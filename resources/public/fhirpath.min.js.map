{"version":3,"file":"./fhirpath.min.js","mappings":"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A,YACAA,EAAQ0a,MAAQ,EAAhB1a,MACAA,EAAQ2E,YAAc,EAAtB3E,MAAAA,uqDC5BA,IAAMq+C,EAASl/D,EAAQ,MAIjBm/D,EAAgB,CAAC,WACnB,oBACA,oBACA,mCACA,4BACA,qBACA,oBACA,qBACA,oBACA,4BACA,qCACA,sCACA,sCACA,sCACA,mCACA,eACA,gBACA,8BACA,yBACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,sBACA,sBACA,sBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,2BACA,yBACA,yBACA,2BACA,yBACA,0BACA,0BACA,0BACA,8BACA,0BACA,0BACA,uBACA,0BACA,yBACA,mBACA,0BACA,mBACA,yBACA,gEACA,mBACA,iCACA,wBACA,sCACA,eACA,gBACA,iBACA,eACA,eACA,eACA,eACA,eACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,eACA,eACA,eACA,iBACA,gBACA,eACA,eACA,eACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,eACA,eACA,eACA,eACA,eACA,iBACA,kBACA,iBACA,eACA,eACA,gBACA,eACA,gBACA,eACA,eACA,eACA,eACA,eACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,eACA,iBACA,eACA,gBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,iBACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,eACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,iBACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,kBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,iBACA,eACA,iBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,oBACA,iBACA,kBACA,iBACA,iBACA,gBACA,eACA,eACA,eACA,eACA,gBACA,eACA,kBACA,iBACA,iBACA,kBACA,mBACA,iBACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,kBACA,kBACA,mBACA,eACA,eACA,gBACA,gBACA,eACA,eACA,eACA,eACA,iBACA,eACA,eACA,eACA,gBACA,gBACA,gBACA,eACA,eACA,eACA,gBACA,gBACA,eACA,eACA,iBACA,eACA,eACA,eACA,mBACA,eACA,eACA,iBACA,gBACA,eACA,gBACA,eACA,eACA,eACA,eACA,iBACA,gBACA,kBACA,eACA,eACA,iBACA,eACA,mBACA,eACA,eACA,gBACA,gBACA,iBACA,eACA,eACA,YAAoD59D,KAAK,IAGvDkkB,GAAM,IAAIy5C,EAAOz5C,IAAImG,iBAAkBoC,YAAYmxC,GAEnDC,EAAiB35C,EAAI4T,gBAAgB92B,KAAK,SAAC88D,EAAIlhD,GAAK,OAAK,IAAI+gD,EAAO3uC,IAAI4oB,IAAIkmB,EAAIlhD,EAAM,IAEtFmhD,EAAa,SAAAC,yRAAA1hD,CAAAyhD,EAAAC,GAAA,QAAAzhD,EAAAC,EAAAuhD,GAqCf,SAAAA,EAAYh3C,GAAO,IAAAta,EAEiG,mGAFjG5N,CAAA,KAAAk/D,IACftxD,EAAA8P,EAAAG,KAAA,KAAMqK,IACDK,QAAU,IAAIu2C,EAAOz5C,IAAI0jB,kBAAiBzgB,EAAA1a,GAAOyX,EAAK25C,EAAgB,IAAIF,EAAO1sC,wBAA0BxkB,CACpH,CAIC,SAJAsxD,KAAA,EAAAr+D,I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AAAC,MACA,SAA6BmlB,GAC7B,GAEA,CAAAplB,IAAA,8BAAAC,MACA,SAA4BmlB,GAC5B,GAGA,CAAAplB,IAAA,qBAAAC,MACA,SAAmBmlB,GACnB,GAEA,CAAAplB,IAAA,oBAAAC,MACA,SAAkBmlB,GAClB,GAGA,CAAAplB,IAAA,2BAAAC,MACA,SAAyBmlB,GACzB,GAEA,CAAAplB,IAAA,0BAAAC,MACA,SAAwBmlB,GACxB,GAGA,CAAAplB,IAAA,kBAAAC,MACA,SAAgBmlB,GAChB,GAEA,CAAAplB,IAAA,iBAAAC,MACA,SAAemlB,GACf,0EAACk9C,CAAA,CAhXoB,CAHPvjE,EAAQ,MAGe6/C,KAAKr0B,mBAqX3C5K,EAAOC,QAAU0iD,27ECxXjB,IAAMrE,EAASl/D,EAAQ,MACjBujE,EAAmBvjE,EAAQ,KAE3Bm/D,EAAgB,CAAC,WACnB,mBACA,qBACA,sCACA,yBACA,eACA,iBACA,eACA,eACA,eACA,eACA,eACA,eACA,qBACA,gBACA,gBACA,iBACA,iBACA,mBACA,gCACA,oCACA,qBACA,qBACA,kBACA,gBACA,oBACA,iBACA,kBACA,eACA,mBACA,kBACA,kBACA,oBACA,eACA,eACA,eACA,eACA,kBACA,oBACA,uBACA,kBACA,+BACA,0BACA,0BACA,yBACA,yBACA,qBACA,qBACA,yBACA,qBACA,uBACA,oBACA,0BACA,oBACA,oBACA,kBACA,oBACA,oBACA,mBACA,oBACA,yBACA,oBACA,kBACA,oBACA,yBACA,wBACA,sBACA,kBACA,oBACA,qBACA,oBACA,kBACA,uBACA,oBACA,oBACA,oBACA,oBACA,oBACA,gBACA,oBACA,gBACA,eACA,eACA,gBACA,eACA,kBACA,eACA,eACA,iBACA,kBACA,eACA,eACA,eACA,eACA,eACA,eACA,wBACA,QAA4B59D,KAAK,IAG/BkkB,GAAM,IAAIy5C,EAAOz5C,IAAImG,iBAAkBoC,YAAYmxC,GAEnDC,EAAiB35C,EAAI4T,gBAAgB92B,KAAK,SAAC88D,EAAIlhD,GAAK,OAAK,IAAI+gD,EAAO3uC,IAAI4oB,I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","sources":["webpack://fhirpath/../source/config.js","webpack://fhirpath/../source/dimension.js","webpack://fhirpath/../source/jsonArrayPack.js","webpack://fhirpath/../source/prefix.js","webpack://fhirpath/../source/prefixTables.js","webpack://fhirpath/../source/ucumFunctions.js","webpack://fhirpath/../source/ucumInternalUtils.js","webpack://fhirpath/../source/ucumJsonDefs.js","webpack://fhirpath/../source/ucumLhcUtils.js","webpack://fhirpath/../source/ucumPkg.js","webpack://fhirpath/../source/unit.js","webpack://fhirpath/../source/unitString.js","webpack://fhirpath/../source/unitTables.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/BufferedTokenStream.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/CommonTokenFactory.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/CommonTokenStream.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/InputStream.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/IntervalSet.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/LL1Analyzer.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/Lexer.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/Parser.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/ParserRuleContext.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/PredictionContext.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/Recognizer.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/RuleContext.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/Token.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/Utils.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/ATN.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/ATNConfig.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/ATNSimulator.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/ATNState.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/ATNType.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/LexerAction.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/PredictionMode.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/SemanticContext.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/Transition.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/atn/index.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/dfa/DFA.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/dfa/DFASerializer.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/dfa/DFAState.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/dfa/index.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/error/ErrorListener.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/error/ErrorStrategy.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/error/Errors.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/error/index.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/polyfills/codepointat.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/tree/Tree.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/tree/Trees.js","webpack://fhirpath/../node_modules/antlr4/src/antlr4/tree/index.js","webpack://fhirpath/../src/additional.js","webpack://fhirpath/../src/aggregate.js","webpack://fhirpath/../src/collections.js","webpack://fhirpath/../src/combining.js","webpack://fhirpath/../src/constants.js","webpack://fhirpath/../src/datetime.js","webpack://fhirpath/../src/deep-equal.js","webpack://fhirpath/../src/equality.js","webpack://fhirpath/../src/existence.js","webpack://fhirpath/../src/factory.js","webpack://fhirpath/../src/fhirpath.js","webpack://fhirpath/../src/filtering.js","webpack://fhirpath/../src/hash-object.js","webpack://fhirpath/../src/logic.js","webpack://fhirpath/../src/math.js","webpack://fhirpath/../src/misc.js","webpack://fhirpath/../src/navigation.js","webpack://fhirpath/../src/numbers.js","webpack://fhirpath/../src/parser/antlr4-index.js","webpack://fhirpath/../src/parser/generated/FHIRPathLexer.js","webpack://fhirpath/../src/parser/generated/FHIRPathListener.js","webpack://fhirpath/../src/parser/generated/FHIRPathParser.js","webpack://fhirpath/../src/parser/index.js","webpack://fhirpath/../src/polyfill.js","webpack://fhirpath/../src/sdc-ig-supplements.js","webpack://fhirpath/../src/strings.js","webpack://fhirpath/../src/terminologies.js","webpack://fhirpath/../src/types.js","webpack://fhirpath/../src/utilities.js","webpack://fhirpath/../node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js","webpack://fhirpath/../node_modules/date-fns/add_days/index.js","webpack://fhirpath/../node_modules/date-fns/add_hours/index.js","webpack://fhirpath/../node_modules/date-fns/add_milliseconds/index.js","webpack://fhirpath/../node_modules/date-fns/add_minutes/index.js","webpack://fhirpath/../node_modules/date-fns/add_months/index.js","webpack://fhirpath/../node_modules/date-fns/add_seconds/index.js","webpack://fhirpath/../node_modules/date-fns/add_weeks/index.js","webpack://fhirpath/../node_modules/date-fns/add_years/index.js","webpack://fhirpath/../node_modules/date-fns/get_days_in_month/index.js","webpack://fhirpath/../node_modules/date-fns/is_date/index.js","webpack://fhirpath/../node_modules/date-fns/parse/index.js","webpack://fhirpath/../node_modules/is-finite/index.js","webpack://fhirpath/../node_modules/is-integer/index.js","webpack://fhirpath/webpack/bootstrap","webpack://fhirpath/webpack/runtime/global","webpack://fhirpath/webpack/startup"],"sourcesContent":["/*\n * This defines the namespace for the UCUM classes and provides\n * a place for the definition of global variables and constants.\n *\n * The javascript for this UCUM implementation uses syntax as\n * defined by the ECMAScript 6 standard\n */\n\nexport var Ucum = {\n\n  /**\n   *  Flag indicating whether or not we're using case sensitive labels\n   *  I don't think we need this.  I think we're just going with\n   *  case sensitive, per Clem.   Gunther's code has this flag, but I\n   *  am removing it, at least for now.  lm, 6/2016\n   */\n  //caseSensitive_: true ,\n\n  /**\n   *  The number of elements in a Dimension array.   Currently this\n   *  is set as a configuration variable, but when we get to the point\n   *  of loading the unit definitions from a file, this value will be\n   *  set from that.\n   */\n  dimLen_: 7,\n\n\n  /**\n   *  The characters used as valid operators in a UCUM unit expression,\n   *  where '.' is for multiplication and '/' is for division.\n   */\n  validOps_: ['.', '/'],\n\n\n  /**\n   * The string used to separate a unit code and unit name when they\n   * are displayed together\n   */\n  codeSep_ : ': ',\n\n  // Message text variations for validation methods and conversion methods\n  valMsgStart_ : 'Did you mean ',\n  valMsgEnd_ : '?' ,\n  cnvMsgStart_ : 'We assumed you meant ',\n  cnvMsgEnd_ : '.',\n\n\n/**\n   * Default opening string used to emphasize portions of error messages.\n   * Used when NOT displaying messages on a web site, i.e., for output\n   * from the library methods or to a file.\n   */\n  openEmph_ : ' ->',\n\n  /**\n   * Default closing string used to emphasize portions of error messages.\n   * Used when NOT displaying messages on a web site, i.e., for output\n   * from the library methods or to a file.\n   */\n  closeEmph_ : '<- ' ,\n\n  /**\n   * Opening HTML used to emphasize portions of error messages.  Used when\n   * displaying messages on a web site; should be blank when output is\n   * to a file.\n   */\n  openEmphHTML_ : ' <span class=\"emphSpan\">',\n\n  /**\n   * Closing HTML used to emphasize portions of error messages.  Used when\n   * displaying messages on a web site; should be blank when output is\n   * to a file.\n   */\n  closeEmphHTML_ : '</span> ' ,\n\n  /**\n   * Message that is displayed when annotations are included in a unit\n   * string, to let the user know how they are interpreted.\n   */\n  bracesMsg_ : 'FYI - annotations (text in curly braces {}) are ignored, ' +\n               'except that an annotation without a leading symbol implies ' +\n               'the default unit 1 (the unity).',\n\n  /**\n   * Message that is displayed or returned when a conversion is requested\n   * for two units where (only) a mass<->moles conversion is appropriate\n   * but no molecular weight was specified.\n   */\n  needMoleWeightMsg_ : 'Did you wish to convert between mass and moles?  The ' +\n                       'molecular weight of the substance represented by the ' +\n                       'units is required to perform the conversion.',\n\n  /**\n   * Hash that matches unit column names to names used in the csv file\n   * that is submitted to the data updater.\n   */\n  csvCols_ : {\n    'case-sensitive code' : 'csCode_',\n    'LOINC property' : 'loincProperty_',\n    'name (display)' : 'name_',\n    'synonyms' : 'synonyms_',\n    'source' : 'source_',\n    'category' : 'category_',\n    'Guidance' : 'guidance_'\n  } ,\n\n  /**\n   * Name of the column in the csv file that serves as the key\n   */\n  inputKey_ : 'case-sensitive code' ,\n\n  /**\n   * Special codes that contain operators within brackets.  The operator\n   * within these codes causes them to parse incorrectly if they are preceded\n   * by a prefix, because the parsing algorithm splits them up on the operator.\n   * So we use this object to identify them and substitute placeholders to\n   * avoid that.\n   */\n   specUnits_ : { 'B[10.nV]' : 'specialUnitOne',\n                  '[m/s2/Hz^(1/2)]' : 'specialUnitTwo'}\n} ;\n\n\n","/**\n * This class implements an object containing the vector of exponents for\n * a unit and its operations for addition, subtraction, and multiplication\n * with a scalar.\n *\n * This object should exist for each unit that can be expressed as a\n * vector of numbers.   This excludes arbitrary units, e.g., (10*23), and\n * units that are not numbers but are an expression based solely on numbers,\n * e.g., mol (mole) which is based on 10*23.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n */\nvar UC = require('./config.js');\nvar isInteger = require(\"is-integer\");\nexport class Dimension {\n\n  /**\n   * Constructor.\n   *\n   * @param dimSetting an optional parameter that may be:\n   *  null, which means that the dimVec_ attribute for this object will be null; or\n   *  an array, which must be the length defined by Ucum.dimLen_, and\n   *    whose contents will be copied to this new object's vector; or\n   *  an integer, which must be between 0 and 1 less than the vector length\n   *    defined by Ucum.dimLen_.  This new object's vector will be\n   *    initialized to zero for all elements except the one whose index\n   *    matches the number passed in.  That element will be set to one.\n\n   * @throws an error if the dimSetting parameter does not meet the types\n   *  listed above.\n   *  An error will also be thrown if Ucum.dimLen_ has not been set yet,\n   *  i.e., is still zero.   Currently that won't happen, because the\n   *  value is set in the config.js file.  But further down the road\n   *  the setting will come from a definitions input file, so we check\n   *  here anyway.\n   *\n   */\n  constructor(dimSetting) {\n\n    if (UC.Ucum.dimLen_ === 0) {\n      throw(new Error('Dimension.setDimensionLen must be called before ' +\n      'Dimension constructor'));\n    }\n    if (dimSetting === undefined || dimSetting === null) {\n      this.assignZero() ;\n    }\n    else if (dimSetting instanceof Array) {\n      if (dimSetting.length !== UC.Ucum.dimLen_) {\n        throw(new Error('Parameter error, incorrect length of vector passed to ' +\n            `Dimension constructor, vector = ${JSON.stringify(dimSetting)}`));\n      }\n      this.dimVec_ = [];\n      for (let d = 0; d < UC.Ucum.dimLen_; d++)\n        this.dimVec_.push(dimSetting[d]);\n    }\n\n    // In es6 this should be Number.isInteger(dimSetting).  But Babel\n    // doesn't transpile that correctly, so we need to use the isInteger\n    // module.  :0\n    else if (isInteger(dimSetting)) {\n      if (dimSetting < 0 || dimSetting >= UC.Ucum.dimLen_) {\n        throw(new Error('Parameter error, invalid element number specified for ' +\n        'Dimension constructor'));\n      }\n      this.assignZero() ;\n      this.dimVec_[dimSetting] = 1;\n    }\n  } // end constructor\n\n\n  /**\n   * Sets the element at the specified position to a specified value.  The\n   * default value is 1.  If the dimension vector is null when this is called\n   * a zero-filled vector is created and then the indicated position is set.\n   *\n   * @param indexPos the index of the element to be set\n   * @param value the value to assign to the specified element; optional,\n   *  default value is 1\n   * @throws an exception if the specified position is invalid, i.e., not a\n   *   number or is less than 0 or greater than Ucum.dimLen_\n   **/\n  setElementAt(indexPos, value) {\n\n    if (!isInteger(indexPos) ||\n        indexPos < 0 || indexPos >= UC.Ucum.dimLen_) {\n      throw(new Error(`Dimension.setElementAt called with an invalid index ` +\n      `position (${indexPos})`));\n    }\n\n    if (!this.dimVec_) {\n      this.assignZero();\n    }\n    if (value === undefined || value === null)\n      value = 1 ;\n\n    this.dimVec_[indexPos] = value;\n  }\n\n\n  /**\n   * Gets the value of the element at the specified position\n   *\n   * @param indexPos the index of the element whose value is to be returned\n   * @return the value of the element at indexPos, or null if the dimension\n   *  vector is null\n   * @throws an exception if the specified position is invalid, i.e., not a\n   *   number or is less than 0 or greater than Ucum.dimLen_\n   **/\n  getElementAt(indexPos) {\n    if (!isInteger(indexPos) ||\n        indexPos < 0 || indexPos >= UC.Ucum.dimLen_) {\n      throw(new Error(`Dimension.getElementAt called with an invalid index ` +\n      `position (${indexPos})`));\n    }\n    let ret = null;\n    if (this.dimVec_)\n      ret = this.dimVec_[indexPos];\n    return ret;\n  }\n\n\n  /**\n   * This returns the value of the property named by the parameter\n   * passed in.  Although we currently only have one property, dimVec_,\n   * that this will get, it's possible that we'll have additional\n   * properties.   If we don't this could just be replaced by a\n   * getVector function.\n   *\n   * @param propertyName name of the property to be returned, with\n   *        or without the trailing underscore.\n   * @return the requested property, if found for this Dimension\n   * @throws an error if the property is not found for this Dimension\n   */\n  getProperty(propertyName) {\n    let uProp = propertyName.charAt(propertyName.length - 1) === '_' ? propertyName : propertyName + '_';\n\n    return this[uProp] ;\n\n  } // end getProperty\n\n\n  /**\n   * Return a string that represents the dimension vector.  Returns null if\n   * the dimension vector is null.\n   *\n   * @return the string that represents the dimension vector.  The\n   *         values are enclosed in square brackets, each separated\n   *         by a comma and a space\n   **/\n  toString() {\n    let ret = null ;\n    if (this.dimVec_)\n      ret = '[' + this.dimVec_.join(', ') + ']';\n    return ret ;\n  }\n\n\n  /**\n   * Adds the vector of the dimension object passed in to this\n   * dimension object's vector.  This object's vector is changed.\n   * If either dimension vector is null, no changes are made to this object.\n   *\n   *\n   * @param dim2 the dimension whose vector is to be added to this one\n   * @return this object\n   * @throws an exception if dim2 is not a Dimension object\n   **/\n  add(dim2) {\n    if (!dim2 instanceof Dimension) {\n      throw(new Error(`Dimension.add called with an invalid parameter - ` +\n      `${typeof dim2} instead of a Dimension object`));\n    }\n    if (this.dimVec_ && dim2.dimVec_) {\n      for (let i = 0; i < UC.Ucum.dimLen_; i++)\n        this.dimVec_[i] += dim2.dimVec_[i];\n    }\n    return this;\n  }\n\n\n  /**\n   * Subtracts the vector of the dimension object passed in from this\n   * dimension object's vector.  This object's vector is changed.\n   * If either dimension vector is null, no changes are made to this object.\n   *\n   * @param dim2 the dimension whose vector is to be subtracted from this one\n   * @return this object\n   * @throws an exception if dim2 is not a Dimension object\n   **/\n  sub(dim2) {\n    if (!dim2 instanceof Dimension) {\n      throw(new Error(`Dimension.sub called with an invalid parameter - ` +\n      `${typeof dim2} instead of a Dimension object`));\n    }\n    if (this.dimVec_ && dim2.dimVec_) {\n      for (let i = 0; i < UC.Ucum.dimLen_; i++)\n        this.dimVec_[i] -= dim2.dimVec_[i];\n    }\n    return this;\n  }\n\n\n  /**\n   * Inverts this dimension object's vector (by multiplying each element\n   * by negative 1).  This object's vector is changed - unless it is null,\n   * in which case it stays that way.\n   *\n   * @return this object\n   **/\n  minus() {\n    if (this.dimVec_) {\n      for (let i = 0; i < UC.Ucum.dimLen_; i++)\n        this.dimVec_[i] = -this.dimVec_[i];\n    }\n    return this;\n  }\n\n\n  /**\n   * Multiplies this dimension object's vector with a scalar.  This is used\n   * when a unit is raised to a power.  This object's vector is changed unless\n   * the vector is null, in which case it stays that way.\n   *\n   * @param s the scalar to use\n   * @return this object\n   * @throws an exception if s is not a number\n   */\n  mul(s) {\n    if (!isInteger(s)) {\n      throw(new Error(`Dimension.sub called with an invalid parameter - ` +\n      `${typeof dim2} instead of a number`));\n    }\n    if (this.dimVec_) {\n      for (let i = 0; i < UC.Ucum.dimLen_; i++)\n        this.dimVec_[i] *= s;\n    }\n    return this;\n  }\n\n\n  /**\n   * Tests for equality of this dimension object's vector and that of\n   * the dimension object passed in.  If the dimension vector for one of\n   * the objects is null, the dimension vector for the other object must\n   * also be null for the two to be equal.  (I know - duh.  still)\n   *\n   * @param dim2 the dimension object whose vector is to be compared to this one\n   * @return true if the two vectors are equal; false otherwise.\n   * @throws an exception if dim2 is not a Dimension object\n   */\n  equals(dim2) {\n    if (!dim2 instanceof Dimension) {\n      throw(new Error(`Dimension.equals called with an invalid parameter - ` +\n      `${typeof dim2} instead of a Dimension object`));\n    }\n    let isEqual = true ;\n    let dimVec2 = dim2.dimVec_;\n    if (this.dimVec_ && dimVec2) {\n      for (let i = 0; isEqual && i < UC.Ucum.dimLen_; i++)\n        isEqual = (this.dimVec_[i] === dimVec2[i]);\n    }\n    else {\n      isEqual = (this.dimVec_ === null && dimVec2 === null);\n    }\n    return isEqual;\n  }\n\n\n  /**\n   * Assigns the contents of the vector belonging to the dimension object\n   * passed in to this dimension's vector.  If this dimension vector is null\n   * and the other is not, this one will get the contents of the other.  If\n   * this dimension vector is not null but the one passed in is null, this\n   * one will be set to null.\n   *\n   * @param dim2 the dimension object with the vector whose contents are\n   *  to be assigned to this dimension's vector\n   * @return this object (not sure why)\n   * @throws an exception if dim2 is not a Dimension object\n   */\n  assignDim(dim2) {\n\n    if (!dim2 instanceof Dimension) {\n      throw(new Error(`Dimension.assignDim called with an invalid parameter - ` +\n      `${typeof dim2} instead of a Dimension object`));\n    }\n    if (dim2.dimVec_ === null)\n      this.dimVec_ = null;\n    else {\n      if (this.dimVec_ === null) {\n        this.dimVec_ = [] ;\n      }\n      for (let i = 0; i < UC.Ucum.dimLen_; i++)\n        this.dimVec_[i] = dim2.dimVec_[i];\n    }\n    return this;\n  }\n\n\n  /**\n   * Sets all elements of this dimension object's vector to zero.\n   * If this object's vector is null, it is created as a zero-filled vector.\n   *\n   * @return this object (not sure why)\n   */\n  assignZero() {\n    if (this.dimVec_ === null || this.dimVec_ === undefined)\n      this.dimVec_ = [];\n\n    for (let i = 0; i < UC.Ucum.dimLen_; i++) {\n      this.dimVec_.push(0);\n    }\n    return this;\n  }\n\n\n  /**\n   * Tests for a dimension vector set to all zeroes.\n   *\n   * @return true if exponents (elements) of this dimension's vector are all\n   * zero; false otherwise (including if the current vector is null).\n   *\n   */\n  isZero() {\n    let allZero = this.dimVec_ !== null ;\n    if (this.dimVec_) {\n      for (let i = 0; allZero && i < UC.Ucum.dimLen_; i++)\n        allZero = this.dimVec_[i] === 0;\n    }\n    return allZero;\n  }\n\n\n  /**\n   * Tests for a Dimension object with no dimension vector (dimVec_ is null).\n   *\n   * @return true the dimension vector is null; false if it is not\n   *\n   */\n  isNull() {\n    return (this.dimVec_ === null);\n  }\n\n\n  /**\n   * Creates and returns a clone of this Dimension object\n   *\n   * @return the clone\n   */\n  clone() {\n    let that = new Dimension();\n    that.assignDim(this);\n    return that;\n  }\n\n} // end Dimension class\n","/**\n * This file provides functions to reduce the size of an array of objects of the same structure in JSON.\n */\nconst pushFn = Array.prototype.push;\n\nfunction isObject(value) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Makes human readable config used to pack/unpack array of objects of the same structure to store with packed data.\n * @param {Object} refObj - reference item of array of objects of the same structure\n * @returns {Array}\n */\nfunction createConfig(refObj) {\n  return Object.keys(refObj).reduce((config, key) => {\n    if (isObject(refObj[key])) {\n      pushFn.apply(config, createConfig(refObj[key]).map(keyTail => [key, ...[].concat(keyTail)]));\n    } else {\n      config.push(key);\n    }\n    return config;\n  }, [])\n}\n\n/**\n * Prepares config created with createConfig function to use in packItem/unpackItem functions.\n * @param {Array} config\n * @returns {Array}\n */\nfunction prepareConfig(config) {\n  return config.map(key => Array.isArray(key) ? key : [key]);\n}\n\n/**\n * Converts an object to an array of values in the order of keys from configuration array.\n * @param {Array} config - configuration array\n * @param {Object} item - input object\n * @returns {Array}\n */\nfunction packItem(config, item) {\n  if (config.join() !== prepareConfig(createConfig(item)).join()) {\n    throw new Error('Object of unusual structure')\n  }\n\n  return config.map(keyArr => {\n    let place = item;\n    keyArr.forEach(key => {\n      place = place[key];\n      if (place === undefined) {\n        throw new Error('Object of unusual structure')\n      }\n    });\n    return place;\n  });\n}\n\n/**\n * Performs the reverse of packItem function.\n * @param {Array} config - configuration array\n * @param {Array} item - input object\n * @returns {Object}\n */\nfunction unpackItem(config, item) {\n  let result = {};\n\n  config.forEach((keyArr, i) => {\n    let place = result;\n    for (let i = 0; i < keyArr.length - 1; i++) {\n      place = place[keyArr[i]] = place[keyArr[i]] || {};\n    }\n    place[keyArr[keyArr.length - 1]] = item[i];\n  });\n\n  return result;\n}\n\n/**\n * Reduces size of an array of objects of the same structure before serialize it to JSON\n * @param {Array} arr\n * @returns {Object}\n */\nexport function packArray(arr) {\n  if (arr && arr.length) {\n    const config = createConfig(arr[0]),\n      _config = prepareConfig(config);\n\n    if (config.length) {\n      return {\n        config: config,\n        data: arr.map(packItem.bind(null, _config))\n      };\n    }\n  }\n\n  return {\n    config: [],\n    data: arr\n  };\n}\n\n/**\n * Restores an array of objects of the same structure after deserializing this object from JSON\n * @param {Object} obj\n * @returns {Array}\n */\nexport function unpackArray(obj) {\n  const config = obj && obj.config;\n\n  if (config) {\n    if (config.length && obj.data) {\n      const _config = prepareConfig(config);\n\n      return obj.data.map(unpackItem.bind(null, _config));\n    } else {\n      return obj.data;\n    }\n  }\n\n  return obj;\n}","/**\n * Prefix objects are defined in this file.\n */\n\n/**\n * This class implements the prefix object.  Prefixes are used as multipliers\n * for units, e.g., km for kilometers\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\nvar Ucum = require('./config.js');\n\nexport class Prefix {\n\n  /**\n   * Creates a single prefix object.\n   *\n   * @param attrs a hash of the values to use in creating the prefix object.\n   *  They should be:\n   *   code_ - which is the case-sensitive code used for the prefix,\n   *    e.g., k for kilo\n   *   ciCode_ - which is the case-insensitive code used for the prefix,\n   *    e.g., K for kilo\n   *   name_ - which is the name of the prefix, e.g., kilo\n   *   printSymbol_ - which is the print symbol for the prefix, e.g., k for kilo\n   *   value_ - which is teh value to use in multiplying the magnitude of\n   *    a unit, e.g., for a prefix of c the value will be .01.\n   *   exp_ - which is the exponent used to get the value. For decimal based\n   *    prefixes the base is 10 and the exp_ is applied to 10, e.g., for a\n   *    prefix of c, the exponent will be -2.  For prefixes that are not\n   *    decimal based, this will be null (but must not be undefined).\n   *\n   * @throws an error if the not all required parameters are provided\n   */\n  constructor(attrs) {\n\n    if (attrs['code_'] === undefined || attrs['code_'] === null ||\n        attrs['name_'] === undefined || attrs['name_'] === null ||\n        attrs['value_'] === undefined || attrs['value_'] === null ||\n        attrs['exp_'] === undefined) {\n      throw(new Error('Prefix constructor called missing one or more parameters.  ' +\n      'Prefix codes (cs or ci), name, value and exponent must all be specified ' +\n      'and all but the exponent must not be null.'));\n    }\n\n    /**\n     * The prefix code, e.g., k for kilo.  This should be the case-sensitive\n     * code.  Since there's no way to check to see if it's the case-sensitive\n     * one as opposed to the case-insensitive one (because although\n     * case-insensitive codes all seem to be uppercase, some case-sensitive\n     * codes are also all uppercase), we'll just have to believe that the\n     * right one was passed in.\n     */\n    this.code_ = attrs['code_'];\n\n    /**\n     * The case-insensitive code, e.g., K for kilo\n     */\n    this.ciCode_ = attrs['ciCode_'];\n\n    /**\n     * The prefix name, e.g., kilo\n     */\n    this.name_ = attrs['name_'];\n\n    /**\n     * The printSymbol for the prefix, e.g., k for kilo\n     */\n    this.printSymbol_ = attrs['printSymbol_'];\n\n    /**\n     * The value to use in multiplying the magnitude of a unit\n     */\n    if (typeof attrs['value_'] === 'string')\n      this.value_ = parseFloat(attrs['value_']);\n    else\n      this.value_ = attrs['value_'] ;\n\n    /**\n     * The exponent used to create the value from 10.  For prefixes that are\n     * not based on 10, this will be null.\n     */\n    this.exp_ = attrs['exp_'] ;\n\n  } // end constructor\n\n\n  /**\n   * Returns the value for the current prefix object\n   * @return the value for the prefix object with the specified code\n   * */\n  getValue() {\n    return this.value_;\n  }\n\n\n  /**\n   * Returns the prefix code for the current prefix object\n   * @return the code for the current prefix object\n   */\n  getCode() {\n    return this.code_;\n  }\n\n\n  /**\n   * Returns the case-insensitive code for the current prefix object\n   * @return the case_insensitive code for the current prefix object\n   */\n  getCiCode() {\n    return this.ciCode_;\n  }\n\n\n  /**\n   * Returns the prefix name for the current prefix object\n   * @return the name for the current prefix object\n   */\n  getName() {\n    return this.name_;\n  }\n\n\n  /**\n   * Returns the print symbol for the current prefix object\n   * @return the print symbol for the current prefix object\n   */\n  getPrintSymbol() {\n    return this.printSymbol_;\n  }\n\n\n  /**\n   * Returns the exponent for the current prefix object\n   * @return the exponent for the current prefix object\n   */\n  getExp() {\n    return this.exp_;\n  }\n\n\n  /**\n   * Provides way to tell if one prefix equals another.  The second prefix\n   * must match all attribute values.\n   *\n   * @param prefix2 prefix object to check for a match\n   * @return true for a match; false if one or more attributes don't match\n   */\n  equals(prefix2) {\n    return this.code_ === prefix2.code_ &&\n            this.ciCode_ === prefix2.ciCode_ &&\n            this.name_ === prefix2.name_ &&\n            this.printSymbol_ === prefix2.printSymbol_ &&\n            this.value_ === prefix2.value_ &&\n            this.exp_ === prefix2.exp_ ;\n  }\n} // end Prefix class\n","/**\n * The tables of defined prefixes is defined in this file.\n */\n\n/**\n * This class implements the table of multiplier prefixes.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\nexport class PrefixTablesFactory {\n\n  /**\n   * Constructor.  This creates the empty PrefixTable hashes once.\n   * There is one hash whose key is the prefix code and one whose\n   * key is the prefix value.\n   *\n   * Implementation of this as a singleton is based on the UnitTables\n   * implementation.  See that class for details.\n   */\n  constructor(){\n    this.byCode_ = {} ;\n    this.byValue_ = {};\n  }\n\n\n  /**\n   * Provides the number of prefix objects in each table\n   * @returns count of the number of prefix objects in each table\n   */\n  prefixCount() {\n    return Object.keys(this.byCode_).length ;\n  }\n\n\n  /**\n   * This is used to get all prefix objects by value.  Currently it is used\n   * to create a csv file with all prefixes and units.\n   * @returns csv string containing all prefix objects, ordered by value.\n   */\n  allPrefixesByValue() {\n    let prefixBuff = '';\n    let pList = Object.keys(this.byValue_);\n    //pList.sort() ;\n    let pLen = pList.length;\n    for (let p = 0; p < pLen; p++) {\n      let pfx = this.getPrefixByValue(pList[p]) ;\n      prefixBuff += pfx.code_ + ',' + pfx.name_ + ',,' + pfx.value_ + '\\r\\n';\n    }\n    return prefixBuff ;\n  }\n\n  /**\n   * This is used to get all prefix objects.  Currently it is used\n   * to get the objects to write to the json ucum definitions file\n   * that is used to provide prefix and unit definition objects for\n   * conversions and validations.\n   *\n   * @returns an array containing all prefix objects, ordered by code.\n   */\n  allPrefixesByCode() {\n    let prefixList = [];\n    let pList = Object.keys(this.byCode_);\n    pList.sort() ;\n    let pLen = pList.length;\n    for (let p = 0; p < pLen; p++) {\n      prefixList.push(this.getPrefixByCode(pList[p])) ;\n    }\n    return prefixList ;\n  }\n\n  /**\n   * Adds a prefix object to the tables\n   *\n   * @param prefixObj the object to be added to the tables\n   */\n  add(prefixObj){\n    this.byCode_[prefixObj.getCode()] = prefixObj;\n    this.byValue_[prefixObj.getValue()] = prefixObj;\n  }\n\n\n  /**\n   * Tests whether a prefix object is found for a specified code.  This\n   * is used to determine whether or not a prefix object has been created\n   * for the code.\n   *\n   * @param code the code to be used to find the prefix object\n   * @return boolean indicating whether or not a prefix object was found\n   *  for the specified code\n   */\n  isDefined(code) {\n    return this.byCode_[code] !== null && this.byCode_[code] !== undefined ;\n  }\n\n\n  /**\n   * Obtains a prefix object for a specified code.\n   *\n   * @param code the code to be used to find the prefix object\n   * @return the prefix object found, or null if nothing was found\n   */\n  getPrefixByCode(code) {\n    return this.byCode_[code];\n  }\n\n\n  /**\n   * Obtains a prefix object for a specified value.\n   *\n   * @param value the value to be used to find the prefix object\n   * @return the prefix object found, or null if nothing was found\n   */\n  getPrefixByValue(value) {\n    return this.byValue_[value];\n  }\n\n} // end PrefixTablesFactory class\n\n\n// Create a singleton instance and (to preserve the existing API) an object that\n// provides that instance via getInstance().\nvar prefixTablesInstance = new PrefixTablesFactory();\nexport const PrefixTables = {\n  getInstance: function() {\n    return prefixTablesInstance;\n  }\n}\n","/*\n * This class manages the special functions used by some units.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\n\nclass UcumFunctions {\n\n  /**\n   * Constructor\n   *\n   * Creates the singleton object that contains the list of functions used\n   * to convert special units.\n   */\n  constructor() {\n\n    // Create the hash containing the function pairs\n    this.funcs = {};\n\n    // Celsius - convert to Celsius from kelvin and from Celsius to kelvin\n    // where kelvin is the base unit for temperature\n    this.funcs['cel'] = {cnvTo   : function(x){return x - 273.15;},\n                      cnvFrom : function(x){return x + 273.15;}};\n\n    // Fahrenheit - convert to Fahrenheit from kelvin and from Fahrenheit to\n    // kelvin - which is the base unit for temperature\n    this.funcs['degf'] = {cnvTo   : function(x){return x - 459.67;},\n                       cnvFrom : function(x){return x + 459.67;}};\n\n    // Reaumur - convert between Reaumur and Kelvin.   Because of the way the\n    // calling code in the Units class is set up (in the convertFrom method),\n    // what is given here as the convertTo function is actually the convert\n    // from method and vice versa.\n    //this.funcs['degre'] = {cnvTo   : function(x){return x + 273.15;},\n    //                    cnvFrom : function(x){return x - 273.15;}};\n    this.funcs['degre'] = {cnvTo   : function(x){return x - 273.15;},\n                        cnvFrom : function(x){return x + 273.15;}};\n\n    // pH - convert to pH from moles per liter and from moles per liter to pH\n    // where a mole is an amount of a substance (a count of particles)\n    this.funcs['ph'] = {cnvTo  : function(x){return - Math.log(x) / Math.LN10;},\n                     cnvFrom : function(x){return Math.pow(10, -x);}};\n\n    // ln - natural logarithm (base e 2.71828) - apply (cnvTo) and invert (cnvFrom)\n    // and 2ln - two times the natural logarithm\n    this.funcs['ln'] = {cnvTo : function(x){return Math.log(x);},\n                     cnvFrom : function(x){return Math.exp(x);}};\n    this.funcs['2ln'] = {cnvTo : function(x){return 2 * Math.log(x);},\n                      cnvFrom : function(x){return Math.exp(x / 2);}};\n\n    // lg - the decadic logarithm (base 10)\n    this.funcs['lg'] = {cnvTo : function(x){return Math.log(x) / Math.LN10;},\n                     cnvFrom : function(x){return Math.pow(10, x);}};\n    this.funcs['10lg'] = {cnvTo : function(x){return 10 * Math.log(x)/Math.LN10;},\n                       cnvFrom : function(x){return Math.pow(10, x / 10);}};\n    this.funcs['20lg'] = {cnvTo : function(x){return 20 * Math.log(x)/Math.LN10;},\n                       cnvFrom : function(x){return Math.pow(10, x / 20);}};\n    // The plain text ucum units file uses '2lg'\n    this.funcs['2lg'] = {cnvTo : function(x){return 2 * Math.log(x)/Math.LN10;},\n                           cnvFrom : function(x){return Math.pow(10, x / 2);}};\n    // The xml essence ucum file uses lgTimes2\n    this.funcs['lgtimes2'] = this.funcs['2lg'];\n\n    // ld - dual logarithm (base 2)\n    this.funcs['ld'] = {cnvTo : function(x){return Math.log(x)/Math.LN2;},\n                     cnvFrom : function(x){return Math.pow(2, x);}};\n\n    // tan - tangent\n    this.funcs['100tan'] = {cnvTo : function(x){return Math.tan(x) * 100;},\n                         cnvFrom : function(x){return Math.atan(x/100);}};\n    // the xml essence ucum file uses both 100tan and tanTimes100\n    this.funcs['tanTimes100'] = this.funcs['100tan'] ;\n\n    // sqrt - square root\n    this.funcs['sqrt'] = {cnvTo : function(x){return Math.sqrt(x);},\n                       cnvFrom : function(x){return x*x;}};\n\n    // inv - inverse\n    this.funcs['inv'] = {cnvTo : function(x){return 1.0 / x;},\n                      cnvFrom : function(x){return 1.0 / x;}};\n\n    // homeopathic potency functions\n    this.funcs['hpX'] = {cnvTo : function(x){return -(this.funcs['lg'](x));},\n                      cnvFrom : function(x){return Math.pow(10, -x);}};\n\n    this.funcs['hpC'] = {cnvTo : function(x){\n                              return -(this.func['ln'](x))/this.funcs['ln'](100);},\n                       cnvFrom : function(x){return Math.pow(100, -x);}};\n\n    this.funcs['hpM'] = {cnvTo : function(x){\n                              return -(this.funcs['ln'](x))/this.funcs['ln'](1000);},\n                      cnvFrom : function(x){return Math.pow(1000, -x);}};\n\n    this.funcs['hpQ'] = {cnvTo : function(x){\n                              return -(this.funcs['ln'](x))/this.funcs['ln'](50000);},\n                      cnvFrom : function(x){return Math.pow(50000, -x);}};\n\n  } // end of constructor\n\n\n  /**\n   * Returns the function with the name specified\n   *\n   * @param fname name of the function to be returned\n   * @return the function with the specified name\n   * @throws an error message if the function is not found\n   */\n  forName(fname) {\n    fname = fname.toLowerCase();\n\n    let f = this.funcs[fname] ;\n    if (f === null)\n      throw(new Error(`Requested function ${fname} is not defined`));\n    return f;\n  }\n\n\n  /**\n   * Returns a flag indicating whether or not the function has been\n   * defined.\n   *\n   * @param fname name of the function in question\n   * @return true if it has been defined; false if not\n   */\n  isDefined(fname) {\n    fname = fname.toLowerCase();\n    return this.funcs[fname] !== null;\n  }\n\n} // end of UcumFunctions class\n\nexport default new UcumFunctions(); // one singleton instance\n","/**\n * Internal utilities used by multiple UCUM classes.  For example,\n * isNumericString is used by both the UnitString and UcumLhcUtils\n * classes.  If it's in the UnitString class the UcumLhcUtils class\n * needs to require the UnitString class.  But the checkSynonyms\n * class is used by the UnitString class - but was in the UcumLhcUtils\n * class.  Requiring the UcumLhcUtils class from the UnitString class\n * made everything break (cyclical requires).\n *\n * So now they're here.\n */\n\n/**\n * This module implements internal ucum utilities.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\n\nvar UnitTables = require('./unitTables.js').UnitTables ;\n\n\n/**\n * This function tests a string to see if it contains only numbers (digits,\n * a period, leading - or +).  This code was taken from a stackoverflow\n * solution:\n * https://stackoverflow.com/questions/175739/is-there-a-built-in-way-in-javascript-to-check-if-a-string-is-a-valid-number/42356340#42356340\n *\n * @params theString\n * @returns true if the string contains only numbers; false otherwise\n */\nexport function isNumericString(theString) {\n  let num = \"\" + theString; //coerce num to be a string\n  return !isNaN(num) && !isNaN(parseFloat(num));\n} // end isNumericString\n\n\n/**\n *  Checks whether a string qualifies as an integer unit.  Section 2.2.8 (\"integer\n *  numbers\", says, \"A positive integer number may appear in place of a simple\n *  unit symbol.  Only a pure string of decimal digits (‘0’–‘9’) is\n *  interpreted as a number.\"\n *  Note:  This leaves open the question of whether \"0\" is a valid unit, since\n *  it is positive, but you can't measure anything in units of zero.\n * @param str the string to check\n */\nexport function isIntegerUnit(str) {\n  return /^\\d+$/.test(str);\n}\n\n\n/**\n * This method accepts a term and looks for units that include it as\n * a synonym - or that include the term in its name.\n *\n * @param theSyn the term to search for.  This is assumed to be\n *  a string and not undefined.  The calling method should do any\n *  necessary checking before calling this.\n * @returns a hash with up to three elements:\n *  'status' contains the status of the request, which can be 'error',\n *    'failed' or succeeded';\n *  'msg' which contains a message for an error or if no units were found; and\n *  'units' which is an array that contains one array for each unit found:\n *    the unit's csCode_, the unit's name_, and the unit's guidance_\n *\n */\nexport function getSynonyms(theSyn) {\n\n  let retObj = {} ;\n  let utab = UnitTables.getInstance();\n  let resp = {} ;\n  resp = utab.getUnitBySynonym(theSyn);\n\n  // If we didn't get any units, transfer the status and message\n  if (!resp['units']) {\n    retObj['status'] = resp['status'];\n    retObj['msg'] = resp['msg'];\n  }\n  else {\n    retObj['status'] = 'succeeded';\n    let aLen = resp['units'].length ;\n    retObj['units'] = [];\n    for (let a = 0; a < aLen; a++) {\n      let theUnit = resp['units'][a];\n      retObj['units'][a] = {\n        'code': theUnit.csCode_,\n        'name': theUnit.name_,\n        'guidance': theUnit.guidance_};\n    } // end do for all units returned\n  } // end if we got a units list\n  return retObj ;\n\n} // end getSynonyms\n\n","/**\n * This class handles opening, reading and loading the JSON file of ucum\n * definitions (prefixes, base units, and unit atoms).\n *\n * @author Lee Mericle\n *\n */\n\nvar Pfx = require(\"./prefix.js\");\nvar PfxT = require(\"./prefixTables.js\");\nvar Un = require(\"./unit.js\");\nvar Utab = require('./unitTables.js');\nvar unpackArray = require('./jsonArrayPack.js').unpackArray;\n\nexport class UcumJsonDefs {\n\n  /**\n   * This method loads the JSON prefix and unit objects into the prefix and\n   * unit tables.\n   *\n   * @returns nothing\n   */\n  loadJsonDefs() {\n    // requiring the file will take care of opening it for use\n    const jsonDefs = require('../data/ucumDefs.min.json');\n    jsonDefs.prefixes = unpackArray(jsonDefs.prefixes);\n    jsonDefs.units = unpackArray(jsonDefs.units);\n\n    if (Utab.UnitTables.getInstance().unitsCount() === 0) {\n\n      let pTab = PfxT.PrefixTables.getInstance();\n      let prefixes = jsonDefs[\"prefixes\"];\n      let plen = prefixes.length;\n\n      for (let p = 0; p < plen; p++) {\n        let newPref = new Pfx.Prefix(prefixes[p]);\n        pTab.add(newPref);\n      }\n\n      let uTab = Utab.UnitTables.getInstance();\n      let units = jsonDefs[\"units\"];\n      let ulen = units.length;\n\n      for (let u = 0; u < ulen; u++) {\n        let newUnit = new Un.Unit(units[u]);\n        uTab.addUnit(newUnit);\n      }\n    } // end if the data has not already been loaded\n  } // end loadJsonDefs\n\n} // end UcumJsonDefs class\n\nvar ucumJsonDefs = new UcumJsonDefs();\nexport {ucumJsonDefs};\n","/**\n * This class provides a single point of access to the LHC UCUM utilities\n *\n * @author Lee Mericle\n *\n */\nvar Ucum = require('./config.js').Ucum;\nimport {ucumJsonDefs} from './ucumJsonDefs.js';\nvar UnitTables = require('./unitTables.js').UnitTables;\nvar UnitString = require('./unitString.js').UnitString;\n\nimport * as intUtils_ from \"./ucumInternalUtils.js\";\n\n/**\n * UCUM external utilities class\n */\nexport class UcumLhcUtils {\n\n  /**\n   * Constructor.  This loads the json prefix and unit definitions if\n   * they haven't been loaded already and creates itself as a singleton object.\n   *\n   */\n  constructor() {\n\n      if (UnitTables.getInstance().unitsCount() === 0) {\n\n        // Load the prefix and unit objects\n        ucumJsonDefs.loadJsonDefs();\n      }\n\n      // Get the UnitString parser that will be used with this instance\n      // of the LHC Utilities\n      this.uStrParser_ = UnitString.getInstance();\n\n  } // end constructor\n\n\n  /**\n   * This method calls the useHTMLInMessages method on the UnitString\n   * object.  It should be called by web applications that use\n   * these utilities.\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useHTMLInMessages(use) {\n    if (use === undefined)\n      use = true ;\n    this.uStrParser_.useHTMLInMessages(use);\n  }\n\n\n  /**\n   * This method calls the useBraceMsgForEachString method on the UnitString\n   * object.  It should be called by web applications where unit\n   * strings are validated individually (as opposed to validating a whole\n   * file of unit strings).\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useBraceMsgForEachString(use) {\n    if (use === undefined)\n      use = true ;\n    this.uStrParser_.useBraceMsgForEachString(use);\n  }\n\n\n  /**\n   * This method validates a unit string.  It first checks to see if the\n   * string passed in is a unit code that is found in the unit codes table.\n   * If it is not found it parses the string to see if it resolves to a\n   * valid unit string.\n   *\n   * If a valid unit cannot be found, the string is tested for some common\n   * errors, such as missing brackets or a missing multiplication operator.\n   * If found, the error is reported in the messages array that is returned.\n   *\n   * If a valid unit cannot be found and an error cannot be discerned, this\n   * may return, if requested, a list of suggested units in the messages\n   * array that is returned.  Suggestions are based on matching the expression\n   * with unit names and synonyms.\n   *\n   * @param uStr the string to be validated\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @param valConv a string indicating if this validation request was initiated\n   *  by a validation task ('validate') or a conversion task ('convert'),\n   *  used only for the demo code, and the default is 'Validator' if the\n   *  parameter is not specified;\n   * @returns an object with five properties:\n   *  'status' will be 'valid' (the uStr is a valid UCUM code), 'invalid'\n   *     (the uStr is not a valid UCUM code, and substitutions or\n   *     suggestions may or may not be returned, depending on what was\n   *     requested and found); or 'error' (an input or programming error\n   *     occurred);\n   *  'ucumCode' the valid ucum code, which may differ from what was passed\n   *    in (e.g., if 'Gauss' is passed in, this will contain 'G') OR null if\n   *    the string was flagged as invalid or an error occurred;\n   *  'msg' is an array of one or more messages, if the string is invalid or\n   *        an error occurred, indicating the problem, or an explanation of a\n   *        substitution such as the substitution of 'G' for 'Gauss', or\n   *        an empty array if no messages were generated;\n   *  'unit' which is null if no unit is found, or a hash for a unit found:\n   *    'code' is the unit's ucum code (G in the above example;\n   *    'name' is the unit's name (Gauss in the above example); and\n   *    'guidance' is the unit's guidance/description data; and\n   *  'suggestions' if suggestions were requested and found, this is an array\n   *     of one or more hash objects.  Each hash contains three elements:\n   *     'msg' which is a message indicating what part of the uStr input\n   *        parameter the suggestions are for;\n   *     'invalidUnit' which is the unit expression the suggestions are\n   *        for; and\n   *     'units' which is an array of data for each suggested unit found.\n   *        Each array will contain the unit code, the unit name and the\n   *        unit guidance (if any).\n   *     If no suggestions were requested and found, this property is not\n   *     returned.\n   */\n  validateUnitString(uStr, suggest, valConv) {\n\n    if (suggest === undefined)\n      suggest = false ;\n\n    if (valConv === undefined)\n      valConv = 'validate' ;\n\n    let resp = this.getSpecifiedUnit(uStr, valConv, suggest);\n    let theUnit = resp['unit'];\n    let retObj = !theUnit ? {'ucumCode': null} :\n      {'ucumCode': resp['origString'],\n       'unit': {'code': theUnit.csCode_,\n                'name': theUnit.name_,\n                'guidance': theUnit.guidance_ }};\n    retObj.status = resp.status;\n    if (resp['suggestions']) {\n      retObj['suggestions'] = resp['suggestions'];\n    }\n    retObj['msg'] = resp['retMsg'];\n    return retObj;\n\n  } // end validateUnitString\n\n\n  /**\n   * This method converts one unit to another\n   *\n   * @param fromUnitCode the unit code/expression/string of the unit to be converted\n   * @param fromVal the number of \"from\" units to be converted to \"to\" units\n   * @param toUnitCode the unit code/expression/string of the unit that the from\n   *  field is to be converted to\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @param molecularWeight the molecular weight of the substance in question\n   *  when a conversion is being requested from mass to moles and vice versa.\n   *  This is required when one of the units represents a value in moles.  It is\n   *  ignored if neither unit includes a measurement in moles.\n   * @returns a hash with six elements:\n   *  'status' that will be: 'succeeded' if the conversion was successfully\n   *     calculated; 'failed' if the conversion could not be made, e.g., if\n   *     the units are not commensurable; or 'error' if an error occurred;\n   *  'toVal' the numeric value indicating the conversion amount, or null\n   *     if the conversion failed (e.g., if the units are not commensurable);\n   *  'msg' is an array message, if the string is invalid or an error occurred,\n   *        indicating the problem, or an explanation of a substitution such as\n   *        the substitution of 'G' for 'Gauss', or an empty array if no\n   *        messages were generated;\n   *  'suggestions' if suggestions were requested and found, this is a hash\n   *     that contains at most two elements:\n   *     'from' which, if the fromUnitCode input parameter or one or more of\n   *       its components could not be found, is an array one or more hash\n   *       objects.  Each hash contains three elements:\n   *         'msg' which is a message indicating what unit expression the\n   *            suggestions are for;\n   *         'invalidUnit' which is the unit expression the suggestions\n   *            are for; and\n   *         'units' which is an array of data for each suggested unit found.\n   *            Each array will contain the unit code, the unit name and the\n   *            unit guidance (if any).\n   *       If no suggestions were found for the fromUnitCode this element\n   *       will not be included.\n   *     'to' which, if the \"to\" unit expression or one or more of its\n   *       components could not be found, is an array one or more hash objects.  Each hash\n   *       contains three elements:\n   *         'msg' which is a message indicating what toUnitCode input\n   *            parameter the suggestions are for;\n   *         'invalidUnit' which is the unit expression the suggestions\n   *            are for; and\n   *         'units' which is an array of data for each suggested unit found.\n   *            Each array will contain the unit code, the unit name and the\n   *            unit guidance (if any).\n   *       If no suggestions were found for the toUnitCode this element\n   *       will not be included.\n   *    No 'suggestions' element will be included in the returned hash\n   *    object if none were found, whether or not they were requested.\n   *  'fromUnit' the unit object for the fromUnitCode passed in; returned\n   *     in case it's needed for additional data from the object; and\n   *  'toUnit' the unit object for the toUnitCode passed in; returned\n   *     in case it's needed for additional data from the object.\n   */\n  convertUnitTo(fromUnitCode, fromVal, toUnitCode, suggest, molecularWeight) {\n    if (suggest === undefined)\n      suggest = false ;\n\n    if (molecularWeight === undefined)\n      molecularWeight = null ;\n\n    let returnObj = {'status' : 'failed',\n                     'toVal' : null,\n                     'msg' : []} ;\n\n    if (fromUnitCode) {\n      fromUnitCode = fromUnitCode.trim();\n    }\n    if (!fromUnitCode || fromUnitCode == '') {\n      returnObj['status'] = 'error';\n      returnObj['msg'].push('No \"from\" unit expression specified.');\n    }\n    this._checkFromVal(fromVal, returnObj);\n    if (toUnitCode) {\n      toUnitCode = toUnitCode.trim();\n    }\n    if (!toUnitCode || toUnitCode == '') {\n      returnObj['status'] = 'error';\n      returnObj['msg'].push('No \"to\" unit expression specified.');\n    }\n    if (returnObj['status'] !== 'error') {\n      try {\n        let fromUnit = null;\n\n        let parseResp = this.getSpecifiedUnit(fromUnitCode, 'convert', suggest);\n        fromUnit = parseResp['unit'];\n        if (parseResp['retMsg'])\n          returnObj['msg'] = returnObj['msg'].concat(parseResp['retMsg']);\n        if (parseResp['suggestions']) {\n          returnObj['suggestions'] = {};\n          returnObj['suggestions']['from'] = parseResp['suggestions'];\n        }\n        if (!fromUnit) {\n          returnObj['msg'].push(`Unable to find a unit for ${fromUnitCode}, ` +\n            `so no conversion could be performed.`);\n        }\n\n        let toUnit = null;\n        parseResp = this.getSpecifiedUnit(toUnitCode, 'convert', suggest);\n        toUnit = parseResp['unit'];\n        if (parseResp['retMsg'])\n          returnObj['msg'] = returnObj['msg'].concat(parseResp['retMsg']);\n        if (parseResp['suggestions']) {\n          if (!returnObj['suggestions'])\n            returnObj['suggestions'] = {} ;\n          returnObj['suggestions']['to'] = parseResp['suggestions'];\n        }\n        if (!toUnit) {\n          returnObj['msg'].push(`Unable to find a unit for ${toUnitCode}, ` +\n                                `so no conversion could be performed.`);\n        }\n\n        if (fromUnit && toUnit) {\n          try {\n            // if no molecular weight was specified perform a normal conversion\n            if (!molecularWeight) {\n              returnObj['toVal'] = toUnit.convertFrom(fromVal, fromUnit);\n            }\n            else {\n              if (fromUnit.moleExp_ !== 0 && toUnit.moleExp_ !== 0) {\n                throw(new Error('A molecular weight was specified ' +\n                  'but a mass <-> mole conversion cannot be executed for two ' +\n                  'mole-based units.  No conversion was attempted.'));\n              }\n              if (fromUnit.moleExp_ === 0 && toUnit.moleExp_ === 0) {\n                throw(new Error('A molecular weight was specified ' +\n                  'but a mass <-> mole conversion cannot be executed when ' +\n                  'neither unit is mole-based.  No conversion was attempted.'));\n              }\n              if (!fromUnit.isMoleMassCommensurable(toUnit)) {\n                throw(new Error(`Sorry.  ${fromUnitCode} cannot be ` +\n                  `converted to ${toUnitCode}.`));\n              }\n\n              // if the \"from\" unit is a mole-based unit, assume a mole to mass\n              // request\n              if (fromUnit.moleExp_ !== 0) {\n                returnObj['toVal'] =\n                  fromUnit.convertMolToMass(fromVal, toUnit, molecularWeight);\n              }\n              // else the \"to\" unit must be the mole-based unit, so assume a\n              // mass to mole request\n              else {\n                returnObj['toVal'] =\n                  fromUnit.convertMassToMol(fromVal, toUnit, molecularWeight);\n              }\n            } // end if a molecular weight was specified\n\n            // if an error hasn't been thrown - either from convertFrom or here,\n            // set the return object to show success\n            returnObj['status'] = 'succeeded';\n            returnObj['fromUnit'] = fromUnit;\n            returnObj['toUnit'] = toUnit;\n          }\n          catch (err) {\n            returnObj['status'] = 'failed';\n            returnObj['msg'].push(err.message);\n          }\n\n\n        }  // end if we have the from and to units\n      }\n      catch (err) {\n        if (err.message == Ucum.needMoleWeightMsg_)\n          returnObj['status'] = 'failed';\n        else\n          returnObj['status'] = 'error';\n        returnObj['msg'].push(err.message);\n      }\n    }\n\n    return returnObj ;\n\n  } // end convertUnitTo\n\n\n  /**\n   *  Converts the given unit string into its base units, their exponents, and\n   *  a magnitude, and returns that data.\n   * @param fromUnit the unit string to be converted to base units information\n   * @param fromVal the number of \"from\" units to be converted\n   * @returns an object with the properties:\n   *  'status' indicates whether the result succeeded.  The value will be one of:\n   *    'succeeded':  the conversion was successfully calculated (which can be\n   *      true even if it was already in base units);\n   *    'invalid':  fromUnit is not a valid UCUM code;\n   *    'failed':  the conversion could not be made (e.g., if it is an \"arbitrary\" unit);\n   *    'error':  if an error occurred (an input or programming error)\n   *  'msg': an array of one or more messages, if the string is invalid or\n   *        an error occurred, indicating the problem, or a suggestion of a\n   *        substitution such as the substitution of 'G' for 'Gauss', or\n   *        an empty array if no messages were generated.  There can also be a\n   *        message that is just informational or warning.\n   *  'magnitude': the new value when fromVal units of fromUnits is expressed in the base units.\n   *  'fromUnitIsSpecial': whether the input unit fromUnit is a \"special unit\"\n   *         as defined in UCUM.  This means there is some function applied to convert\n   *         between fromUnit and the base units, so the returned magnitude is likely not\n   *         useful as a scale factor for other conversions (i.e., it only has validity\n   *         and usefulness for the input values that produced it).\n   *  'unitToExp': a map of base units in uStr to their exponent\n   */\n  convertToBaseUnits(fromUnit, fromVal) {\n    let retObj = {};\n    this._checkFromVal(fromVal, retObj);\n    if (!retObj.status) { // could be set to 'error' by _checkFromVal\n      let inputUnitLookup = this.getSpecifiedUnit(fromUnit, 'validate');\n      retObj = {status: inputUnitLookup.status == 'valid' ? 'succeeded' : inputUnitLookup.status};\n      let unit = inputUnitLookup.unit;\n      retObj.msg = inputUnitLookup.retMsg || [];\n      if (!unit) {\n        if (inputUnitLookup.retMsg?.length == 0)\n          retObj.msg.push('Could not find unit information for '+fromUnit);\n      }\n      else if (unit.isArbitrary_) {\n        retObj.msg.push('Arbitrary units cannot be converted to base units or other units.');\n        retObj.status = 'failed';\n      }\n      else if (retObj.status == 'succeeded') {\n        let unitToExp = {};\n        let dimVec = unit.dim_?.dimVec_\n        let baseUnitString = '1';\n        if (dimVec) {\n          let dimVecIndexToBaseUnit = UnitTables.getInstance().dimVecIndexToBaseUnit_;\n          for (let i=0, len=dimVec.length; i<len; ++i) {\n            let exp = dimVec[i];\n            if (exp) {\n              unitToExp[dimVecIndexToBaseUnit[i]] = exp;\n              baseUnitString += '.' + dimVecIndexToBaseUnit[i] + exp;\n            }\n          }\n        }\n\n        // The unit might have a conversion function, which has to be applied; we\n        // cannot just assume unit_.magnitude_ is the magnitude in base units.\n        let retUnitLookup = this.getSpecifiedUnit(baseUnitString, 'validate');\n        // There should not be any error in retUnitLookup, unless there is a bug.\n        let retUnit = retUnitLookup.unit;\n        if (retUnitLookup.status !== 'valid') {\n          retObj.msg.push('Unable construct base unit string; tried '+baseUnitString);\n          retObj.status = 'error';\n        }\n        else {\n          try {\n            retObj.magnitude = retUnit.convertFrom(fromVal, unit);\n          }\n          catch (e) {\n            retObj.msg.push(e.toString());\n            retObj.status = 'error';\n          }\n          if (retObj.status == 'succeeded') {\n            retObj.unitToExp = unitToExp;\n            retObj.fromUnitIsSpecial = unit.isSpecial_;\n          }\n        }\n      }\n    }\n    return retObj;\n  }\n\n\n  /**\n   *  Checks the given value as to whether it is suitable as a \"from\" value in a\n   *  unit conversion.  If it is not, the responseObj will have its status set\n   *  to 'error' and a message added.\n   * @param fromVal The value to check\n   * @param responseObj the object that will be updated if the value is not\n   *  usable.\n   */\n  _checkFromVal(fromVal, responseObj) {\n    if (fromVal === null || isNaN(fromVal) || (typeof fromVal !== 'number' &&\n        !intUtils_.isNumericString(fromVal))) {\n      responseObj.status = 'error';\n      if (!responseObj.msg)\n        responseObj.msg = [];\n      responseObj.msg.push('No \"from\" value, or an invalid \"from\" value, ' +\n                         'was specified.');\n    }\n  }\n\n\n  /**\n   * This method accepts a term and looks for units that include it as\n   * a synonym - or that include the term in its name.\n   *\n   * @param theSyn the term to search for\n   * @returns a hash with up to three elements:\n   *  'status' contains the status of the request, which can be 'error',\n   *    'failed' or succeeded';\n   *  'msg' which contains a message for an error or if no units were found; and\n   *  'units' which is an array that contains one hash for each unit found:\n   *    'code' is the unit's csCode_\n   *    'name' is the unit's name_\n   *    'guidance' is the unit's guidance_\n   *\n   */\n  checkSynonyms(theSyn) {\n    let retObj = {} ;\n    if (theSyn === undefined || theSyn === null) {\n      retObj['status'] = 'error';\n      retObj['msg'] = 'No term specified for synonym search.'\n    }\n    else {\n      retObj = intUtils_.getSynonyms(theSyn);\n    } // end if a search synonym was supplied\n\n    return retObj ;\n\n  } // end checkSynonyms\n\n\n  /**\n   * This method parses a unit string to get (or try to get) the unit\n   * represented by the string.  It returns an error message if no string was specified\n   * or if any errors were encountered trying to get the unit.\n   *\n   * @param uName the expression/string representing the unit\n   * @param valConv indicates what type of request this is for - a request to\n   *  validate (pass in 'validate') or a request to convert (pass in 'convert')\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @returns a hash containing:\n   *   'status' will be 'valid' (uName is a valid UCUM code), 'invalid'\n   *     (the uStr is not a valid UCUM code, and substitutions or\n   *     suggestions may or may not be returned, depending on what was\n   *     requested and found); or 'error' (an input or programming error\n   *     occurred);\n   *   'unit' the unit object (or null if there were problems creating the\n   *     unit);\n   *   'origString' the possibly updated unit string passed in;\n   *   'retMsg' an array of user messages (informational, error or warning) if\n   *     any were generated (IF any were generated, otherwise will be an\n   *     empty array); and\n   *   'suggestions' is an array of 1 or more hash objects.  Each hash\n   *     contains three elements:\n   *       'msg' which is a message indicating what unit expression the\n   *          suggestions are for;\n   *       'invalidUnit' which is the unit expression the suggestions are\n   *          for; and\n   *       'units' which is an array of data for each suggested unit found.\n   *          Each array will contain the unit code, the unit name and the\n   *          unit guidance (if any).\n   *   The return hash will not contain a suggestions array if a valid unit\n   *   was found or if suggestions were not requested and found.\n   */\n  getSpecifiedUnit(uName, valConv, suggest) {\n\n    if (suggest === undefined)\n      suggest = false ;\n\n    let retObj = {};\n    retObj['retMsg'] = [];\n\n    if (!uName) {\n      retObj['retMsg'].push('No unit string specified.');\n    }\n    else {\n      let utab = UnitTables.getInstance();\n      uName = uName.trim();\n\n      // go ahead and just try using the name as the code.  This may or may not\n      // work, but if it does, it cuts out a lot of parsing.\n      let theUnit = utab.getUnitByCode(uName);\n\n      // If we found it, set the returned unit string to what was passed in;\n      // otherwise try parsing as a unit string\n      if (theUnit) {\n        retObj['unit'] = theUnit ;\n        retObj['origString'] = uName;\n      }\n      else {\n        try {\n          let resp = this.uStrParser_.parseString(uName, valConv, suggest);\n          retObj['unit'] = resp[0];\n          retObj['origString'] = resp[1];\n          if (resp[2])\n            retObj['retMsg'] = resp[2];\n          retObj['suggestions'] = resp[3];\n        }\n        catch (err) {\n          console.log(`Unit requested for unit string ${uName}.` +\n            'request unsuccessful; error thrown = ' + err.message);\n            retObj['retMsg'].unshift(`${uName} is not a valid unit.  ` +\n                                     `${err.message}`);\n        }\n      } // end if the unit was not found as a unit name\n    } // end if a unit expression was specified\n\n    // Set the status field\n    if (!retObj.unit) {\n      // No unit was found; check whether origString has a value\n      retObj.status = !retObj.origString ? 'error' : 'invalid';\n    }\n    else {\n      // Check whether substitutions were made to the unit string in order to\n      // find the unit\n      retObj.status = retObj.origString === uName ? 'valid': 'invalid';\n    }\n\n    return retObj;\n\n  } // end getSpecifiedUnit\n\n\n  /**\n   * This method retrieves a list of units commensurable, i.e., that can be\n   * converted from and to, a specified unit.  Returns an error if the \"from\"\n   * unit cannot be found.\n   *\n   * @param fromName the name/unit string of the \"from\" unit\n   * @returns an array containing two elements;\n   *   first element is the list of commensurable units if any were found\n   *   second element is an error message if the \"from\" unit is not found\n   */\n  commensurablesList(fromName) {\n\n    let retMsg = [];\n    let commUnits = null ;\n    let parseResp = this.getSpecifiedUnit(fromName, 'validate', false);\n    let fromUnit = parseResp['unit'];\n    if (parseResp['retMsg'].length > 0)\n      retMsg = parseResp['retMsg'] ;\n    if (!fromUnit) {\n      retMsg.push(`Could not find unit ${fromName}.`);\n    }\n    else {\n      let dimVec = null ;\n      let fromDim = fromUnit.getProperty('dim_');\n      if (!fromDim) {\n        retMsg.push('No commensurable units were found for ' + fromName) ;\n      }\n      else {\n        try {\n          dimVec = fromDim.getProperty('dimVec_');\n        }\n        catch (err) {\n          retMsg.push(err.message);\n          if (err.message ===\n            \"Dimension does not have requested property(dimVec_)\")\n            dimVec = null;\n        }\n        if (dimVec) {\n          let utab = UnitTables.getInstance();\n          commUnits = utab.getUnitsByDimension(dimVec);\n        }\n      } // end if the from unit has a dimension vector\n    } // end if we found a \"from\" unit\n    return [commUnits , retMsg];\n  } // end commensurablesList\n\n} // end UcumLhcUtils class\n\n\n/**\n *  This function exists ONLY until the original UcumLhcUtils constructor\n *  is called for the first time.  It's defined here in case getInstance\n *  is called before the constructor.   This calls the constructor.\n *\n *  The constructor redefines the getInstance function to return the\n *  singleton UcumLhcUtils object.  This is based on the UnitTables singleton\n *  implementation; see more detail in the UnitTables constructor description.\n *\n *  NO LONGER TRUE - not implemented as a singleton.  This method retained to\n *  avoid problems with calls to it that exist throughout the code.\n *\n *  @return the (formerly singleton) UcumLhcUtils object.\n */\nUcumLhcUtils.getInstance = function(){\n  return new UcumLhcUtils();\n} ;\n","/**\n * This exports definitions for ucum classes that need references to them\n * available to the demo code.  The actual code will be in the ucumPkg\n * library found in the dist directory.  This file provides the hooks to\n * those classes within the library.\n */\n\nexport var Ucum = require(\"./config.js\").Ucum;\nexport var UcumLhcUtils = require(\"./ucumLhcUtils.js\").UcumLhcUtils;\nexport var UnitTables = require(\"./unitTables.js\").UnitTables;","\n/**\n * This class represents one unit of measure.  It includes\n * functions to cover constructor, accessor, and assignment tasks as\n * well as operators to calculate multiplication, division and raising\n * to a power.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\nvar Ucum = require('./config.js').Ucum;\nvar Dimension = require('./dimension.js').Dimension;\nimport funcs from \"./ucumFunctions.js\";\nvar UnitTables;\n\nvar isInteger = require(\"is-integer\");\nimport * as intUtils_ from \"./ucumInternalUtils.js\";\n\nexport class Unit {\n\n  /**\n   * Constructor.\n   *\n   * @param attrs an optional parameter that may be:\n   *  a string, which is parsed by the unit parser, which creates\n   *  the unit from the parsed string; or\n   *  a hash containing all or some values for the attributes of\n   *  the unit, where the keys are the attribute names, without a\n   *  trailing underscore, e.g., name instead of name_; or\n   *  null, in which case an empty hash is created and used to\n   *  set the values forthe attributes.\n   *  If a hash (empty or not) is used, attributes for which no value\n   *  is specified are assigned a default value.\n   *\n   */\n  constructor(attrs = {}) {\n\n    // Process the attrs hash passed in, which may be empty.\n    // Create and assign values (from the attrs hash or defaults) to all\n    // attributes.  From Class Declarations in Understanding ECMAScript,\n    // https://leanpub.com/understandinges6/read/#leanpub-auto-class-declarations,\n    //   \"Own properties, properties that occur on the instance rather than the\n    //    prototype, can only be created inside of a class constructor or method.\n    //    It's recommended to create all possible own properties inside of the\n    //    constructor function so there's a single place that's responsible for\n    //    all of them.\"\n\n    /*\n     * Flag indicating whether or not this is a base unit\n     */\n    this.isBase_ = attrs['isBase_'] || false ;\n\n    /*\n     * The unit name, e.g., meter\n     */\n    this.name_ = attrs['name_'] || '';\n\n    /*\n     * The unit's case-sensitive code, e.g., m\n     */\n    this.csCode_ = attrs['csCode_'] || '';\n\n    /*\n     * The unit's case-insensitive code, e.g., M\n     */\n    this.ciCode_ = attrs['ciCode_'] || '';\n\n    /*\n     * The unit's property, e.g., length\n     */\n    this.property_ = attrs['property_'] || '';\n\n    /*\n     * The magnitude of the unit, e.g., 3600/3937 for a yard,\n     * where a yard - 3600/3973 * m(eter).  The Dimension\n     * property specifies the meter - which is the unit on which\n     * a yard is based, and this magnitude specifies how to figure\n     * this unit based on the base unit.\n     */\n    this.magnitude_ = attrs['magnitude_'] || 1;\n\n    /*\n     * The Dimension object of the unit\n     */\n    if (attrs['dim_'] === undefined || attrs['dim_'] === null) {\n      this.dim_ = new Dimension();\n    }\n    // When the unit data stored in json format is reloaded, the dimension data\n    // is recognized as a a hash, not as a Dimension object.\n    else if (attrs['dim_']['dimVec_'] !== undefined) {\n      this.dim_ = new Dimension(attrs['dim_']['dimVec_']) ;\n    }\n    else if (attrs['dim_'] instanceof Dimension) {\n      this.dim_ = attrs['dim_'];\n    }\n    else if (attrs['dim_'] instanceof Array || isInteger(attrs['dim_'])) {\n      this.dim_ = new Dimension(attrs['dim_']) ;\n    }\n    else {\n      this.dim_ = new Dimension();\n    }\n    /*\n     * The print symbol of the unit, e.g., m\n     */\n    this.printSymbol_ = attrs['printSymbol_'] || null;\n\n    /*\n     * The class of the unit, where given, e.g., dimless\n     */\n    this.class_ = attrs['class_'] || null;\n\n    /*\n     * A flag indicating whether or not the unit is metric\n     */\n    this.isMetric_ = attrs['isMetric_'] || false;\n\n    /*\n     * The \"variable\" - which I think is used only for base units\n     * The symbol for the variable as used in equations, e.g., s for distance\n     */\n    this.variable_ = attrs['variable_'] || null ;  // comes from 'dim' in XML\n\n    /*\n     * The conversion function\n     */\n    this.cnv_ = attrs['cnv_'] || null;\n\n    /*\n     * The conversion prefix\n     */\n    this.cnvPfx_ = attrs['cnvPfx_'] || 1;\n\n    /*\n     * Flag indicating whether or not this is a \"special\" unit, i.e., is\n     * constructed using a function specific to the measurement, e.g.,\n     * fahrenheit and celsius\n     */\n    this.isSpecial_ = attrs['isSpecial_'] || false ;\n\n    /*\n     * Flag indicating whether or not this is an arbitrary unit\n     */\n    this.isArbitrary_ = attrs['isArbitrary_'] || false;\n\n    /*\n     * Integer indicating what level of exponent applies to a mole-based portion\n     * of the unit.  So, for the unit \"mol\", this will be 1.  For \"mol2\" this\n     * will be 2.  For \"1/mol\" this will be -1.  Any unit that does not include\n     * a mole will have a 0 in this field.  This is used to determine\n     * commensurability for mole<->mass conversions.\n     */\n    this.moleExp_ = attrs['moleExp_'] || 0;\n\n    /*\n     * Added when added LOINC list of units\n     * synonyms are used by the autocompleter to enhance lookup capabilities\n     * while source says where the unit first shows up.  Current sources are\n     * UCUM - which are units from the unitsofmeasure.org list and LOINC -\n     * which are units from the LOINC data.\n     */\n    this.synonyms_ = attrs['synonyms_'] || null ;\n    this.source_ = attrs['source_'] || null ;\n    this.loincProperty_ = attrs['loincProperty_'] || null;\n    this.category_ = attrs['category_'] || null;\n    this.guidance_ = attrs['guidance_'] || null;\n\n    /*\n     * Used to compute dimension; storing for now until I complete\n     * unit definition parsing\n     */\n    /*\n     * Case sensitive (cs) and case insensitive (ci) base unit strings,\n     * includes exponent and prefix if applicable - specified in\n     * <value Unit=x UNIT=X value=\"nnn\">nnn</value> -- the unit part --\n     * in the ucum-essence.xml file, and may be specified by a user\n     * when requesting conversion or validation of a unit string.  The\n     * magnitude (base factor) is used with this to determine the new unit.\n     * For example, a Newton (unit code N) is created from the string\n     * kg.m/s2, and the value of 1 (base factor defined below). An hour\n     * (unit code h) is created from the unit min (minute) with a value\n     * of 60.\n     */\n    this.csUnitString_ = attrs['csUnitString_'] || null ;\n    this.ciUnitString_ = attrs['ciUnitString_'] || null ;\n\n    /*\n     * String and numeric versions of factor applied to unit specified in\n     * <value Unit=x UNIT=X value=\"nnn\">nnn</value> -- the value part\n     */\n    this.baseFactorStr_ = attrs['baseFactorStr_'] || null;\n    this.baseFactor_ = attrs['baseFactor_'] || null;\n\n    /*\n     * Flag used to indicate units where the definition process failed\n     * when parsing units from the official units definitions file\n     * (currently using the ucum-essence.xml file).  We keep these\n     * so that we can use them to at least validate them as valid\n     * units, but we don't try to convert them.   This is temporary\n     * and only to account for instances where the code does not\n     * take into account various special cases in the xml file.\n     *\n     * This is NOT used when trying to validate a unit string\n     * submitted during a conversion or validation attempt.\n     */\n    this.defError_ = attrs['defError_'] || false ;\n\n\n  } // end constructor\n\n\n  /**\n   * Assign the unity (= dimensionless unit 1) to this unit.\n   *\n   * @return this unit\n   */\n  assignUnity() {\n    this.name_  = \"\" ;\n    this.magnitude_ = 1 ;\n    if (!this.dim_)\n      this.dim_ = new Dimension();\n    this.dim_.assignZero() ;\n    this.cnv_ = null ;\n    this.cnvPfx_ = 1 ;\n    return this;\n\n  } // end assignUnity\n\n\n  /**\n   * This assigns one or more values, as provided in the hash passed in,\n   * to this unit.\n   *\n   * @param vals hash of values to be assigned to the attributes\n   *        specified by the key(s), which should be the attribute\n   *        name without the trailing underscore, e.g., name instead\n   *        of name_.\n   * @return nothing\n   */\n  assignVals(vals) {\n    for (let key in vals) {\n      let uKey = !(key.charAt(key.length - 1)) === '_' ? key + '_' : key ;\n      if (this.hasOwnProperty(uKey))\n        this[uKey] = vals[key];\n      else\n        throw(new Error(`Parameter error; ${key} is not a property of a Unit`));\n    }\n  } // end assignVals\n\n\n  /**\n   * This creates a clone of this unit.\n   *\n   * @return the clone\n   */\n  clone() {\n    let retUnit = new Unit() ;\n    Object.getOwnPropertyNames(this).forEach(val => {\n      if (val === 'dim_') {\n        if (this['dim_'])\n          retUnit['dim_'] = this['dim_'].clone();\n        else\n          retUnit['dim_'] = null;\n      }\n      else\n        retUnit[val] = this[val];\n    });\n    return retUnit ;\n\n  } // end clone\n\n\n  /**\n   * This assigns all properties of a unit passed to it to this unit.\n   *\n   * @param unit2 the unit whose properties are to be assigned to this one.\n   * @return nothing; this unit is updated\n   */\n  assign(unit2) {\n    Object.getOwnPropertyNames(unit2).forEach(val => {\n      if (val === 'dim_') {\n        if (unit2['dim_'])\n          this['dim_'] = unit2['dim_'].clone();\n        else\n          this['dim_'] = null;\n      }\n      else {\n        this[val] = unit2[val];\n      }\n    });\n  } // end assign\n\n\n  /**\n   * This determines whether or not object properties of the unit\n   * passed in are equal to the corresponding properties in this unit.\n   * The following properties are the only ones checked:\n   *   magnitude_, dim_, cnv_ and cnvPfx_\n   *\n   * @param unit2 the unit whose properties are to be checked.\n   * @return boolean indicating whether or not they match\n   */\n  equals(unit2) {\n\n    return (this.magnitude_ === unit2.magnitude_ &&\n            this.cnv_ === unit2.cnv_ &&\n            this.cnvPfx_ === unit2.cnvPfx_ &&\n            ((this.dim_ === null && unit2.dim_ === null) ||\n             this.dim_.equals(unit2.dim_)));\n\n  } // end equals\n\n\n  /**\n   * This method compares every attribute of two objects to determine\n   * if they all match.\n   *\n   * @param unit2 the unit that is to be compared to this unit\n   * @return boolean indicating whether or not every attribute matches\n   */\n  fullEquals(unit2) {\n\n    let thisAttr = Object.keys(this).sort();\n    let u2Attr = Object.keys(unit2).sort();\n\n    let keyLen = thisAttr.length ;\n    let match = (keyLen === u2Attr.length);\n\n    // check each attribute.   Dimension objects have to checked using\n    // the equals function of the Dimension class.\n    for (let k = 0; k < keyLen && match; k++) {\n      if (thisAttr[k] === u2Attr[k]) {\n        if (thisAttr[k] === 'dim_')\n          match = this.dim_.equals(unit2.dim_);\n        else\n          match = this[thisAttr[k]] === unit2[thisAttr[k]];\n      }\n      else\n        match = false ;\n    } // end do for each key and attribute\n    return match ;\n  }// end of fullEquals\n\n\n  /**\n   * This returns the value of the property named by the parameter\n   * passed in.\n   *\n   * @param propertyName name of the property to be returned, with\n   *        or without the trailing underscore.\n   * @return the requested property, if found for this unit\n   * @throws an error if the property is not found for this unit\n   */\n  getProperty(propertyName) {\n    let uProp = propertyName.charAt(propertyName.length - 1) === '_' ? propertyName :\n                                             propertyName + '_' ;\n    return this[uProp] ;\n\n  } // end getProperty\n\n\n  /**\n   * Takes a measurement consisting of a number of units and a unit and returns\n   * the equivalent number of this unit.  So, 15 mL would translate\n   * to 1 tablespoon if this object is a tablespoon.\n   *\n   * Note that the number returned may not be what is normally expected.\n   * For example, converting 10 Celsius units to Fahrenheit would \"normally\"\n   * return a value of 50.   But in this case you'll get back something like\n   * 49.99999999999994.\n   *\n   * If either unit is an arbitrary unit an exception is raised.\n   *\n   * @param num the magnitude for the unit to be translated (e.g. 15 for 15 mL)\n   * @param fromUnit the unit to be translated to one of this type (e.g. a mL unit)\n   *\n   * @return the number of converted units (e.g. 1 for 1 tablespoon)\n   * @throws an error if the dimension of the fromUnit differs from this unit's\n   * dimension\n   */\n  convertFrom(num, fromUnit) {\n    let newNum = 0.0 ;\n\n    if (this.isArbitrary_)\n      throw (new Error(`Attempt to convert to arbitrary unit \"${this.csCode_}\"`));\n    if (fromUnit.isArbitrary_)\n      throw (new Error(`Attempt to convert arbitrary unit \"${fromUnit.csCode_}\"`));\n\n    // reject request if both units have dimensions that are not equal\n    if (fromUnit.dim_ && this.dim_ && !(fromUnit.dim_.equals(this.dim_))) {\n      // check first to see if a mole<->mass conversion is appropriate\n      if (this.isMoleMassCommensurable(fromUnit)) {\n        throw(new Error(Ucum.needMoleWeightMsg_));\n      }\n      else {\n        throw(new Error(`Sorry.  ${fromUnit.csCode_} cannot be converted ` +\n          `to ${this.csCode_}.`));\n      }\n    }\n    // reject request if there is a \"from\" dimension but no \"to\" dimension\n    if (fromUnit.dim_ && (!this.dim_ || this.dim_.isNull())) {\n      throw(new Error(`Sorry.  ${fromUnit.csCode_} cannot be converted ` +\n        `to ${this.csCode_}.`));\n    }\n\n    // reject request if there is a \"to\" dimension but no \"from\" dimension\n    if (this.dim_ && (!fromUnit.dim_ || fromUnit.dim_.isNull())) {\n      throw(new Error(`Sorry.  ${fromUnit.csCode_} cannot be converted ` +\n        `to ${this.csCode_}.`));\n    }\n\n    let fromCnv = fromUnit.cnv_ ;\n    let fromMag = fromUnit.magnitude_ ;\n\n    let x;\n    if (fromCnv != null) {\n      // turn num * fromUnit.magnitude into its ratio scale equivalent,\n      // e.g., convert Celsius to Kelvin\n      let fromFunc = funcs.forName(fromCnv);\n      x = fromFunc.cnvFrom(num * fromUnit.cnvPfx_) * fromMag;\n      //x = fromFunc.cnvFrom(num * fromMag) * fromUnit.cnvPfx_;\n    }\n    else {\n      x = num * fromMag;\n    }\n\n    if (this.cnv_ != null) {\n      // turn mag * origUnit on ratio scale into a non-ratio unit,\n      // e.g. convert Kelvin to Fahrenheit\n      let toFunc = funcs.forName(this.cnv_);\n      newNum = toFunc.cnvTo(x / this.magnitude_) / this.cnvPfx_;\n    }\n    else {\n      newNum = x / this.magnitude_;\n    }\n\n    return newNum;\n\n  } // end convertFrom\n\n\n  /**\n   * Takes a number and a target unit and returns the number for a measurement\n   * of this unit that corresponds to the number of the target unit passed in.\n   * So, 1 tablespoon (where this unit represents a tablespoon) would translate\n   * to 15 mL.\n   *\n   * See the note on convertFrom about return values.\n   *\n   * @param mag the magnitude for this unit (e.g. 1 for 1 tablespoon)\n   * @param toUnit the unit to which this unit is to be translated\n   *  (e.g. an mL unit)\n   *\n   * @return the converted number value (e.g. 15 mL)\n   * @throws an error if the dimension of the toUnit differs from this unit's\n   *   dimension\n   */\n  convertTo(num, toUnit) {\n\n    return toUnit.convertFrom(num, this) ;\n\n  } // end convertTo\n\n\n  /**\n   * Takes a given number of this unit returns the number of this unit\n   * if it is converted into a coherent unit.  Does not change this unit.\n   *\n   * If this is a coherent unit already, just gives back the number\n   * passed in.\n   *\n   * @param num the number for the coherent version of this unit\n   * @return the number for the coherent version of this unit\n   */\n  convertCoherent(num) {\n\n    // convert mag' * u' into canonical number * u on ratio scale\n    if(this.cnv_ !== null)\n      num = this.cnv_.f_from(num / this.cnvPfx_) * this.magnitude_;\n\n    return num;\n\n  } // end convertCoherent\n\n\n  /**\n   * Mutates this unit into a coherent unit and converts a given number of\n   * units to the appropriate value for this unit as a coherent unit\n   *\n   * @param num the number for this unit before conversion\n   * @return the number of this unit after conversion\n   * @throws an error if the dimensions differ\n   */\n  mutateCoherent(num) {\n\n    // convert mu' * u' into canonical mu * u on ratio scale\n    num = this.convertCoherent(num) ;\n\n    // mutate to coherent unit\n    this.magnitude_ = 1;\n    this.cnv_ = null;\n    this.cnvPfx_ = 1;\n    this.name_ = \"\";\n\n    // build a name as a term of coherent base units\n    // This is probably ALL WRONG and a HORRIBLE MISTAKE\n    // but until we figure out what the heck the name being\n    // built here really is, it will have to stay.\n    for (let i = 0, max = Dimension.getMax(); i < max; i++) {\n      let elem = this.dim_.getElementAt(i);\n      let tabs = this._getUnitTables();\n      let uA = tabs.getUnitsByDimension(new Dimension(i));\n      if(uA == null)\n        throw(new Error(`Can't find base unit for dimension ${i}`));\n      this.name_ = uA.name + elem;\n    }\n    return num;\n\n  } // end mutateCoherent\n\n\n  /**\n   * Calculates the number of units that would result from converting a unit\n   * expressed in mass/grams to a unit expressed in moles.  The \"this\" unit is\n   * the unit expressed in some form of mass (g, mg, mmg, kg, whatever) and the\n   * target or \"to\" unit - the molUnit parameter - is a unit expressed in moles\n   * - mol, umol, mmol, etc.  The unit expressions surrounding the moles and\n   * mass must be convertible.  No validation of this requirement is performed.\n   *\n   * @param amt the quantity of this unit to be converted\n   * @param molUnit the target/to unit for which the converted # is wanted\n   * @param molecularWeight the molecular weight of the substance for which the\n   *  conversion is being made\n   * @return the equivalent amount in molUnit\n   */\n  convertMassToMol(amt, molUnit, molecularWeight) {\n    // The prefix values that have been applied to this unit, which is the mass\n    // (grams) unit, are reflected in the magnitude.  So the number of moles\n    // represented by this unit equals the number of grams -- amount * magnitude\n    // divided by the molecular Weight\n    let molAmt = (this.magnitude_ * amt)/molecularWeight ;\n    // The molUnit's basic magnitude, before prefixes are applied,\n    // is avogadro's number, get that and divide it out of the current magnitude.\n    let tabs = this._getUnitTables();\n    let avoNum = tabs.getUnitByCode('mol').magnitude_ ;\n    let molesFactor = molUnit.magnitude_ / avoNum ;\n    // return the molAmt divided by the molesFactor as the number of moles\n    // for the molUnit\n    return molAmt/molesFactor ;\n  }\n\n  /**\n   * Calculates the number of units that would result from converting a unit\n   * expressed in moles to a unit expressed in mass (grams).  The \"this\" unit\n   * is the unit expressed in some form of moles, e.g., mol, umol, mmol, etc.,\n   * and the target or \"to\" unit is a unit expressed in some form of mass, e.g.,\n   * g, mg, mmg, kg, etc.  Any unit expressions surrounding the moles and mass\n   * must be convertible. No validation of this requirement is performed.\n   *\n   * @param amt the quantity of this unit to be converted\n   * @param massUnit the target/to unit for which the converted # is wanted\n   * @param molecularWeight the molecular weight of the substance for which the\n   *  conversion is being made\n   * @return the equivalent amount in massUnit\n   */\n  convertMolToMass(amt, massUnit, molecularWeight) {\n    // A simple mole unit has a magnitude of avogadro's number.  Get that\n    // number now (since not everyone agrees on what it is, and what is\n    // being used in this system might change).\n    let tabs = this._getUnitTables();\n    let avoNum = tabs.getUnitByCode('mol').magnitude_ ;\n    // Determine what prefix values (mg or mg/dL, etc.) have been applied to\n    // this unit by dividing the simple mole unit magnitude out of the\n    // current mole unit magnitude.\n    let molesFactor = this.magnitude_ / avoNum ;\n    // The number of grams (mass) is equal to the number of moles (amt)\n    // times the molecular weight.  We also multiply that by the prefix values\n    // applied to the current unit (molesFactor) to get the grams for this\n    // particular unit.\n    let massAmt = (molesFactor * amt) * molecularWeight ;\n    // Finally, we return the mass amount/grams for this particular unit\n    // divided by any effects of prefixes applied to the \"to\" unit, which\n    // is assumed to be some form of a gram unit\n    return massAmt / massUnit.magnitude_ ;\n  }\n\n\n  /**\n   * Mutates this unit into a unit on a ratio scale and converts a specified\n   * number of units to an appropriate value for this converted unit\n   *\n   * @param num the number of this unit before it's converted\n   * @return the magnitude of this unit after it's converted\n   * @throw an error if the dimensions differ\n   */\n  mutateRatio(num) {\n    if (this.cnv_ == null)\n      return this.mutateCoherent(num);\n    else\n      return num;\n\n  } // end mutateRatio\n\n\n  /**\n   * Multiplies this unit with a scalar. Special meaning for\n   * special units so that (0.1*B) is 1 dB.\n   *\n   * This function DOES NOT modify this unit.\n   *\n   * @param s the value by which this unit is to be multiplied\n   * @return a copy this unit multiplied by s\n   * */\n  multiplyThis(s) {\n\n    let retUnit = this.clone() ;\n    if (retUnit.cnv_ != null)\n      retUnit.cnvPfx_ *= s;\n    else\n      retUnit.magnitude_ *= s;\n    let mulVal = s.toString();\n    retUnit.name_ = this._concatStrs(mulVal, '*', this.name_, '[', ']');\n    retUnit.csCode_ = this._concatStrs(mulVal, '.', this.csCode_, '(', ')');\n    retUnit.ciCode_ = this._concatStrs(mulVal, '.', this.ciCode_, '(', ')');\n    retUnit.printSymbol_ = this._concatStrs(mulVal, '.', this.printSymbol_,\n        '(', ')');\n\n    return retUnit;\n\n  } // end multiplyThis\n\n\n  /**\n   * Multiplies this unit with another unit. If one of the\n   * units is a non-ratio unit the other must be dimensionless or\n   * else an exception is thrown.\n   *\n   * This function does NOT modify this unit\n   * @param unit2 the unit to be multiplied with this one\n   * @return this unit after it is multiplied\n   * @throws an error if one of the units is not on a ratio-scale\n   *         and the other is not dimensionless.\n   */\n  multiplyThese(unit2) {\n\n    var retUnit = this.clone() ;\n\n    if (retUnit.cnv_ != null) {\n      if (unit2.cnv_ == null && (!unit2.dim_ || unit2.dim_.isZero()))\n        retUnit.cnvPfx_ *= unit2.magnitude_;\n      else\n        throw (new Error(`Attempt to multiply non-ratio unit ${retUnit.name_} ` +\n          'failed.'));\n    } // end if this unit has a conversion function\n\n    else if (unit2.cnv_ != null) {\n      if (!retUnit.dim_ || retUnit.dim_.isZero()) {\n        retUnit.cnvPfx_ = unit2.cnvPfx_ * retUnit.magnitude_;\n        retUnit.magnitude_ = unit2.magnitude_;\n        retUnit.cnv_ = unit2.cnv_ ;\n      }\n      else\n        throw (new Error(`Attempt to multiply non-ratio unit ${unit2.name_}`));\n    } // end if unit2 has a conversion function\n\n    // else neither unit has a conversion function\n    else {\n      retUnit.magnitude_ *= unit2.magnitude_;\n    } // end if unit2 does not have a conversion function\n\n    // If this.dim_ isn't there, clone the dimension in unit2 - if dimVec_\n    // is a dimension in unit2.dim_; else just transfer it to this dimension\n    if (!retUnit.dim_ || (retUnit.dim_ && !retUnit.dim_.dimVec_)) {\n      if (unit2.dim_)\n        retUnit.dim_ = unit2.dim_.clone();\n      else\n        retUnit.dim_ = unit2.dim_;\n    }\n    // Else this.dim_ is there.  If there is a dimension for unit2,\n    // add it to this one.\n    else if (unit2.dim_ && unit2.dim_ instanceof Dimension) {\n      retUnit.dim_.add(unit2.dim_);\n    }\n\n    // Concatenate the unit info (name, code, etc) for all cases\n    // where the multiplication was performed (an error wasn't thrown)\n    retUnit.name_ = this._concatStrs(retUnit.name_, '*', unit2.name_, '[', ']');\n    retUnit.csCode_ = this._concatStrs(retUnit.csCode_, '.', unit2.csCode_,\n      '(', ')');\n    if (retUnit.ciCode_ && unit2.ciCode_)\n      retUnit.ciCode_ = this._concatStrs(retUnit.ciCode_, '.', unit2.ciCode_,\n        '(', ')');\n    else if (unit2.ciCode_)\n      retUnit.ciCode_ = unit2.ciCode_;\n    retUnit.resetFieldsForDerivedUnit();\n    if (retUnit.printSymbol_ && unit2.printSymbol_)\n      retUnit.printSymbol_ = this._concatStrs(retUnit.printSymbol_, '.',\n        unit2.printSymbol_, '(', ')');\n    else if (unit2.printSymbol_)\n      retUnit.printSymbol_ = unit2.printSymbol_;\n\n    // Update the mole exponent count by adding the count for unit2 to the\n    // count for this unit.\n    retUnit.moleExp_ = retUnit.moleExp_ + unit2.moleExp_ ;\n\n    // A unit that has the arbitrary attribute taints any unit created from it\n    // via an arithmetic operation.  Taint accordingly\n    // if (!retUnit.isMole_)\n    //   retUnit.isMole_ = unit2.isMole_ ;\n    if (!retUnit.isArbitrary_)\n      retUnit.isArbitrary_ = unit2.isArbitrary_;\n\n    // Likewise for special units\n    if (!retUnit.isSpecial_)\n      retUnit.isSpecial_ = unit2.isSpecial_;\n\n    return retUnit ;\n\n  } // end multiplyThese\n\n\n  /**\n   *  Clears fields like isBase_, synonyms_, etc. when a unit has been cloned\n   *  from a known unit but it being used to construct a derived unit.\n   */\n  resetFieldsForDerivedUnit() {\n    this.guidance_ = '';\n    this.synonyms_ = null;\n    this.isBase_ = false;\n  }\n\n\n  /**\n   * Divides this unit by another unit. If this unit is not on a ratio\n   * scale an exception is raised. Mutating to a ratio scale unit\n   * is not possible for a unit, only for a measurement.\n   *\n   * This unit is NOT modified by this function.\n   * @param unit2 the unit by which to divide this one\n   * @return this unit after it is divided by unit2\n   * @throws an error if either of the units is not on a ratio scale.\n   * */\n  divide(unit2) {\n\n    var retUnit = this.clone();\n\n    if (retUnit.cnv_ != null)\n      throw (new Error(`Attempt to divide non-ratio unit ${retUnit.name_}`));\n    if (unit2.cnv_ != null)\n      throw (new Error(`Attempt to divide by non-ratio unit ${unit2.name_}`));\n\n    if (retUnit.name_ && unit2.name_)\n      retUnit.name_ = this._concatStrs(retUnit.name_, '/', unit2.name_, '[', ']');\n    else if (unit2.name_)\n      retUnit.name_ = unit2.invertString(unit2.name_);\n\n    retUnit.csCode_ = this._concatStrs(retUnit.csCode_, '/', unit2.csCode_,\n      '(', ')');\n\n    if (retUnit.ciCode_ && unit2.ciCode_)\n      retUnit.ciCode_ = this._concatStrs(retUnit.ciCode_, '/', unit2.ciCode_,\n      '(', ')');\n    else if (unit2.ciCode_)\n      retUnit.ciCode_ = unit2.invertString(unit2.ciCode_) ;\n\n    retUnit.resetFieldsForDerivedUnit();\n\n    retUnit.magnitude_ /= unit2.magnitude_;\n\n    if (retUnit.printSymbol_ && unit2.printSymbol_)\n      retUnit.printSymbol_ = this._concatStrs(retUnit.printSymbol_, '/',\n        unit2.printSymbol_, '(', ')');\n    else if (unit2.printSymbol_)\n      retUnit.printSymbol_ = unit2.invertString(unit2.printSymbol_);\n\n    // Continue if unit2 has a dimension object.\n    // If this object has a dimension object, subtract unit2's dim_ object from\n    // this one. The sub method will take care of cases where the dimVec_ arrays\n    // are missing on one or both dim_ objects.\n    if (unit2.dim_) {\n      if (retUnit.dim_) {\n        if (retUnit.dim_.isNull())\n          retUnit.dim_.assignZero();\n        retUnit.dim_ = retUnit.dim_.sub(unit2.dim_);\n      } // end if this.dim_ exists\n\n      // Else if this dim_ object is missing, clone unit2's dim_ object\n      // and give the inverted clone to this unit.\n      else\n        retUnit.dim_ = unit2.dim_.clone().minus();\n    } // end if unit2 has a dimension object\n\n    // Update the mole exponent count by subtracting the count for unit2 from\n    // the // count for this unit.\n    retUnit.moleExp_ = retUnit.moleExp_ - unit2.moleExp_ ;\n\n    // A unit that has the arbitrary attribute taints any unit created from\n    // it via an arithmetic operation.  Taint accordingly\n    // if (!retUnit.isMole_)\n    //   retUnit.isMole_ = unit2.isMole_ ;\n    if (!retUnit.isArbitrary_)\n      retUnit.isArbitrary_ = unit2.isArbitrary_;\n\n    return retUnit;\n\n  } // end divide\n\n\n  /**\n   * Invert this unit with respect to multiplication. If this unit is not\n   * on a ratio scale an exception is thrown. Mutating to a ratio scale unit\n   * is not possible for a unit, only for a measurement (the magnitude and\n   * dimension).\n   *\n   *  This unit is modified by this function.\n   * @return this unit after being inverted\n   * @throws and error if this unit is not on a ratio scale\n   */\n  invert() {\n\n    if (this.cnv_ != null)\n      throw (new Error(`Attempt to invert a non-ratio unit - ${this.name_}`));\n\n    this.name_ = this.invertString(this.name_);\n    this.magnitude_ = 1/this.magnitude_ ;\n    this.dim_.minus();\n    return this;\n\n  } // end invert\n\n\n  /**\n   * Inverts a string, where the string is assumed to be a code or a name\n   * of a division operation where the string is the divisor and the dividend\n   * is blank.\n   *\n   * @param the string to be inverted\n   * @return the inverted string\n   */\n  invertString(theString) {\n\n    if (theString.length > 0) {\n      let stringRep = theString.replace('/', \"!\").replace('.', '/').replace(\"!\", '.');\n      switch(stringRep.charAt(0)) {\n        case '.' : theString = stringRep.substr(1); break;\n        case '/' : theString = stringRep; break;\n        default  : theString = \"/\" + stringRep;\n      }\n    }\n    return theString;\n\n  } // end invertString\n\n\n  /**\n   * This function handles concatenation of two strings and an operator.\n   * It's called to build unit data, e.g., unit name, unit code, etc., from\n   * two different units, joined by the specified operator.\n   *\n   * @param str1 the first string to appear in the result\n   * @param operator the operator ('*', '.' or '/') to appear between the strings\n   * @param str2 the second string to appear in the result\n   * @param startChar the starting character to be used, when needed, to\n   *  enclose a string\n   * @param endChar the ending character to be used, when needed, to enclose\n   *  a string\n   * @returns the built string\n   */\n  _concatStrs(str1, operator, str2, startChar, endChar) {\n\n    return this._buildOneString(str1, startChar, endChar) +\n      operator + this._buildOneString(str2, startChar, endChar) ;\n  }\n\n\n  /**\n   * This function handles creation of one string to be included in a\n   * concatenated string.   Basically it checks to see if the string\n   * needs to be enclosed either in parentheses or square brackets.\n   *\n   * The string is enclosed if it is not a number, is not already enclosed in a pair of\n   * parentheses or square brackets, and includes a period, and asterisk,\n   * a slash or a blank space.\n   *\n   * @param str the string\n   * @param startChar starting enclosing character\n   * @param endChar ending enclosing character\n   * @returns the string\n   */\n  _buildOneString(str, startChar, endChar) {\n    let ret = '' ;\n    if (intUtils_.isNumericString(str)) {\n      ret = str;\n    }\n    else {\n      if (str.charAt(0) === '(' && str.endsWith(')') || str.charAt(0) === '['  && str.endsWith(']')) {\n        ret = str;\n      }\n      else if (/[./* ]/.test(str)) {\n        ret = startChar + str + endChar ;\n      }\n      else {\n        ret = str ;\n      }\n    }\n    return ret ;\n  }\n\n\n  /**\n   * Raises the unit to a power.  For example\n   *  kg.m/s2 raised to the -2 power would be kg-2.m-2/s-4\n   *\n   * If this unit is not on a ratio scale an error is thrown. Mutating\n   * to a ratio scale unit is not possible for a unit, only for a\n   * measurement (magnitude and dimension).\n   *\n   * This is based on the pow method in Gunter Schadow's java version,\n   * although it uses javascript capabilities to simplify the processing.\n   *\n   * This unit is modified by this function\n   *\n   * @param p the power to with this unit is to be raise\n   * @return this unit after it is raised\n   * @throws an error if this unit is not on a ratio scale.\n   */\n  power(p) {\n\n    if (this.cnv_ != null)\n      throw (new Error(`Attempt to raise a non-ratio unit, ${this.name_}, ` +\n                       'to a power.'));\n\n    //this.name_ = UnitString.pow(this.name_, p);\n    // the above line is replaced with the code below, as the pow method\n    // never actually existing in the UnitString class.  (Tried to use\n    // Schadow java code but this way ended up being a lot easier).\n    let uStr = this.csCode_ ;\n    let uArray = uStr.match(/([./]|[^./]+)/g) ;\n    let arLen = uArray.length;\n\n    for (let i = 0; i < arLen; i++) {\n      let un = uArray[i] ;\n      if (un !== '/' && un !== '.') {\n        let nun = parseInt(un);\n        if (isInteger(nun))\n          uArray[i] = (Math.pow(nun, p).toString());\n        else {\n          let uLen = un.length ;\n          for (let u = uLen - 1; u >= 0; u--) {\n            let uChar = parseInt(un[u]);\n            if (!isInteger(uChar)) {\n              if (un[u] === '-' || un[u] === '+') {\n                u--;\n              }\n              if (u < uLen - 1) {\n                let exp = parseInt(un.substr(u));\n                exp = Math.pow(exp, p);\n                uArray[i] = un.substr(0, u) + exp.toString();\n                u = -1;\n              }\n              else {\n                uArray[i] += p.toString();\n                u = -1;\n              } // end if there are/aren't some numbers at the end\n              u = -1;\n            } // end if this character is not a number\n          } // end searching backwards for start of exponent\n        } // end if this element is not a number\n      } // end if the current element is not an operator\n    } // end do for each element of the units array\n\n    // reassemble the updated units array to a string\n    this.csCode_ = uArray.join('');\n\n    this.magnitude_ = Math.pow(this.magnitude_, p);\n    if (this.dim_) {\n      this.dim_.mul(p);\n    }\n    return this;\n\n  } // end power\n\n\n  /*\n   * This function tests this unit against the unit passed in to see if the\n   * two are mole to mass commensurable.  It assumes that one of the units\n   * is a mole-based unit and the other is a mass-based unit.  It also assumes\n   * that the mole-based unit has a single mole unit in the numerator and that\n   * the mass-based unit has a single mass unit in the numerator.  It does NOT\n   * check to validate those assumptions.\n   *\n   * The check is made by setting the dimension vector element corresponding\n   * to the base mass unit (gram) in the mole unit, and then comparing the\n   * two dimension vectors.  If they match, the units are commensurable.\n   * Otherwise they are not.\n   *\n   * @param unit2 the unit to be compared to this one\n   * @returns boolean indicating commensurability\n   */\n  isMoleMassCommensurable(unit2) {\n    let tabs = this._getUnitTables();\n    let d = tabs.getMassDimensionIndex();\n    let commensurable = false ;\n    if (this.moleExp_ === 1 && unit2.moleExp_ === 0) {\n      let testDim = this.dim_.clone();\n      let curVal = testDim.getElementAt(d);\n      testDim.setElementAt(d, (curVal + this.moleExp_));\n      commensurable = (testDim.equals(unit2.dim_));\n    }\n    else if (unit2.moleExp_ === 1 && this.moleExp_ === 0) {\n      let testDim = unit2.dim_.clone();\n      let curVal = testDim.getElementAt(d);\n      testDim.setElementAt(d, (curVal + unit2.moleExp_));\n      commensurable = (testDim.equals(this.dim_));\n    }\n    return commensurable ;\n  }\n\n\n  /**\n   * This returns the UnitTables singleton object.  Including the require\n   * statement included here causes a circular dependency condition that\n   * resulted in the UnitTables object not being defined for the Unit object.\n   * sigh.  Thanks, Paul, for figuring this out.\n   *\n   * @private\n   */\n  _getUnitTables() {\n    if (!UnitTables)\n      UnitTables = require('./unitTables.js').UnitTables;\n    return UnitTables.getInstance();\n  }\n\n} // end Unit class\n","/**\n * This class handles the parsing of a unit string into a unit object\n */\n\nvar Ucum = require('./config.js').Ucum;\nvar Unit = require('./unit.js').Unit;\nvar UnitTables = require('./unitTables.js').UnitTables;\nvar PrefixTables = require('./prefixTables.js').PrefixTables;\n\nimport * as intUtils_ from \"./ucumInternalUtils.js\";\n\nexport class UnitString {\n\n  /**\n   * Constructor\n   */\n  constructor() {\n\n    // Get instances of the unit and prefix tables and the utilities\n    this.utabs_ = UnitTables.getInstance();\n    this.pfxTabs_ = PrefixTables.getInstance();\n\n    // Set emphasis characters to defaults.  These are used to emphasize\n    // certain characters or strings in user messages.  They can be reset in\n    // the useHTMLInMessages method.\n    this.openEmph_ = Ucum.openEmph_;\n    this.closeEmph_ = Ucum.closeEmph_;\n\n    // Set the braces message to blank.  This message is displayed for each\n    // validation request on the web page, but is included separately as\n    // a note on the validation spreadsheet.  The useBraceMsgForEachString\n    // method should be used to set the message to be displayed for each\n    // unit string.\n    this.bracesMsg_ = '';\n\n    // Set the flags used, with indices, as place holders in unit strings\n    // for parenthetical strings and strings within braces.\n    this.parensFlag_ = \"parens_placeholder\"; // in lieu of Jehoshaphat\n    this.pFlagLen_ = this.parensFlag_.length;\n    this.braceFlag_ = \"braces_placeholder\"; // in lieu of Nebuchadnezzar\n    this.bFlagLen_ = this.braceFlag_.length;\n\n    // Initialize the message start/end strings, which will be set when\n    // parseString is called.\n    this.vcMsgStart_ = null;\n    this.vcMsgEnd_ = null;\n\n    // Arrays used by multiple methods within this class to hold persistent\n    // data.  Just gets too bulky to pass these guys around.\n\n    // Messages to be returned to the calling function\n    this.retMsg_ = [] ;\n\n    // Units for parenthetical unit strings\n    this.parensUnits_ = [] ;\n\n    // annotation text for annotations found in unit strings\n    this.annotations_ = [] ;\n\n    // suggestions for unit strings that for which no unit was found\n    this.suggestions = [] ;\n  } // end constructor\n\n\n  // The start of an error message about an invalid annotation character.\n  static INVALID_ANNOTATION_CHAR_MSG = 'An invalid character was found in the annotation ';\n\n  // A regular expression for validating annotation strings.\n  static VALID_ANNOTATION_REGEX = /^\\{[!-z|~]*\\}$/;\n\n  /**\n   * Sets the emphasis strings to the HTML used in the webpage display - or\n   * blanks them out, depending on the use parameter.\n   *\n   * @param use flag indicating whether or not to use the html message format;\n   *  defaults to true\n   */\n  useHTMLInMessages(use) {\n    if (use === undefined || use) {\n      this.openEmph_ = Ucum.openEmphHTML_;\n      this.closeEmph_ = Ucum.closeEmphHTML_;\n    }\n    else {\n      this.openEmph_ = Ucum.openEmph_;\n      this.closeEmph_ = Ucum.closeEmph_;\n    }\n  } // end useHTMLInMessages\n\n\n  /**\n   * Sets the braces message to be displayed for each unit string validation\n   * requested, as appropriate.\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useBraceMsgForEachString(use) {\n    if (use === undefined || use)\n      this.bracesMsg_ = Ucum.bracesMsg_;\n    else\n      this.bracesMsg_ = '';\n  }\n\n\n  /**\n   * Parses a unit string, returns a unit, a possibly updated version of\n   * the string passed in, and messages and suggestions where appropriate.\n   *\n   * The string returned may be updated if the input string contained unit\n   * names, e.g., \"pound\".  The unit code ([lb_av] for pound) is placed in\n   * the string returned, a the returned messages array includes a note\n   * explaining the substitution.\n   *\n   * @param uStr the string defining the unit\n   * @param valConv indicates what type of request this is for - a request to\n   *  validate (pass in 'validate') or a request to convert (pass in 'convert');\n   *  optional, defaults to 'validate'\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @returns an array containing:\n   *   the unit object or null if a unit could not be created.  In cases where\n   *     a fix was found for a problem string, .e.g., 2.mg for 2mg, a unit will\n   *     be returned but an error message will also be returned, describing\n   *     the substitution;\n   *   the possibly updated unit string passed in;\n   *   an array of any user messages (informational, error or warning)\n   *     generated (or an empty array); and\n   *   a suggestions array of hash objects (1 or more).  Each hash contains\n   *   three elements:\n   *     'msg' which is a message indicating what unit expression the\n   *       suggestions are for;\n   *     'invalidUnit' which is the unit expression the suggestions are\n   *       for; and\n   *     'units' which is an array of data for each suggested unit found.\n   *        Each array will contain the unit code, the unit name and the\n   *        unit guidance (if any).\n   *   The return array will not contain a suggestions array if a valid unit\n   *   was found or if suggestions were not requested.\n   * @throws an error if nothing was specified.\n   */\n  parseString(uStr, valConv, suggest) {\n\n    uStr = uStr.trim();\n    // Make sure we have something to work with\n    if (uStr === '' || uStr === null) {\n      throw (new Error('Please specify a unit expression to be validated.'));\n    }\n\n    if (valConv === 'validate') {\n      this.vcMsgStart_ = Ucum.valMsgStart_;\n      this.vcMsgEnd_ = Ucum.valMsgEnd_;\n    }\n    else {\n      this.vcMsgStart_ = Ucum.cnvMsgStart_;\n      this.vcMsgEnd_ = Ucum.cnvMsgEnd_;\n    }\n\n    if (suggest === undefined || suggest === false) {\n      this.suggestions_ = null;\n    }\n    else {\n      this.suggestions_ = [] ;\n    }\n\n    this.retMsg_ = [];\n    this.parensUnits_ = [];\n    this.annotations_ = [] ;\n\n    let origString = uStr;\n    let retObj = [];\n\n    // Extract any annotations, i.e., text enclosed in braces ({}) from the\n    // string before further processing.  Store each one in this.annotations_\n    // array and put a placeholder in the string for the annotation.  Do\n    // this before other processing in case an annotation contains characters\n    // that will be interpreted as parenthetical markers or operators in\n    // subsequent processing.\n\n    uStr = this._getAnnotations(uStr);\n    if (this.retMsg_.length > 0) {\n      retObj[0] = null;\n      retObj[1] = null;\n    }\n    else {\n      // Flag used to block further processing on an unrecoverable error\n      let endProcessing = this.retMsg_.length > 0;\n\n      // First check for one of the \"special\" units.  If it's one of those, put\n      // in a substitution phrase for it to avoid having it separated on its\n      // embedded operator.  This will only happen, by the way, if it is\n      // preceded by a prefix or followed by an operator and another unit.\n      let sUnit = null ;\n      for (sUnit in Ucum.specUnits_) {\n        while (uStr.indexOf(sUnit) !== -1)\n          uStr = uStr.replace(sUnit, Ucum.specUnits_[sUnit]);\n      }\n\n      // Check for spaces and throw an error if any are found.  The spec\n      // explicitly forbids spaces except in annotations, which is why any\n      // annotations are extracted before this check is made.\n      if (uStr.indexOf(' ') > -1) {\n        throw (new Error('Blank spaces are not allowed in unit expressions.'));\n      } // end if blanks were found in the string\n\n      // assign the array returned to retObj.  It will contain 2 elements:\n      //  the unit returned in position 0; and the origString (possibly\n      //  modified) in position 1.  The origString in position 1 will not\n      //  be changed by subsequent processing.\n      retObj = this._parseTheString(uStr, origString);\n      let finalUnit = retObj[0];\n\n      // Do a final check to make sure that finalUnit is a unit and not\n      // just a number.  Something like \"8/{HCP}\" will return a \"unit\" of 8\n      // - which is not a unit.  Hm - evidently it is.  So just create a unit\n      // object for it.\n      if (intUtils_.isIntegerUnit(finalUnit) || typeof finalUnit === 'number') {\n        finalUnit = new Unit({\n          'csCode_': origString,\n          'ciCode_': origString,\n          'magnitude_': finalUnit,\n          'name_': origString\n        });\n        retObj[0] = finalUnit;\n      } // end final check\n    } // end if no annotation errors were found\n\n    retObj[2] = this.retMsg_;\n    if (this.suggestions_ && this.suggestions_.length > 0)\n      retObj[3] = this.suggestions_ ;\n    return retObj;\n\n  } // end parseString\n\n\n  /**\n   * Parses a unit string, returns a unit, a possibly updated version of\n   * the string passed in, and messages where appropriate.  This should\n   * only be called from within this class (or by test code).\n   *\n   * The string returned may be updated if the input string contained unit\n   * names, e.g., \"pound\".  The unit code ([lb_av] for pound) is placed in\n   * the string returned, a the returned messages array includes a note\n   * explaining the substitution.\n   *\n   * @param uStr the string defining the unit\n   * @param origString the original unit string passed in\n   *\n   * @returns\n   *  an array containing:\n   *    the unit object (or null if there were problems creating the unit); and\n   *    the possibly updated unit string passed in.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * the this.parensUnits_ array is referenced and possibly populated by\n   *   methods called within this one\n   * the this.annotations_ array is referenced by methods called within\n   *   this one\n   * the this.suggestions_ array may be populated by methods called within\n   *   this one\n   */\n  _parseTheString(uStr, origString) {\n\n    // Unit to be returned\n    let finalUnit = null;\n\n    // Flag used to block further processing on an unrecoverable error\n    let endProcessing = this.retMsg_.length > 0;\n\n    // Call _processParens to search for and process any/all parenthetical\n    // strings in uStr.  Units created for parenthetical strings will be\n    // stored in the this.parensUnits_ array.\n    let parensResp = this._processParens(uStr, origString);\n    endProcessing = parensResp[2];\n\n    // The array used to hold the units and their operators.\n    let uArray = [];\n\n    // Continue if we didn't hit a problem\n    if (!endProcessing) {\n      uStr = parensResp[0];\n      origString = parensResp[1];\n\n      // Call _makeUnitsArray to convert the string to an array of unit\n      // descriptors with operators.\n      let mkUArray = this._makeUnitsArray(uStr, origString);\n\n      endProcessing = mkUArray[2] ;\n      if (!endProcessing) {\n        uArray = mkUArray[0];\n        origString = mkUArray[1];\n        // Create a unit object out of each un element\n        let uLen = uArray.length;\n        for (let u1 = 0; u1 < uLen; u1++) {\n          //for (let u1 = 0; u1 < uLen && !endProcessing; u1++) {\n          let curCode = uArray[u1]['un'];\n\n          // Determine the type of the \"un\" attribute of the current array element\n\n          // Check to see if it's a number.  If so write the number version of\n          // the number back to the \"un\" attribute and move on\n          if (intUtils_.isIntegerUnit(curCode)) {\n            uArray[u1]['un'] = Number(curCode);\n          }\n\n          else {\n            // The current unit array element is a string.  Check now to see\n            // if it is or contains a parenthesized unit from this.parensUnits_.\n            // If so, call _getParens to process the string and get the unit.\n\n            if (curCode.indexOf(this.parensFlag_) >= 0) {\n              let parenUnit = this._getParensUnit(curCode, origString);\n              // if we couldn't process the string, set the end flag and bypass\n              // further processing.\n              if (!endProcessing)\n                endProcessing = parenUnit[1];\n\n              // If we're good, put the unit in the uArray and replace the\n              // curCode, which contains the parentheses placeholders, etc.,\n              // with the unit's code - including any substitutions.\n              if (!endProcessing) {\n                uArray[u1]['un'] = parenUnit[0];\n              }\n            } // end if the curCode contains a parenthesized unit\n\n            // Else it's not a parenthetical unit and not a number. Call\n            // _makeUnit to create a unit for it.\n            else {\n              let uRet = this._makeUnit(curCode, origString);\n              // If we didn't get a unit, set the endProcessing flag.\n              if (uRet[0] === null) {\n                endProcessing = true;\n              }\n              else {\n                uArray[u1]['un'] = uRet[0];\n                origString = uRet[1];\n              }\n            } // end if the curCode is not a parenthetical expression\n          } // end if the \"un\" array is a not a number\n        } // end do for each element in the units array\n      } // end if _makeUnitsArray did not return an error\n    } // end if _processParens did not find an error that causes a stop\n\n    // If we're still good, continue\n    if (!endProcessing) {\n      // Process the units (and numbers) to create one final unit object\n      if ((uArray[0] === null || uArray[0] === ' ' ||\n           uArray[0]['un'] === undefined || uArray[0]['un'] === null)\n          && this.retMsg_.length === 0) {\n        // not sure what this might be, but this is a safeguard\n        this.retMsg_.push(`Unit string (${origString}) did not contain ` +\n          `anything that could be used to create a unit, or else something ` +\n          `that is not handled yet by this package.  Sorry`);\n        endProcessing = true;\n      }\n    }\n    if (!endProcessing) {\n      finalUnit = this._performUnitArithmetic(uArray, origString);\n    }\n    return [finalUnit, origString];\n  } // end _parseTheString\n\n\n  /**\n   * Extracts all annotations from a unit string, replacing them with\n   * placeholders for later evaluation.  The annotations are stored in the\n   * this.annotations_ array.  This should only be called from within this\n   * class (or by test code).\n   *\n   * @param uString the unit string being parsed\n   * @returns the string after the annotations are replaced with placeholders\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * the this.annotations_ array is populated by this method\n   */\n  _getAnnotations(uString) {\n    let openBrace = uString.indexOf('{');\n    while (openBrace >= 0) {\n\n      let closeBrace = uString.indexOf('}');\n      if (closeBrace < 0) {\n        this.retMsg_.push('Missing closing brace for annotation starting at ' +\n          this.openEmph_ + uString.substr(openBrace) +\n          this.closeEmph_);\n        openBrace = -1;\n      }\n      else {\n        let braceStr = uString.substring(openBrace, closeBrace + 1);\n        // Check for valid characters in the annotation.\n        if (!UnitString.VALID_ANNOTATION_REGEX.test(braceStr)) {\n          this.retMsg_.push(UnitString.INVALID_ANNOTATION_CHAR_MSG +\n            this.openEmph_ + braceStr + this.closeEmph_);\n          openBrace = -1; // end search for annotations\n        }\n        else {\n          let aIdx = this.annotations_.length.toString();\n          uString = uString.replace(braceStr, this.braceFlag_ + aIdx +\n            this.braceFlag_);\n          this.annotations_.push(braceStr);\n          openBrace = uString.indexOf('{');\n        }\n      }\n    } // end do while we have an opening brace\n\n    // check for a stray/unmatched closing brace\n    if (this.retMsg_.length == 0) { // if there were no other errors above\n      let closeBrace = uString.indexOf('}');\n      if (closeBrace >= 0)\n        this.retMsg_.push('Missing opening brace for closing brace found at ' +\n          this.openEmph_ + uString.substring(0, closeBrace + 1) +\n          this.closeEmph_);\n    }\n    return uString;\n  } // end _getAnnotations\n\n\n  /**\n   * Finds and processes any/all parenthesized unit strings. This should only\n   * be called from within this class (or by test code).\n   *\n   * Nested parenthesized strings are processed from the inside out.  The\n   * parseString function is called from within this one for each parenthesized\n   * unit string, and the resulting unit object is stored in this.parensUnits_,\n   * to be processed after all strings are translated to units.\n   *\n   * A placeholder is placed in the unit string returned to indicate that the\n   * unit object should be obtained from the this.parensUnits_ array.  The\n   * placeholder consists of the parenthesis flag (this.parensFlag_) followed\n   * by the index of the unit in this.parensUnits_ followed by this.parensFlag_.\n   *\n   * @param uString the unit string being parsed, where this will be the full\n   *  string the first time this is called and parenthesized strings on any\n   *  subsequent calls\n   * @param origString the original string first passed in to parseString\n   * @returns\n   *  an array containing:\n   *   the string after the parentheses are replaced;\n   *   the original string; and\n   *   a boolean flag indicating whether or not an error occurred that\n   *     should stop processing.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * this this.parensUnits_ array will be populated with units found for\n   *   parenthetical unit strings\n   */\n  _processParens(uString, origString) {\n\n    // Unit strings array and index\n    let uStrArray = [];\n    let uStrAryPos = 0;\n    let stopProcessing = false;\n\n    let pu = this.parensUnits_.length;\n\n    // Count of characters trimmed off the beginning of the unit string (uString)\n    // as units are removed from it; used for error messages to provide\n    // context.\n    let trimmedCt = 0;\n\n    // Break the unit string into pieces that consist of text outside of\n    // parenthetical strings and placeholders for the parenthetical units.\n    // This method is called recursively for parenthetical strings and the units\n    // returned are stored in the this.parensUnits_ array.\n    while (uString !== \"\" && !stopProcessing) {\n      let openCt = 0;\n      let closeCt = 0;\n      let openPos = uString.indexOf('(');\n\n      // If an opening parenthesis was not found, check for an unmatched\n      // close parenthesis.  If one was found report the error and end\n      // processing.\n      if (openPos < 0) {\n        let closePos = uString.indexOf(')');\n        if (closePos >= 0) {\n          let theMsg = `Missing open parenthesis for close ` +\n            `parenthesis at ${uString.substring(0, closePos + trimmedCt)}` +\n            `${this.openEmph_}${uString.substr(closePos, 1)}${this.closeEmph_}`;\n          if (closePos < uString.length - 1) {\n            theMsg += `${uString.substr(closePos + 1)}`;\n          }\n          this.retMsg_.push(theMsg);\n          uStrArray[uStrAryPos] = uString;\n          stopProcessing = true;\n        } // end if a close parenthesis was found\n\n        // If no parentheses were found in the current unit string, transfer\n        // it to the units array and blank out the string, which will end\n        // the search for parenthetical units.\n        else {\n          uStrArray[uStrAryPos] = uString;\n          uString = \"\";\n        } // end if no close parenthesis was found\n      } // end if no open parenthesis was found\n\n      // Otherwise an open parenthesis was found. Process the string that\n      // includes the parenthetical group\n      else {\n        openCt += 1;\n        // Write the text before the parentheses (if any) to the unit strings array\n        let uLen = uString.length;\n        if (openPos > 0) {\n          uStrArray[uStrAryPos++] = uString.substr(0, openPos);\n        }\n\n        // Find the matching closePos, i.e., the one that closes the\n        // parenthetical group that this one opens.  Look also for\n        // another open parenthesis, in case this includes nested parenthetical\n        // strings.  This continues until it finds the same number of close\n        // parentheses as open parentheses, or runs out of string to check.\n        // In the case of nested parentheses this will identify the outer set\n        // of parentheses.\n        let closePos = 0;\n        let c = openPos + 1;\n        for (; c < uLen && openCt != closeCt; c++) {\n          if (uString[c] === '(')\n            openCt += 1;\n          else if (uString[c] === ')')\n            closeCt += 1;\n        }\n\n        // Put a placeholder for the group in the unit strings array and recursively\n        // call this method for the parenthetical group.  Put the unit returned\n        // in this.parensUnits_.  Set the unit string to whatever follows\n        // the position of the closing parenthesis for this group, to be\n        // processed by the next iteration of this loop.  If there's nothing\n        // left uString is set to \"\".\n        if (openCt === closeCt) {\n          closePos = c;\n          uStrArray[uStrAryPos++] = this.parensFlag_ + pu.toString() + this.parensFlag_;\n          let parseResp = this._parseTheString(\n            uString.substring(openPos + 1, closePos - 1), origString);\n          if (parseResp[0] === null)\n            stopProcessing = true;\n          else {\n            origString = parseResp[1];\n            this.parensUnits_[pu++] = parseResp[0];\n            uString = uString.substr(closePos);\n            trimmedCt = closePos;\n          }\n        } // end if the number of open and close parentheses matched\n\n        // If the number of open and close parentheses doesn't match, indicate\n        // an error.\n        else {\n          uStrArray.push(origString.substr(openPos));\n          this.retMsg_.push(`Missing close parenthesis for open parenthesis at ` +\n            `${origString.substring(0, openPos + trimmedCt)}` +\n            `${this.openEmph_}${origString.substr(openPos, 1)}` +\n            `${this.closeEmph_}${origString.substr(openPos + 1)}`);\n          stopProcessing = true;\n        }\n      } // end if an open parenthesis was found\n    } // end do while the input string is not empty\n    if (stopProcessing)\n      this.parensUnits_ = [];\n    return [uStrArray.join(''), origString, stopProcessing]\n  } // end _processParens\n\n\n  /**\n   * Breaks the unit string into an array of unit descriptors and operators.\n   * If a unit descriptor consists of a number preceding a unit code, with\n   * no multiplication operator, e.g., 2mg instead of 2.mg, it is handled\n   * as if it were a parenthetical expression.\n   *\n   * This should only be called from within this class (or by test code).\n   *\n   * @param uStr the unit string being parsed\n   * @param origString the original string passed to parseString\n   * @returns\n   *  an array containing:\n   *    the array representing the unit string;\n   *    the original string passed in, possibly updated with corrections; and\n   *    and a flag indicating whether or not processing can continue.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   */\n  _makeUnitsArray(uStr, origString) {\n\n    // Separate the string into pieces based on delimiters / (division) and .\n    // (multiplication).  The idea is to get an array of units on which we\n    // can then perform any operations (prefixes, multiplication, division).\n\n    let uArray1 = uStr.match(/([./]|[^./]+)/g);\n    let endProcessing = false ;\n    let uArray = [];\n    let startNumCheck = /(^[0-9]+)(\\[?[a-zA-Z\\_0-9a-zA-Z\\_]+\\]?$)/ ;\n\n    // If the first element in the array is the division operator (/), the\n    // string started with '/'.  Add a first element containing 1 to the\n    // array, which will cause the correct computation to be performed (inversion).\n    if (uArray1[0] === \"/\") {\n      uArray1.unshift(\"1\");\n    }\n    // If the first element in the array is the multiplication operator (.)\n    // return an error.\n    else if (uArray1[0] === '.') {\n      this.retMsg_.push(`${origString} is not a valid UCUM code. ` +\n          `The multiplication operator at the beginning of the expression is ` +\n          `not valid. A multiplication operator must appear only between ` +\n          `two codes.`);\n      endProcessing = true ;\n    }\n    if (!endProcessing) {\n      // Check to see if there is a number preceding a unit code, e.g., 2mg\n      // If so, update the first element to remove the number (2mg -> mg) and\n      // add two elements to the beginning of the array - the number and the\n      // multiplication operator.\n\n      if (!intUtils_.isNumericString(uArray1[0])) {\n        let numRes = uArray1[0].match(startNumCheck);\n        if (numRes && numRes.length === 3 && numRes[1] !== '' &&\n          numRes[2] !== '' && numRes[2].indexOf(this.braceFlag_) !== 0) {\n          let dispVal = numRes[2] ;\n\n          if (!endProcessing && numRes[2].indexOf(this.parensFlag_) !== -1) {\n            let parensback = this._getParensUnit(numRes[2], origString);\n            numRes[2] = parensback[0]['csCode_'];\n            dispVal = `(${numRes[2]})`;\n            endProcessing = parensback[1];\n          }\n          if (!endProcessing) {\n            this.retMsg_.push(`${numRes[1]}${dispVal} is not a valid UCUM code.` +\n              `  ${this.vcMsgStart_}${numRes[1]}.${dispVal}${this.vcMsgEnd_}`);\n            origString = origString.replace(`${numRes[1]}${dispVal}`,\n              `${numRes[1]}.${dispVal}`);\n            uArray1[0] = numRes[2];\n            uArray1.unshift(numRes[1], '.');\n          }\n        }\n      } // end if the first element is not a number (only)\n\n      // Create an array of unit/operator objects.  The unit is, for now, the\n      // string containing the unit code (e.g., Hz for hertz) including\n      // a possible prefix and exponent.   The operator is the operator to be\n      // applied to that unit and the one preceding it.  So, a.b would give\n      // us two objects.  The first will have a unit of a, and a blank operator\n      // (because it's the first unit).  The second would have a unit of b\n      // and the multiplication operator (.).\n      if (!endProcessing) {\n        let u1 = uArray1.length;\n        uArray = [{op: \"\", un: uArray1[0]}];\n        for (let n = 1; n < u1; n++) {\n\n          // check to make sure that we don't have two operators together, e.g.,\n          // mg./K.  If so, let the user know the problem.\n          let theOp = uArray1[n++];\n          // oh wait - check to make sure something is even there, that the\n          // user didn't end the expression with an operator.\n          if (!uArray1[n]) {\n            this.retMsg_.push(`${origString} is not a valid UCUM code. ` +\n              `It is terminated with the operator ${this.openEmph_}` +\n              `${theOp}${this.closeEmph_}.`);\n            n = u1;\n            endProcessing = true;\n          }\n          else if (Ucum.validOps_.indexOf(uArray1[n]) !== -1) {\n            this.retMsg_.push(`${origString} is not a valid UCUM code. ` +\n              `A unit code is missing between${this.openEmph_}` +\n              `${theOp}${this.closeEmph_}and${this.openEmph_}` +\n              `${uArray1[n]}${this.closeEmph_}in${this.openEmph_}` +\n              `${theOp}${uArray1[n]}${this.closeEmph_}.`);\n            n = u1;\n            endProcessing = true;\n          }\n          else {\n            // Check to see if a number precedes a unit code.\n            // If so, send the element to _processParens, inserting the multiplication\n            // operator where it belongs.  Treating it as parenthetical keeps it from\n            // being interpreted incorrectly because of operator parentheses.  For\n            // example, if the whole string is mg/2kJ we don't want to rewrite it as\n            // mg/2.kJ - because mg/2 would be performed, followed by .kJ.  Instead,\n            // handling 2kJ as a parenthesized unit will make sure mg is divided by\n            // 2.kJ.\n            if (!intUtils_.isNumericString(uArray1[n])) {\n              let numRes2 = uArray1[n].match(startNumCheck);\n              if (numRes2 && numRes2.length === 3 && numRes2[1] !== '' &&\n                numRes2[2] !== '' && numRes2[2].indexOf(this.braceFlag_) !== 0) {\n                let invalidString = numRes2[0];\n                if (!endProcessing && numRes2[2].indexOf(this.parensFlag_) !== -1) {\n                  let parensback = this._getParensUnit(numRes2[2], origString);\n                  numRes2[2] = parensback[0]['csCode_'];\n                  invalidString = `(${numRes2[2]})`;\n                  endProcessing = parensback[1];\n                  if (!endProcessing) {\n                    this.retMsg_.push(`${numRes2[1]}${invalidString} is not a ` +\n                      `valid UCUM code.  ${this.vcMsgStart_}${numRes2[1]}.${invalidString}` +\n                      `${this.vcMsgEnd_}`);\n                    let parensString = `(${numRes2[1]}.${invalidString})`;\n                    origString = origString.replace(`${numRes2[1]}${invalidString}`,\n                      parensString);\n                    let nextParens = this._processParens(parensString, origString);\n                    endProcessing = nextParens[2];\n                    if (!endProcessing) {\n                      uArray.push({op: theOp, un: nextParens[0]});\n                    }\n                    //uArray.push({op: '.', un: numRes2[2]});\n                  }\n                } // end if the string represents a parenthesized unit\n                else {\n                  let parensStr = '(' + numRes2[1] + '.' + numRes2[2] + ')';\n                  let parensResp = this._processParens(parensStr, origString);\n                  // if a \"stop processing\" flag was returned, set the n index to end\n                  // the loop and set the endProcessing flag\n                  if (parensResp[2]) {\n                    n = u1;\n                    endProcessing = true;\n                  }\n                  else {\n                    this.retMsg_.push(`${numRes2[0]} is not a ` +\n                      `valid UCUM code.  ${this.vcMsgStart_}${numRes2[1]}.${numRes2[2]}` +\n                      `${this.vcMsgEnd_}`);\n                    origString = origString.replace(numRes2[0], parensStr);\n                    uArray.push({op: theOp, un: parensResp[0]});\n                  } // end if no error on the processParens call\n                } // end if the string does not represent a parenthesized unit\n              } // end if the string is a number followed by a string\n              else {\n                uArray.push({op: theOp, un: uArray1[n]});\n              }\n            }\n            else {\n              uArray.push({op: theOp, un: uArray1[n]});\n            }\n          } // end if there isn't a missing operator or unit code\n        } // end do for each element in uArray1\n      } // end if a processing error didn't occur in getParensUnit\n    } // end if the string did not begin with a '.' with no following digit\n    return [uArray, origString, endProcessing];\n  } // end _makeUnitsArray\n\n\n  /**\n   * Takes a unit string containing parentheses flags and returns the unit they\n   * represent.  Any text found before and/or after the parenthetical\n   * expression is checked to see if we can tell what the user meant and\n   * let them know what it should have been.  For example, 2(mg), which\n   * would resolve to 2mg, should be 2.mg.\n   *\n   * This should only be called from within this class (or by test code).\n   *\n   * @param pStr the string being parsed\n   * @param origString the original unit string passed in; passed through\n   *  to _getAnnonText if annotation flags are found in any text preceding\n   *  or following the parenthetical unit\n   * @returns\n   *   an array containing\n   *     the unit object; and\n   *     a flag indicating whether or not processing should be ended.\n   *       True indicates that the string was invalid and no corrections\n   *         (substitutions or suggestions) could be found;\n   *       False indicates that it was either valid or substitutions/suggestions\n   *          were made.\n   *   the this.retMsg_ array will be updated with any user messages\n   *     (informational, error or warning) generated by this or called methods\n   *   this this.parensUnits_ array contains the units that are acquired by\n   *     this method\n   * @throws an error if an invalid parensUnit index was found.  This is\n   *    a processing error.\n   */\n  _getParensUnit(pStr, origString) {\n    let endProcessing = false;\n    let retAry = [];\n    let retUnit = null;\n    let befAnnoText = null;\n    let aftAnnoText = null;\n\n    // Get the location of the flags.  We're assuming there are only two\n    // because _processParens takes care of nesting.  By the time we get\n    // here we should not be looking a nested parens.  Also get any text\n    // before and after the parentheses.  Once we get the unit we update\n    // the input string with the unit's csCode_, which will wipe out any\n    // before and after text\n    let psIdx = pStr.indexOf(this.parensFlag_);\n    let befText = null;\n    if (psIdx > 0) {\n      befText = pStr.substr(0, psIdx - 1);\n    }\n    let peIdx = pStr.lastIndexOf(this.parensFlag_);\n    let aftText = null;\n    if (peIdx + this.pFlagLen_ < pStr.length) {\n      aftText = pStr.substr(peIdx + this.pFlagLen_);\n    }\n\n    // Get the text between the flags\n    let pNumText = pStr.substring(psIdx + this.pFlagLen_, peIdx);\n\n    // Make sure the index is a number, and if it is, get the unit from the\n    // this.parensUnits_ array\n    if (intUtils_.isNumericString(pNumText)) {\n      retUnit = this.parensUnits_[Number(pNumText)];\n      if (!intUtils_.isIntegerUnit(retUnit)) {\n        pStr = retUnit.csCode_;\n      }\n      else {\n        pStr = retUnit ;\n      }\n    }\n    // If it's not a number, it's a programming error.  Throw a fit.\n    else {\n      throw (new Error(`Processing error - invalid parens number ${pNumText} ` +\n        `found in ${pStr}.`));\n    }\n\n    // If there's something in front of the starting parentheses flag, check to\n    // see if it's a number or an annotation.\n    if (befText) {\n      // If it's a number, assume that multiplication was assumed\n      if (intUtils_.isNumericString(befText)) {\n        let nMag = retUnit.getProperty('magnitude_');\n        nMag *= Number(befText);\n        retUnit.assignVals({'magnitude_': nMag});\n        pStr = `${befText}.${pStr}`;\n        this.retMsg_.push(`${befText}${pStr} is not a valid UCUM code.\\n` +\n          this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n      }\n      else {\n        if (befText.indexOf(this.braceFlag_) >= 0) {\n          let annoRet = this._getAnnoText(befText, origString);\n          // if we found not only an annotation, but text before or after\n          // the annotation (remembering that this is all before the\n          // parentheses) throw an error - because we don't know what\n          // to do with it.  Could it be missing an operator?\n          if (annoRet[1] || annoRet[2]) {\n            throw (new Error(`Text found before the parentheses (` +\n              `${befText}) included an annotation along with other text ` +\n              `for parenthetical unit ${retUnit.csCode_}`));\n          }\n          // Otherwise put the annotation after the unit string and note\n          // the misplacement.\n          pStr += annoRet[0];\n          this.retMsg_.push(`The annotation ${annoRet[0]} before the unit ` +\n            `code is invalid.\\n` + this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n        }\n        // else the text before the parentheses is neither a number nor\n        // an annotation.  If suggestions were NOT requested, record an\n        // error.\n        else if (!this.suggestions_) {\n          this.retMsg_.push(`${befText} preceding the unit code ${pStr} ` +\n            `is invalid.  Unable to make a substitution.`);\n          endProcessing = true;\n        }\n        // otherwise try for suggestions\n        else {\n          let suggestStat = this._getSuggestions(befText);\n          endProcessing =  (suggestStat !== 'succeeded');\n\n        } // end if a brace was found or, if not, suggestions were not or\n          // were requested\n      } // end if text preceding the parentheses was not a number\n    } // end if there was text before the parentheses\n\n    // Process any text after the parentheses\n    if (aftText) {\n      // if it's an annotation, get it and add it to the pStr\n      if (aftText.indexOf(this.braceFlag_) >= 0) {\n        let annoRet = this._getAnnoText(aftText, origString);\n        // if we found not only an annotation, but text before or after\n        // the annotation (remembering that this is all after the\n        // parentheses) throw an error - because we don't know what\n        // to do with it.  Could it be missing an operator?\n        if (annoRet[1] || annoRet[2]) {\n          throw (new Error(`Text found after the parentheses (` +\n            `${aftText}) included an annotation along with other text ` +\n            `for parenthetical unit ${retUnit.csCode_}`));\n        }\n        // Otherwise put the annotation after the unit string - no message\n        // needed.\n        pStr += annoRet[0];\n      }\n      // Otherwise check to see if it's an exponent.  If so, warn the\n      // user that it's not valid - but try it anyway\n      else {\n\n        if (intUtils_.isNumericString(aftText)) {\n          pStr += aftText;\n          retUnit = retUnit.power(Number(aftText));\n          this.retMsg_.push(`An exponent (${aftText}) following a parenthesis ` +\n            `is invalid as of revision 1.9 of the UCUM Specification.\\n  ` +\n            this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n        }\n        // else the text after the parentheses is neither a number nor\n        // an annotation.  If suggestions were NOT requested, record an\n        // error.\n        else if (!this.suggestions_) {\n          this.retMsg_.push(`Text ${aftText} following the unit code ${pStr} ` +\n            `is invalid.  Unable to make a substitution.`);\n          endProcessing = true;\n        }\n        // otherwise try for suggestions\n        else {\n          let suggestStat = this._getSuggestions(befText);\n          endProcessing =  (suggestStat !== 'succeeded');\n        } // end if text following the parentheses not an exponent\n      } // end if text following the parentheses is not an annotation\n    } // end if there is text following the parentheses\n    if (!endProcessing) {\n      if (!retUnit) {\n        retUnit = new Unit({\n          'csCode_': pStr,\n          'magnitude_': 1,\n          'name_': pStr});\n      }\n      else if (intUtils_.isIntegerUnit(retUnit)) {\n        retUnit = new Unit({'csCode_': retUnit,\n        'magnitude_': retUnit,\n        'name_': retUnit});\n      }\n      else {\n        retUnit.csCode_ = pStr;\n      }\n    }\n    return [retUnit, endProcessing];\n  } // end _getParensUnit\n\n  /**\n   * Takes a unit string containing annotation flags and returns the\n   * annotation they represent.  This also returns any text found before\n   * the annotation and any found after the annotation.\n   *\n   * This should only be called from within this class (or by test code).\n   * NEEDS FIX in next branch to handle string with multiple annotations.\n   *\n   * @param pStr the string being parsed\n   * @param origString the original string being parsed; used in error msg\n   *  thrown for an invalid index to the annotations array\n   * @returns\n   *  an array containing\n   *    the annotation for the pStr;\n   *    any text found before the annotation; and\n   *    any text found after the annotation.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * the this.annotations_ array is used as the source for the annotations text\n   * @throws an error if for a processing error - an invalid annotation index.\n   */\n  _getAnnoText(pStr, origString) {\n\n    // if the starting braces flag is not at index 0, get the starting\n    // text and the adjust the pStr to omit it.\n    let asIdx = pStr.indexOf(this.braceFlag_);\n    let startText = (asIdx > 0) ? pStr.substring(0, asIdx) : null;\n    if (asIdx !== 0) {\n      pStr = pStr.substr(asIdx);\n    }\n\n    // Get the location of the end flag and, if text follows it, get the text\n    let aeIdx = pStr.indexOf(this.braceFlag_, 1);\n    let endText = ((aeIdx + this.bFlagLen_) < pStr.length) ?\n      pStr.substr(aeIdx + this.bFlagLen_) : null;\n\n    // Get the index of the annotation in this.annotations_.\n    // Check it to make sure it's valid, and if not, throw an error\n    let idx = pStr.substring(this.bFlagLen_, aeIdx);\n    let idxNum = Number(idx);\n    if (!intUtils_.isNumericString(idx) || idxNum >= this.annotations_.length) {\n      throw (new Error(`Processing Error - invalid annotation index ${idx} found ` +\n        `in ${pStr} that was created from ${origString}`));\n    }\n\n    // Replace the flags and annotation index with the annotation expression\n    pStr = this.annotations_[idxNum];\n    return [pStr, startText, endText];\n  } // end _getAnnoText\n\n\n  /**\n   * Takes a unit string and looks for suggested units.  This should be\n   * called for unit strings that cannot be resolved to unit codes.  The\n   * string is searched for in the synonyms table found in the UnitTables\n   * class.  That table includes all synonyms and unit names for the units\n   * in the unit data table.\n   *\n   * @param pStr the string being parsed\n   * @returns an object that contains an element named 'status', whose\n   *  value indicates the status of the request:\n   *   'succeeded' indicates that synonyms were found;\n   *   'failed' indicates that no synonyms were found; or\n   *   'error' which indicates that an error occurred\n   *\n   * the this.retMsg_ array will be updated with a message indicating whether\n   *  or not synonyms/suggestions  were found\n   * the this.suggestions_ array will be updated with a hash (added to the\n   *   array if it already contains others) that contains three elements:\n   *   'msg' which is a message indicating what unit expression the\n   *      suggestions are for;\n   *   'invalidUnit' which is the unit expression the suggestions are for; and\n   *   'units' which is an array of data for each suggested unit found.\n   *       Each array will contain the unit code, the unit name and the\n   *       unit guidance (if any).\n   */\n  _getSuggestions(pStr) {\n\n    let retObj = intUtils_.getSynonyms(pStr);\n    if (retObj['status'] === 'succeeded') {\n      let suggSet = {} ;\n      suggSet['msg'] = `${pStr} is not a valid UCUM code.  We found possible ` +\n                       `units that might be what was meant:`;\n      suggSet['invalidUnit'] = pStr ;\n      let synLen = retObj['units'].length ;\n      suggSet['units'] = [] ;\n      for (let s = 0; s < synLen; s++) {\n        let unit = retObj['units'][s];\n        let unitArray = [unit['code'], unit['name'], unit['guidance']];\n\n        suggSet['units'].push(unitArray) ;\n      }\n      this.suggestions_.push(suggSet);\n    }\n    else {\n      this.retMsg_.push(`${pStr} is not a valid UCUM code.  No alternatives ` +\n                  `were found.`);\n    }\n    return retObj['status'] ;\n  } // end getSuggestions\n\n\n  /**\n   * Creates a unit object from a string defining one unit.  The string\n   * should consist of a unit code for a unit already defined (base or\n   * otherwise).  It may include a prefix and an exponent, e.g., cm2\n   * (centimeter squared).  This should only be called from within this\n   * class (or by test code).\n   *\n   * @params uCode the string defining the unit\n   * @param origString the original string to be parsed; used to provide\n   *  context for messages\n   * @returns\n   *  an array containing:\n   *    a unit object, or null if there were problems creating the unit; and\n   *    the origString passed in, which may be updated if a unit name was\n   *    translated to a unit code.\n   *\n   *  the this.retMsg_ array will be updated with any user messages\n   *    (informational, error or warning) generated by this or called methods\n   *  the this.suggestions_ array will be populated if no unit (with or without\n   *    substitutions) could be found and suggestions were requested\n   */\n  _makeUnit(uCode, origString) {\n\n    // First try the code just as is, without looking for annotations,\n    // prefixes, exponents, or elephants.\n    let retUnit = this.utabs_.getUnitByCode(uCode);\n    if (retUnit) {\n      retUnit = retUnit.clone();\n    }\n\n    // If we found it, we're done.  No need to parse for those elephants (or\n    // other stuff).\n    else if (uCode.indexOf(this.braceFlag_) >= 0) {\n      let getAnnoRet = this._getUnitWithAnnotation(uCode, origString);\n      retUnit = getAnnoRet[0];\n      if (retUnit) {\n        origString = getAnnoRet[1];\n      }\n      // If a unit is not found, retUnit will be returned null and\n      // the this.retMsg_ array will contain a message describing the problem.\n      // If a unit is found, of course, all is good. So ... nothing left\n      // to see here, move along.\n    } // end if the uCode includes an annotation\n\n    else {\n\n      // So we didn't find a unit for the full uCode or for one with\n      // annotations.  Try looking for a unit that uses a carat (^)\n      // instead of an asterisk (*)\n\n      if (uCode.indexOf('^') > -1) {\n        let tryCode = uCode.replace('^', '*');\n        retUnit = this.utabs_.getUnitByCode(tryCode);\n        if (retUnit) {\n          retUnit = retUnit.clone();\n          retUnit.csCode_ = retUnit.csCode_.replace('*', '^');\n          retUnit.ciCode_ = retUnit.ciCode_.replace('*', '^');\n        }\n      }\n      // If that didn't work, check to see if it should have brackets\n      // around it (uCode = degF when it should be [degF]\n      if (!retUnit) {\n        let addBrackets = '[' + uCode + ']' ;\n        retUnit = this.utabs_.getUnitByCode(addBrackets);\n        if (retUnit) {\n          retUnit = retUnit.clone();\n          origString = origString.replace(uCode, addBrackets);\n          this.retMsg_.push(`${uCode} is not a valid unit expression, but ` +\n            `${addBrackets} is.\\n` + this.vcMsgStart_ +\n            `${addBrackets} (${retUnit.name_})${this.vcMsgEnd_}`);\n        } // end if we found the unit after adding brackets\n      } // end trying to add brackets\n\n      // If we didn't find it, try it as a name\n      if (!retUnit) {\n        let retUnitAry = this.utabs_.getUnitByName(uCode);\n        if (retUnitAry && retUnitAry.length > 0) {\n          retUnit = retUnitAry[0].clone();\n          let mString = 'The UCUM code for ' + uCode + ' is ' +\n            retUnit.csCode_ + '.\\n' + this.vcMsgStart_ +\n            retUnit.csCode_ + this.vcMsgEnd_;\n          let dupMsg = false;\n          for (let r = 0; r < this.retMsg_.length && !dupMsg; r++)\n            dupMsg = this.retMsg_[r] === mString;\n          if (!dupMsg)\n            this.retMsg_.push(mString);\n          let rStr = new RegExp('(^|[.\\/({])(' + uCode + ')($|[.\\/)}])');\n          let res = origString.match(rStr);\n          origString = origString.replace(rStr, res[1] + retUnit.csCode_ + res[3]);\n          uCode = retUnit.csCode_;\n        }\n      }\n\n      // If we still don't have a unit, try assuming a modifier (prefix and/or\n      // exponent) and look for a unit without the modifier\n      if (!retUnit) {\n\n        // Well, first see if it's one of the special units.  If so,\n        // replace the placeholder text with the actual unit string, keeping\n        // whatever text (probably a prefix) goes with the unit string.\n        let sUnit = null;\n        for (sUnit in Ucum.specUnits_) {\n          if (uCode.indexOf(Ucum.specUnits_[sUnit]) !== -1)\n            uCode = uCode.replace(Ucum.specUnits_[sUnit], sUnit);\n        }\n        retUnit = this.utabs_.getUnitByCode(uCode);\n        if (retUnit)\n          retUnit = retUnit.clone();\n      }\n      if (!retUnit) {\n\n        let origCode = uCode;\n        let origUnit = null;\n        let exp = null;\n        let pfxCode = null;\n        let pfxObj = null;\n        let pfxVal = null;\n        let pfxExp = null;\n\n        // Look first for an exponent.  If we got one, separate it out and\n        // try to get the unit again\n        let codeAndExp = this._isCodeWithExponent(uCode);\n        if (codeAndExp) {\n          uCode = codeAndExp[0];\n          exp = codeAndExp[1];\n          origUnit = this.utabs_.getUnitByCode(uCode);\n        }\n\n\n        // If we still don't have a unit, separate out the prefix, if any,\n        // and try without it.\n        if (!origUnit) {\n          // Try for a single character prefix first.\n          pfxCode = uCode.charAt(0);\n          pfxObj = this.pfxTabs_.getPrefixByCode(pfxCode);\n\n          // if we got a prefix, get its info and remove it from the unit code\n          if (pfxObj) {\n            pfxVal = pfxObj.getValue();\n            pfxExp = pfxObj.getExp();\n            let pCodeLen = pfxCode.length;\n            uCode = uCode.substr(pCodeLen);\n\n            // try again for the unit\n            origUnit = this.utabs_.getUnitByCode(uCode);\n\n            // If we still don't have a unit, see if the prefix could be the\n            // two character \"da\" (deka) prefix.  That's the only prefix with\n            // two characters, and without this check it's interpreted as \"d\"\n            // (deci) and the \"a\" is considered part of the unit code.\n\n            if (!origUnit && pfxCode == 'd' && uCode.substr(0, 1) == 'a') {\n              pfxCode = 'da';\n              pfxObj = this.pfxTabs_.getPrefixByCode(pfxCode);\n              pfxVal = pfxObj.getValue();\n              uCode = uCode.substr(1);\n\n              // try one more time for the unit\n              origUnit = this.utabs_.getUnitByCode(uCode);\n            }\n\n            // Reject the unit we found if it might have another prefix.\n            // Such things are in our tables through the LOINC source_\n            // (ucum.csv) which has guidance and synonyms.  I think it should be\n            // safe to exclude anything whose source is LOINC from having a\n            // prefix.\n            if (origUnit && origUnit.source_ == 'LOINC')\n              origUnit = null;\n          } // end if we found a prefix\n        } // end if we didn't get a unit after removing an exponent\n\n        // If we still haven't found anything, we're done looking.\n        // (We tried with the full unit string, with the unit string\n        // without the exponent, the unit string without a prefix,\n        // common errors, etc. That's all we can try).\n        if (!origUnit) {\n          retUnit = null ;\n          // BUT if the user asked for suggestions, at least look for them\n          if (this.suggestions_) {\n            let suggestStat = this._getSuggestions(origCode);\n          }\n          else {\n            this.retMsg_.push(`${origCode} is not a valid UCUM code.`);\n          }\n        }\n        else {\n          // Otherwise we found a unit object.  Clone it and then apply the\n          // prefix and exponent, if any, to it.  And remove the guidance.\n          retUnit = origUnit.clone();\n          // If we are here, this is only part of the full unit string, so it is\n          // not a base unit, and the synonyms will mostly likely not be correct for the full\n          // string.\n          retUnit.resetFieldsForDerivedUnit();\n          let theDim = retUnit.getProperty('dim_');\n          let theMag = retUnit.getProperty('magnitude_');\n          let theName = retUnit.getProperty('name_');\n          let theCiCode = retUnit.getProperty('ciCode_');\n          let thePrintSymbol = retUnit.getProperty('printSymbol_');\n          // If there is an exponent for the unit, apply it to the dimension\n          // and magnitude now\n          if (exp) {\n            exp = parseInt(exp);\n            let expMul = exp;\n            if (theDim)\n              theDim = theDim.mul(exp);\n            theMag = Math.pow(theMag, exp);\n            retUnit.assignVals({'magnitude_': theMag});\n\n            // If there is also a prefix, apply the exponent to the prefix.\n            if (pfxObj) {\n\n              // if the prefix base is 10 it will have an exponent.  Multiply\n              // the current prefix exponent by the exponent for the unit\n              // we're working with.  Then raise the prefix value to the level\n              // defined by the exponent.\n              if (pfxExp) {\n                expMul *= pfxObj.getExp();\n                pfxVal = Math.pow(10, expMul);\n              }\n              // If the prefix base is not 10, it won't have an exponent.\n              // At the moment I don't see any units using the prefixes\n              // that aren't base 10.   But if we get one the prefix value\n              // will be applied to the magnitude (below) if the unit does\n              // not have a conversion function, and to the conversion prefix\n              // if it does.\n            } // end if there's a prefix as well as the exponent\n          } // end if there's an exponent\n\n          // Now apply the prefix, if there is one, to the conversion\n          // prefix or the magnitude\n          if (pfxObj) {\n            if (retUnit.cnv_) {\n              retUnit.assignVals({'cnvPfx_': pfxVal});\n            }\n            else {\n              theMag *= pfxVal;\n              retUnit.assignVals({'magnitude_': theMag})\n            }\n          }\n          // if we have a prefix and/or an exponent, add them to the unit\n          // attributes - name, csCode, ciCode and print symbol\n          let theCode = retUnit.csCode_;\n          if (pfxObj) {\n            theName = pfxObj.getName() + theName;\n            theCode = pfxCode + theCode;\n            theCiCode = pfxObj.getCiCode() + theCiCode;\n            thePrintSymbol = pfxObj.getPrintSymbol() + thePrintSymbol;\n            retUnit.assignVals({\n              'name_': theName,\n              'csCode_': theCode,\n              'ciCode_': theCiCode,\n              'printSymbol_': thePrintSymbol\n            });\n          }\n          if (exp) {\n            let expStr = exp.toString();\n            retUnit.assignVals({\n              'name_': theName + '<sup>' + expStr + '</sup>',\n              'csCode_': theCode + expStr,\n              'ciCode_': theCiCode + expStr,\n              'printSymbol_': thePrintSymbol + '<sup>' + expStr + '</sup>'\n            });\n          }\n        } // end if an original unit was found (without prefix and/or exponent)\n\n      } // end if we didn't get a unit for the full unit code (w/out modifiers)\n    } // end if we didn't find the unit on the first try, before parsing\n    return [retUnit, origString];\n  } // end _makeUnit\n\n\n  /**\n   * This method handles unit creation when an annotation is included\n   * in the unit string.  This basically isolates and retrieves the\n   * annotation and then calls _makeUnit to try to get a unit from\n   * any text that precedes or follows the annotation.\n   *\n   * @param uCode the string defining the unit\n   * @param origString the original full string submitted to parseString\n   * @returns the unit object found, or null if one could not be found\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   */\n  _getUnitWithAnnotation(uCode, origString) {\n\n    let retUnit = null;\n\n    // Get the annotation and anything that precedes or follows it.\n    let annoRet = this._getAnnoText(uCode, origString);\n    let annoText = annoRet[0];\n    let befAnnoText = annoRet[1];\n    let aftAnnoText = annoRet[2];\n\n    // Add the warning about annotations - just once.\n\n    if (this.bracesMsg_ && this.retMsg_.indexOf(this.bracesMsg_) === -1)\n      this.retMsg_.push(this.bracesMsg_);\n\n    // If there's no text before or after the annotation, it's probably\n    // something that should be interpreted as a 1, e.g., {KCT'U}.\n    // HOWEVER, it could also be a case where someone used braces instead\n    // of brackets, e.g., {degF} instead of [degF].  Check for that before\n    // we assume it should be a 1.\n    let msgLen = this.retMsg_.length;\n    if (!befAnnoText && !aftAnnoText) {\n      let tryBrackets = '[' + annoText.substring(1, annoText.length - 1) + ']';\n      let mkUnitRet = this._makeUnit(tryBrackets, origString);\n\n      // Nearly anything inside braces is valid, so we don't want to change the\n      // unit, but we can put the found unit in the message as a sort of\n      // warning.\n      if (mkUnitRet[0]) {\n        retUnit = uCode;\n        this.retMsg_.push(`${annoText} is a valid unit expression, but ` +\n          `did you mean ${tryBrackets} (${mkUnitRet[0].name_})?`);\n      }\n      else {\n        // remove error message generated for trybrackets\n        if (this.retMsg_.length > msgLen) {\n          this.retMsg_.pop();\n        }\n      }\n\n      // This is the case where the string is only this annotation.\n      // Create and return a unit object, as we do for numeric units in\n      // parseString.\n      retUnit = new Unit({\n        'csCode_': annoText,\n        'ciCode_': annoText,\n        'magnitude_': 1,\n        'name_': annoText\n      });\n\n    } // end if it's only an annotation\n\n    else {\n      // if there's text before and no text after, assume the text before\n      // the annotation is the unit code (with an annotation following it).\n      // Call _makeUnit for the text before the annotation.\n      if (befAnnoText && !aftAnnoText) {\n        // make sure that what's before the annoText is not a number, e.g.,\n        // /100{cells}.  But f it is a number, just set the return unit to\n        // the number.\n        if (intUtils_.isIntegerUnit(befAnnoText)) {\n          retUnit = befAnnoText ;\n        }\n        // Otherwise try to find a unit\n        else {\n          let mkUnitRet = this._makeUnit(befAnnoText, origString);\n\n          // if a unit was returned\n          if (mkUnitRet[0]) {\n            retUnit = mkUnitRet[0];\n            retUnit.csCode_ += annoText;\n            origString = mkUnitRet[1];\n          }\n          // Otherwise add a not found message\n          else {\n            this.retMsg_.push(`Unable to find a unit for ${befAnnoText} that ` +\n              `precedes the annotation ${annoText}.`);\n          }\n        }\n      }\n      // else if there's only text after the annotation, try for a unit\n      // from the after text and assume the user put the annotation in\n      // the wrong place (and tell them)\n      else if (!befAnnoText && aftAnnoText) {\n\n        // Again, test for a number and if it is a number, set the return\n        // unit to the number.\n        if (intUtils_.isIntegerUnit(aftAnnoText)) {\n          retUnit = aftAnnoText + annoText ;\n          this.retMsg_.push(`The annotation ${annoText} before the `\n            `${aftAnnoText} is invalid.\\n` + this.vcMsgStart_ + retUnit +\n            this.vcMsgEnd_);\n        }\n        else {\n          let mkUnitRet = this._makeUnit(aftAnnoText, origString);\n          if (mkUnitRet[0]) {\n            retUnit = mkUnitRet[0];\n            retUnit.csCode_ += annoText;\n            origString = retUnit.csCode_;\n            this.retMsg_.push(`The annotation ${annoText} before the unit ` +\n              `code is invalid.\\n` + this.vcMsgStart_ + retUnit.csCode_ +\n              this.vcMsgEnd_);\n          }\n          // Otherwise add a not found message\n          else {\n            this.retMsg_.push(`Unable to find a unit for ${befAnnoText} that ` +\n              `follows the annotation ${annoText}.`);\n          }\n        }\n      }\n      // else it's got text before AND after the annotation.  Now what?\n      // For now this is an error.  This may be a case of a missing\n      // operator but that is not handled yet.\n      else {\n        this.retMsg_.push(`Unable to find a unit for ${befAnnoText}${annoText}` +\n          `${aftAnnoText}.\\nWe are not sure how to interpret text both before ` +\n          `and after the annotation.  Sorry`);\n      }\n    } // else if there's text before/and or after the annotation\n\n    return [retUnit , origString];\n\n  } // end _getUnitWithAnnotations\n\n\n  /**\n   * Performs unit arithmetic for the units in the units array.  That array\n   * contains units/numbers and the operators (division or multiplication) to\n   * be performed on each unit/unit or unit/number pair in the array.  This\n   * should only be called from within this class (or by test code).\n   *\n   * @params uArray the array that contains the units, numbers and operators\n   *  derived from the unit string passed in to parseString\n   * @param origString the original string to be parsed; used to provide\n   *  context for messages\n   *\n   * @returns a single unit object that is the result of the unit arithmetic\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   */\n  _performUnitArithmetic(uArray, origString) {\n\n    let finalUnit = uArray[0]['un'];\n    if (intUtils_.isIntegerUnit(finalUnit)) {\n      finalUnit = new Unit({'csCode_' : finalUnit, 'ciCode_' : finalUnit,\n        'magnitude_' : Number(finalUnit),\n        'name_' : finalUnit}) ;\n    }\n    let uLen = uArray.length ;\n    let endProcessing = false ;\n    // Perform the arithmetic for the units, starting with the first 2 units.\n    // We only need to do the arithmetic if we have more than one unit.\n    for (let u2 = 1; (u2 < uLen) && !endProcessing; u2++) {\n      let nextUnit = uArray[u2]['un'];\n      if (intUtils_.isIntegerUnit(nextUnit)) {\n        nextUnit = new Unit({'csCode_' : nextUnit, 'ciCode_' : nextUnit,\n          'magnitude_' : Number(nextUnit),\n          'name_': nextUnit});\n      }\n      if (nextUnit === null ||\n          ((typeof nextUnit !== 'number') && (!nextUnit.getProperty))) {\n        let msgString = `Unit string (${origString}) contains unrecognized ` +\n                        'element' ;\n        if (nextUnit) {\n          msgString += ` (${this.openEmph_}${nextUnit.toString()}` +\n                       `${this.closeEmph_})`;\n        }\n        msgString += '; could not parse full string.  Sorry';\n        this.retMsg_.push(msgString);\n        endProcessing = true;\n      }\n      else {\n        try {\n          // Is the operation division?\n          let thisOp = uArray[u2]['op'];\n          let isDiv = thisOp === '/';\n\n          // Perform the operation.  Both the finalUnit and nextUnit\n          // are unit objects.\n          isDiv ? finalUnit = finalUnit.divide(nextUnit) :\n                  finalUnit = finalUnit.multiplyThese(nextUnit);\n        }\n        catch (err) {\n          this.retMsg_.unshift(err.message) ;\n          endProcessing = true ;\n          finalUnit = null ;\n        }\n      } // end if we have another valid unit/number to process\n    } // end do for each unit after the first one\n    return finalUnit ;\n  }  // end _performUnitArithmetic\n\n\n  /**\n   * This tests a string to see if it starts with characters and ends with\n   * digits.  This is used to test for an exponent on a UCUM code (or what\n   * we think might be a UCUM code).  This is broken out to a separate\n   * function so that the regular expression can be verified to provide the\n   * results we expect, in case someone changes it.  (Per Paul Lynch)\n   * See \"Test _isCodeWithExponent method\" in testUnitString.spec.js\n   *\n   * This particular regex has been tweaked several times.  This one\n   * works with the following test strings:\n   * \"m[H2O]-21 gives [\"m[H2O]-21\", \"m[H2O]\", \"-21\"]\n   * \"m[H2O]+21 gives [\"m[H2O]+21\", \"m[H2O]\", \"+21\"]\n   * \"m[H2O]21 gives [\"m[H2O]-21\", \"m[H2O]\", \"21\"]\n   * \"s2\" gives [\"s2\", \"s, \"2\"]\n   * \"kg\" gives null\n   * \"m[H2O]\" gives null\n   * \"m[H2O]23X\" gives null\n   *\n   * @params uCode the code being tested\n   * @returns an array containing: (1) the code without the exponent (or\n   *  trailing number); and (2) the exponent/trailing number.  Returns null\n   *  if there is no trailing number or something follows the trailing\n   *  number, or if the first part is not characters.\n   */\n  _isCodeWithExponent(uCode) {\n\n    let ret = [] ;\n    let res = uCode.match(/(^[^\\-\\+]+?)([\\-\\+\\d]+)$/);\n\n    // If we got a return with an exponent, separate the exponent from the\n    // unit and return both (as separate values)\n    if (res && res[2] && res[2] !== \"\") {\n      ret.push(res[1]);\n      ret.push(res[2]);\n    } // end if we got an exponent\n    else {\n      ret = null ;\n    }\n    return ret ;\n  } // end _isCodeWithExponent\n\n} // end class UnitString\n\n\n/**\n *  This function exists ONLY until the original UnitString constructor\n *  is called for the first time.  It's defined here in case getInstance\n *  is called before the constructor.   This calls the constructor.\n *\n *  The constructor redefines the getInstance function to return the\n *  singleton UnitString object.  This is based on the UnitTables singleton\n *  implementation; see more detail in the UnitTables constructor description.\n *\n *  @return the singleton UnitString object.\n */\nUnitString.getInstance = function(){\n  return new UnitString();\n} ;\n\n/*\n// Perform the first request for the object, to set the getInstance method.\nUnitString.getInstance();\n\n*/\n","/**\n * This class manages Hashtables that provide references to\n * defined units.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\n\nvar Ucum = require('./config.js').Ucum;\n\nclass UnitTablesFactory {\n\n  /**\n   * Constructor.  This creates the empty unit tables (hashes) once. After the\n   * tables are created, it redefines this constructor to throw an error\n   * stating that the constructor is no longer available and that the\n   * getInstance function must be used.   Here's a description of the first\n   * and then all subsequent calls to this constructor.\n   *\n   * First call to constructor:\n   * 1. creates  OBJECT1\n   * 2. initializes attributes of OBJECT1\n   * 3. stores reference to OBJECT1.prototype in holdthis local variable\n   * 4. redefines OBJECT1 as a function that throws an error\n   * 5. defines the getInstance function (which is also defined outside of\n   *    the class definition - see below).\n   *\n   * All subsequent calls to constructor:\n   * 1. throw error message referring to getInstance\n   * 2. call getInstance, returns this - which is OBJECT1.\n   */\n  constructor() {\n\n    /**\n     * Tracks units by name\n     * @type hash - key is the name;\n     *              value is an array of references to the Unit objects\n     *              with the name.  More than one unit may have the same\n     *              name, e.g., \"second\", which is shared by the base unit\n     *              with the code = \"s\" and the unit with code = \"'\".\n     */\n    this.unitNames_ = {};\n\n    /**\n     * Tracks units by code using case-sensitive version.\n     *\n     * @type hash - key is the code;\n     *              value is the reference to the Unit object.  Codes must\n     *              be unique.\n     */\n    this.unitCodes_ = {};\n\n    /**\n     * Keeps track of the order in which units are defined.  The order is\n     * important because unit definitions build on previous definitions.\n     *\n     * @type {Array}\n     */\n    this.codeOrder_ = [] ;\n\n    /**\n     * Tracks units by unit strings, e.g., cm-1\n     *\n     * @type hash - key is the unit string\n     *              value is an array of unit objects with that ciUnitString.\n     */\n    this.unitStrings_ = {};\n\n    /**\n     * Tracks units by Dimension vector\n     *\n     * @type hash - key is the dimension vector (not the object, just the\n     *              vector);\n     *              value is an array of references to the Unit objects\n     *              with that vector.  More than one unit may have the same\n     *              unit vector, and this can be used to provide a list\n     *              of commensurable units.\n     */\n    this.unitDimensions_ = {};\n\n    /**\n     * Maps synonyms to units.   Not built until first requested.\n     *\n     * @type hash - key is the synonym\n     *              value is an array of references to Unit objects that\n     *              include that synonym.\n     */\n     this.unitSynonyms_ = {};\n\n    /*\n     * Holds onto the index of the index of the dimension vector flag for\n     * the base mass unit (gram).  This is set when the base unit (gram) is\n     * created, and is stored here so that it doesn't have to be found\n     * over and over again to try to determine whether or not a unit is\n     * mass-based (for mole<->mass conversions)\n     *\n     * @type integer\n     */\n    this.massDimIndex_ = 0;\n\n    /**\n     *  Map of indices in the dimension vector to base unit symbols.\n     */\n    this.dimVecIndexToBaseUnit_ = {};\n  }\n\n\n  /**\n   * Provides the number of unit objects written to the tables, using the\n   * codes table since codes must be unique.\n   *\n   * @returns count of the number of unit objects in the unitCodes_ table.\n   */\n  unitsCount() {\n    return Object.keys(this.unitCodes_).length ;\n  }\n\n\n  /**\n   * Adds a Unit object to the tables.\n   *\n   * @param theUnit the unit to be added\n   * @returns nothing\n   * @throws passes on an error if one is thrown by the called functions for\n   *  a problem with the unit code or unit name\n   */\n  addUnit(theUnit) {\n\n    let uName = theUnit['name_'] ;\n    if (uName) {\n      this.addUnitName(theUnit);\n    }\n\n    this.addUnitCode(theUnit);\n    this.addUnitString(theUnit);\n\n    try {\n      if (theUnit['dim_'].getProperty('dimVec_'))\n        this.addUnitDimension(theUnit);\n    }\n    catch(err){\n      // do nothing - throws error if the property is null\n      // and that's OK here.\n    }\n\n    if (theUnit.isBase_) {\n      const dimVec = theUnit.dim_.dimVec_;\n      let nonZeroIndex;\n      for (let i=0, len=dimVec.length; nonZeroIndex==undefined && i<len; ++i) {\n        if (dimVec[i] != 0)\n          nonZeroIndex = i;\n      }\n      this.dimVecIndexToBaseUnit_[nonZeroIndex] = theUnit.csCode_;\n    }\n  } // end addUnit\n\n\n  /**\n   * Adds a Unit object to the unitNames_ table.  More than one unit\n   * can have the same name, e.g., the two units with the name \"second\",\n   * where the code for one of them is 's' and the code for the other is\n   * \"'\".  Because of this, an array of unit objects is stored for the\n   * name.  In most cases it will be an array of one object, but this\n   * clarifies that there may be more than one.\n   *\n   * @param theUnit the unit to be added\n   * @returns nothing\n   * @throws an error if the unit has no name\n   */\n  addUnitName(theUnit) {\n\n    let uName = theUnit['name_'];\n\n    if (uName) {\n      if (this.unitNames_[uName])\n        this.unitNames_[uName].push(theUnit);\n      else\n        this.unitNames_[uName] = [theUnit];\n    }\n    else\n      throw(new Error('UnitTables.addUnitName called for a unit with no name.  ' +\n            `Unit code = ${theUnit['csCode_']}.`));\n\n  } // end addUnitName\n\n\n  /**\n   * Adds a Unit object to the unitCodes_, unitUcCodes_, unitLcCodes_ and\n   * codeOrder_ tables.  This also sets the mass dimension index when the\n   * base mass unit (gram) is read.\n   *\n   * @param theUnit the unit to be added\n   * @returns nothing\n   * @throws an error if the unitCodes_ table already contains a unit with\n   *  the code\n   */\n  addUnitCode(theUnit) {\n\n    let uCode = theUnit['csCode_'];\n    if (uCode) {\n\n      if (this.unitCodes_[uCode])\n        throw(new Error(`UnitTables.addUnitCode called, already contains entry for ` +\n              `unit with code = ${uCode}`));\n      else {\n        this.unitCodes_[uCode] = theUnit;\n        this.codeOrder_.push(uCode);\n        if (uCode == 'g') {\n          let dimVec = theUnit.dim_.dimVec_;\n          let d = 0;\n          for (; d < dimVec.length && dimVec[d] < 1; d++) ;\n          this.massDimIndex_ = d;\n        }\n      }\n    }\n    else\n      throw(new Error('UnitTables.addUnitCode called for unit that has ' +\n                      'no code.')) ;\n\n  } // end addUnitCode\n\n\n  /**\n   * Adds a unit object to the unitStrings_ table.  More than one unit\n   * can have the same string, so an array of unit objects is stored\n   * for the string.  The unit string is the string that creates a non-base\n   * unit, e.g., a Newton has a unit code of N, a name of Newton, and a\n   * unitString of kg.m/s2.\n   *\n   * If the unit has no string, nothing is stored and no error is reported.\n   *\n   * @param theUnit the unit to be added\n   * @returns nothing\n   */\n  addUnitString(theUnit) {\n\n    let uString = null;\n    if (Ucum.caseSensitive_ == true)\n      uString = theUnit['csUnitString_'];\n    else\n      uString = theUnit['ciUnitString_'];\n\n    if (uString) {\n      let uEntry = {mag: theUnit['baseFactorStr_'], unit: theUnit};\n      if (this.unitStrings_[uString])\n        this.unitStrings_[uString].push(uEntry);\n      else\n        this.unitStrings_[uString] = [uEntry];\n    }\n  } // end addUnitString\n\n\n  /**\n   * Adds a Unit object to the unitDimensions_ table.  More than one unit\n   * can have the same dimension (commensurable units have the same dimension).\n   * Because of this, an array of unit objects is stored for the\n   * dimension.\n   *\n   * @param theUnit the unit to be added\n   * @returns nothing\n   * @throws an error if the unit has no dimension\n   */\n  addUnitDimension(theUnit) {\n\n    let uDim = theUnit['dim_'].getProperty('dimVec_');\n\n    if (uDim) {\n      if (this.unitDimensions_[uDim])\n        this.unitDimensions_[uDim].push(theUnit);\n      else\n        this.unitDimensions_[uDim] = [theUnit];\n    }\n    else\n      throw(new Error('UnitTables.addUnitDimension called for a unit with no dimension.  ' +\n          `Unit code = ${theUnit['csCode_']}.`));\n\n  } // end addUnitDimension\n\n\n  /**\n   * Builds the unitSynonyms_ table. This is called the first time the\n   * getUnitsBySynonym method is called.  The table/hash contains each word\n   * (once) from each synonym as well as each word from each unit name.\n   *\n   * Hash keys are the words.  Hash values are an array of unit codes for\n   * each unit that has that word in its synonyms or name.\n   *\n   * @returns nothing\n   */\n  buildUnitSynonyms() {\n\n    for (let code in this.unitCodes_) {\n      let theUnit = this.unitCodes_[code];\n      let uSyns = theUnit.synonyms_ ;\n\n      // If the current unit has synonyms, process each synonym (often multiples)\n      if (uSyns) {\n        let synsAry = uSyns.split(';');\n        if (synsAry[0] !== '') {\n          let aLen = synsAry.length;\n          for (let a = 0; a < aLen; a++) {\n            let theSyn = synsAry[a].trim();\n\n            // call addSynonymCodes to process each word in the\n            // synonym, e.g., \"British fluid ounces\"\n            this.addSynonymCodes(code, theSyn) ;\n          } // end do for each synonym\n        } // end if the current unit has a non-null synonym attribute\n      } // end if the unit has any synonyms\n\n      // Now call addSynonymCodes to process each word in the unit's name\n      this.addSynonymCodes(code, theUnit.name_) ;\n    } // end do for each unit\n   } // end buildUnitSynonyms\n\n\n  /**\n   * Adds unit code entries to the synonyms table for a string containing\n   * one or more words to be considered as synonyms.\n   *\n   * @param theCode the unit code to be connected to the synonyms\n   * @param theSynonyms a string containing one or more words to be\n   *  considered synonyms (and thus to be added to the unitSynonyms hash).\n   */\n  addSynonymCodes(theCode, theSynonyms) {\n\n    let words = theSynonyms.split(' ');\n    let wLen = words.length;\n\n    for (let w = 0; w < wLen; w++) {\n      let word = words[w];\n\n      // if there is already a synonyms entry for the word,\n      // get the array of unit codes currently assigned to\n      // the word and add the code for the current word to\n      // the synonyms array if it's not already there.\n      if (this.unitSynonyms_[word]) {\n        let synCodes = this.unitSynonyms_[word];\n        if (synCodes.indexOf(theCode) === -1) {\n          this.unitSynonyms_[word].push(theCode);\n        }\n      }\n      // else there are no synonyms entry for the word.  Create a\n      // synonyms array for the word, setting it to contain the unit code.\n      else {\n        this.unitSynonyms_[word] = [theCode];\n      }\n    } // end do for each word in the synonyms being processed\n\n  } // end addSynonymCodes\n\n\n  /**\n   *  Returns a unit object with a case-sensitive code matching the\n   *  uCode parameter, or null if no unit is found with that code.\n   *\n   *  @param uCode the code of the unit to be returned\n   *  @returns the unit object or null if it is not found\n   */\n  getUnitByCode(uCode) {\n    let retUnit = null ;\n    if (uCode) {\n      retUnit = this.unitCodes_[uCode];\n    }\n    return retUnit ;\n  }\n\n\n  /**\n   *  Returns a array of unit objects based on the unit's name.  Usually this\n   *  will be an array of one, but there may be more, since unit names are\n   *  not necessarily unique.\n   *\n   *  @param uName the name of the unit to be returned.  If more than one\n   *  unit has the same name and you only want one specific unit, append the\n   *  csCode of the unit you want to the end of the name, separated by the\n   *  Ucum.codeSep_ value, e.g., inch - [in_i] vs. inch - [in_us].\n   *  @returns null if no unit was found for the specified name OR an array of\n   *  unit objects with the specified name.  Normally this will be an array\n   *  of one object.\n   *  @throws an error if no name is provided to search on\n   */\n  getUnitByName(uName) {\n\n    if (uName === null || uName === undefined) {\n      throw (new Error('Unable to find unit by name because no name was provided.'));\n    }\n    let sepPos = uName.indexOf(Ucum.codeSep_);\n    let uCode = null;\n    if (sepPos >= 1) {\n      uCode = uName.substr(sepPos + Ucum.codeSep_.length);\n      uName = uName.substr(0, sepPos);\n    }\n    let retUnits = this.unitNames_[uName] ;\n    if (retUnits) {\n      let uLen = retUnits.length ;\n\n      if (uCode && uLen > 1) {\n        let i = 0;\n        for (; retUnits[i].csCode_ !== uCode && i < uLen; i++);\n        if (i < uLen)\n          retUnits = [retUnits[i]];\n        else {\n          retUnits = null;\n        }\n      } // end if we need to find both a name and a code\n    } // end if we got an array of units\n    return retUnits ;\n\n  } // end getUnitByName\n\n\n  /**\n   *  Returns an array of unit objects with the specified unit string.\n   *  The array may contain one or more unit reference objects.\n   *  Or none, if no units have a matching unit string (which is not\n   *  considered an error)\n   *\n   *  @param name the name of the unit to be returned\n   *  @returns the array of unit references or null if none were found\n   */\n  getUnitByString(uString) {\n    let retAry = null ;\n    if (uString) {\n      retAry = this.unitStrings_[uString] ;\n      if (retAry === undefined)\n        retAry = null;\n    }\n    return retAry ;\n  }\n\n\n  /**\n   *  Returns a array of unit objects based on the unit's dimension vector.\n   *\n   *  @param uName the dimension vector of the units to be returned.\n   *\n   *  @returns null if no unit was found for the specified vector OR an array of\n   *  one or more unit objects with the specified vector.\n   *  @throws an error if no vector is provided to search on\n   *  logs an error to the console if no unit is found\n   */\n  getUnitsByDimension(uDim) {\n\n    let unitsArray = null ;\n    if (uDim === null || uDim === undefined) {\n      throw (new Error('Unable to find unit by because no dimension ' +\n                       'vector was provided.'));\n    }\n\n    unitsArray = this.unitDimensions_[uDim] ;\n    if (unitsArray === undefined || unitsArray === null) {\n      console.log(`Unable to find unit with dimension = ${uDim}`);\n    }\n\n    return unitsArray ;\n\n  } // end getUnitsByDimension\n\n\n  /**\n   *  Returns a array of unit objects that include the specified synonym.\n   *\n   *  @param uSyn the synonym of the units to be returned.\n   *\n   *  @returns an object with two of the following three elements:\n   *   'status' will be error, failed or succeeded\n   *   'msg' will be included for returns with status = error or failed and\n   *     will explain why the request did not return any units\n   *   'units' any array of unit objects with the specified synonym will be\n   *     returned for requests with status = succeeded\n   */\n  getUnitBySynonym(uSyn) {\n\n    let retObj = {} ;\n    let unitsArray = [];\n\n    try {\n      if (uSyn === null || uSyn === undefined) {\n        retObj['status'] = 'error' ;\n        throw (new Error('Unable to find unit by synonym because no synonym ' +\n            'was provided.'));\n      }\n      // If this is the first request for a unit by synonym, build the hash map\n      if (Object.keys(this.unitSynonyms_).length === 0) {\n        this.buildUnitSynonyms();\n      }\n      let foundCodes = [];\n      foundCodes = this.unitSynonyms_[uSyn];\n      if (foundCodes) {\n        retObj['status'] = 'succeeded';\n        let fLen = foundCodes.length;\n        for (let f = 0; f < fLen; f++) {\n          unitsArray.push(this.unitCodes_[foundCodes[f]]);\n        }\n        retObj['units'] = unitsArray ;\n      }\n      if (unitsArray.length === 0) {\n        retObj['status'] = 'failed' ;\n        retObj['msg'] = `Unable to find any units with synonym = ${uSyn}`;\n      }\n    }\n    catch(err) {\n      retObj['msg'] = err.message ;\n    }\n    return retObj ;\n  } // end getUnitBySynonym\n\n\n  /**\n   * Gets a list of all unit names in the Unit tables\n   *\n   * @returns an array of the unit names\n   */\n  getAllUnitNames() {\n    return Object.keys(this.unitNames_);\n  } // end getAllUnitNames\n\n\n  /**\n   * Gets a list of all unit names in the tables.  Where more than one\n   * unit has the same name, the unit code, in parentheses, is appended\n   * to the end of the name.\n   *\n   * @returns {Array}\n   */\n  getUnitNamesList() {\n    let nameList = [];\n    let codes = Object.keys(this.unitCodes_);\n    codes.sort(this.compareCodes) ;\n    let uLen = codes.length;\n    for (let i = 0; i < uLen; i++) {\n      nameList[i] = codes[i] + Ucum.codeSep_ + this.unitCodes_[codes[i]].name_\n    } // end do for each code\n    return nameList ;\n  }\n\n\n  /*\n   * Returns the mass dimension index\n   * @returns this.massDimIndex_\n   */\n  getMassDimensionIndex() {\n    return this.massDimIndex_ ;\n  }\n\n  /**\n   * This provides a sort function for unit codes so that sorting ignores\n   * square brackets and case.\n   *\n   * @param a first value\n   * @param b second value\n   * @returns -1 if a is should fall before b; otherwise 1.\n   */\n  compareCodes(a, b) {\n    a = a.replace(/[\\[\\]]/g, '');\n    a = a.toLowerCase();\n    b = b.replace(/[\\[\\]]/g, '');\n    b = b.toLowerCase();\n    return (a < b) ? -1 : 1 ;\n  }\n\n\n  /**\n   * Gets a list of all unit codes in the Unit tables\n   *\n   * @returns an array of the unit names\n   */\n  getAllUnitCodes() {\n    return Object.keys(this.unitCodes_);\n  } // end getAllUnitNames\n\n\n  /**\n   * This is used to get all unit objects.  Currently it is used\n   * to get the objects to write to the json ucum definitions file\n   * that is used to provide prefix and unit definition objects for\n   * conversions and validations.\n   *\n   * @returns an array containing all unit objects, ordered by definition\n   * order\n   */\n  allUnitsByDef() {\n\n    let unitsList = [];\n    let uLen = this.codeOrder_.length ;\n    for (let u = 0; u < uLen; u++) {\n      unitsList.push(this.getUnitByCode(this.codeOrder_[u]));\n    }\n    return unitsList ;\n  } // end allUnitsByDef\n\n\n  /**\n   * This is used to get all unit objects, ordered by unit name.  Currently it\n   * is used to create a csv list of all units.\n   * @param sep separator character (or string) to be used to separate each\n   *  column in the output.  Optional, defaults to '|' if not specified.\n   *  (Used to use ; but the synonyms use that extensively).  Don't use a\n   *  comma or any other punctuation found in the output data.\n   * @returns a buffer containing all unit objects, ordered by name\n   * order\n   */\n  allUnitsByName(cols, sep) {\n    if (sep === undefined || sep === null)\n      sep = '|';\n    let unitBuff = '';\n    let unitsList = this.getAllUnitNames();\n    let uLen = unitsList.length;\n    let cLen = cols.length;\n    for (let i = 0; i < uLen; i++) {\n      let nameRecs = this.getUnitByName(unitsList[i]);\n      for (let u = 0; u < nameRecs.length; u++) {\n        let rec = nameRecs[u];\n        for (let c = 0; c < cLen; c++) {\n          if (c > 0)\n            unitBuff += sep;\n          if (cols[c] === 'dim_') {\n            if (rec.dim_ !== null && rec.dim_ !== undefined &&\n                rec.dim_.dimVec_ instanceof Array)\n              unitBuff += '[' + rec.dim_.dimVec_.join(',') + ']';\n            else\n              unitBuff += '';\n          }\n          else {\n            let cbuf = rec[cols[c]];\n            if (typeof cbuf === 'string')\n              unitBuff += cbuf.replace(/[\\n\\r]/g, ' ');\n            else\n              unitBuff += cbuf ;\n          }\n        } // end do for each column requested\n        unitBuff += '\\r\\n';\n      } // end do for each unit in the unit names array\n    }\n    return unitBuff ;\n  } // end allUnitsByName\n\n\n  /**\n   * This creates a list of all units in the tables.  It uses the byCode\n   * table, and uses the codeOrder_ array to determine the order in which\n   * the units are listed.\n   *\n   * @param doLong boolean indicating how much to output.  If true, all data\n   *  from the unit objects is included.   If false, only a few major values\n   *  are included.\n   * @param sep separator character (or string) to be used to separate each\n   *  column in the output.  Optional, defaults to '|' if not specified.\n   *  (Used to use ; but the synonyms use that extensively).\n   * @returns {string} buffer containing all the listings\n   */\n  printUnits(doLong, sep) {\n    if (doLong === undefined)\n      doLong = false ;\n    if (sep === undefined)\n      sep = '|';\n    let codeList = '';\n    let uLen = this.codeOrder_.length ;\n    let unitString = 'csCode' + sep  ;\n    if (doLong) {\n      unitString += 'ciCode' + sep ;\n    }\n    unitString += 'name' + sep ;\n    if (doLong)\n      unitString += 'isBase' + sep ;\n    unitString += 'magnitude' + sep + 'dimension' + sep + 'from unit(s)' + sep +\n                  'value' + sep + 'function' + sep ;\n    if (doLong)\n      unitString += 'property' + sep + 'printSymbol' + sep + 'synonyms' + sep +\n                    'source' + sep + 'class' + sep + 'isMetric' + sep +\n                    'variable' + sep + 'isSpecial' + sep + 'isAbitrary' + sep ;\n    unitString += 'comment';\n    codeList = unitString + '\\n' ;\n\n    for (let u = 0; u < uLen; u++) {\n      let curUnit = this.getUnitByCode(this.codeOrder_[u]);\n      unitString = this.codeOrder_[u] + sep ;\n      if (doLong) {\n        unitString += curUnit.getProperty('ciCode_') + sep ;\n      }\n      unitString += curUnit.getProperty('name_') + sep ;\n      if (doLong) {\n        if (curUnit.getProperty('isBase_'))\n          unitString += 'true' + sep ;\n        else\n          unitString += 'false' + sep ;\n      }\n      unitString += curUnit.getProperty('magnitude_')  + sep;\n      let curDim = curUnit.getProperty('dim_');\n      if (curDim) {\n        unitString += curDim.dimVec_ + sep ;\n      }\n      else {\n        unitString += 'null' + sep;\n      }\n      if (curUnit.csUnitString_)\n        unitString += curUnit.csUnitString_ + sep + curUnit.baseFactor_ + sep ;\n      else\n        unitString += 'null' + sep + 'null' + sep;\n\n      if (curUnit.cnv_)\n        unitString += curUnit.cnv_ + sep ;\n      else\n        unitString += 'null' + sep ;\n\n      if (doLong) {\n        unitString += curUnit.getProperty('property_') + sep +\n                      curUnit.getProperty('printSymbol_') + sep +\n                      curUnit.getProperty('synonyms_') + sep +\n                      curUnit.getProperty('source_') + sep +\n                      curUnit.getProperty('class_') + sep +\n                      curUnit.getProperty('isMetric_') + sep +\n                      curUnit.getProperty('variable_') + sep +\n                      curUnit.getProperty('isSpecial_') + sep +\n                      curUnit.getProperty('isArbitrary_') + sep ;\n      }\n      if (curUnit.defError_)\n        unitString += 'problem parsing this one, deferred to later.' ;\n      codeList += unitString + '\\n' ;\n    }\n    return codeList ;\n  }\n\n} // end UnitTablesFactory\n\n\n// Create a singleton instance and (to preserve the existing API) an object that\n// provides that instance via getInstance().\nvar unitTablesInstance = new UnitTablesFactory();\nexport const UnitTables = {\n  getInstance: function() {\n    return unitTablesInstance;\n  }\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst Lexer = require('./Lexer');\nconst {Interval} = require('./IntervalSet');\n\n// this is just to keep meaningful parameter types to Parser\nclass TokenStream {}\n\n/**\n * This implementation of {@link TokenStream} loads tokens from a\n * {@link TokenSource} on-demand, and places the tokens in a buffer to provide\n * access to any previous token by index.\n *\n * <p>\n * This token stream ignores the value of {@link Token//getChannel}. If your\n * parser requires the token stream filter tokens to only those on a particular\n * channel, such as {@link Token//DEFAULT_CHANNEL} or\n * {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a\n * {@link CommonTokenStream}.</p>\n */\nclass BufferedTokenStream extends TokenStream {\n\tconstructor(tokenSource) {\n\n\t\tsuper();\n\t\t// The {@link TokenSource} from which tokens for this stream are fetched.\n\t\tthis.tokenSource = tokenSource;\n\t\t/**\n\t\t * A collection of all tokens fetched from the token source. The list is\n\t\t * considered a complete view of the input once {@link //fetchedEOF} is set\n\t\t * to {@code true}.\n\t\t */\n\t\tthis.tokens = [];\n\n\t\t/**\n\t\t * The index into {@link //tokens} of the current token (next token to\n\t\t * {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should\n\t\t * be\n\t\t * {@link //LT LT(1)}.\n\t\t *\n\t\t * <p>This field is set to -1 when the stream is first constructed or when\n\t\t * {@link //setTokenSource} is called, indicating that the first token has\n\t\t * not yet been fetched from the token source. For additional information,\n\t\t * see the documentation of {@link IntStream} for a description of\n\t\t * Initializing Methods.</p>\n\t\t */\n\t\tthis.index = -1;\n\n\t\t/**\n\t\t * Indicates whether the {@link Token//EOF} token has been fetched from\n\t\t * {@link //tokenSource} and added to {@link //tokens}. This field improves\n\t\t * performance for the following cases:\n\t\t *\n\t\t * <ul>\n\t\t * <li>{@link //consume}: The lookahead check in {@link //consume} to\n\t\t * prevent\n\t\t * consuming the EOF symbol is optimized by checking the values of\n\t\t * {@link //fetchedEOF} and {@link //p} instead of calling {@link\n\t\t * //LA}.</li>\n\t\t * <li>{@link //fetch}: The check to prevent adding multiple EOF symbols\n\t\t * into\n\t\t * {@link //tokens} is trivial with this field.</li>\n\t\t * <ul>\n\t\t */\n\t\tthis.fetchedEOF = false;\n\t}\n\n\tmark() {\n\t\treturn 0;\n\t}\n\n\trelease(marker) {\n\t\t// no resources to release\n\t}\n\n\treset() {\n\t\tthis.seek(0);\n\t}\n\n\tseek(index) {\n\t\tthis.lazyInit();\n\t\tthis.index = this.adjustSeekIndex(index);\n\t}\n\n\tget(index) {\n\t\tthis.lazyInit();\n\t\treturn this.tokens[index];\n\t}\n\n\tconsume() {\n\t\tlet skipEofCheck = false;\n\t\tif (this.index >= 0) {\n\t\t\tif (this.fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = this.index < this.tokens.length - 1;\n\t\t\t} else {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = this.index < this.tokens.length;\n\t\t\t}\n\t\t} else {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\t\tif (!skipEofCheck && this.LA(1) === Token.EOF) {\n\t\t\tthrow \"cannot consume EOF\";\n\t\t}\n\t\tif (this.sync(this.index + 1)) {\n\t\t\tthis.index = this.adjustSeekIndex(this.index + 1);\n\t\t}\n\t}\n\n\t/**\n\t * Make sure index {@code i} in tokens has a token.\n\t *\n\t * @return {Boolean} {@code true} if a token is located at index {@code i}, otherwise\n\t * {@code false}.\n\t * @see //get(int i)\n\t */\n\tsync(i) {\n\t\tconst n = i - this.tokens.length + 1; // how many more elements we need?\n\t\tif (n > 0) {\n\t\t\tconst fetched = this.fetch(n);\n\t\t\treturn fetched >= n;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Add {@code n} elements to buffer.\n\t *\n\t * @return {Number} The actual number of elements added to the buffer.\n\t */\n\tfetch(n) {\n\t\tif (this.fetchedEOF) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst t = this.tokenSource.nextToken();\n\t\t\tt.tokenIndex = this.tokens.length;\n\t\t\tthis.tokens.push(t);\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tthis.fetchedEOF = true;\n\t\t\t\treturn i + 1;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n// Get all tokens from start..stop inclusively///\n\tgetTokens(start, stop, types) {\n\t\tif (types === undefined) {\n\t\t\ttypes = null;\n\t\t}\n\t\tif (start < 0 || stop < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.lazyInit();\n\t\tconst subset = [];\n\t\tif (stop >= this.tokens.length) {\n\t\t\tstop = this.tokens.length - 1;\n\t\t}\n\t\tfor (let i = start; i < stop; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (types === null || types.contains(t.type)) {\n\t\t\t\tsubset.push(t);\n\t\t\t}\n\t\t}\n\t\treturn subset;\n\t}\n\n\tLA(i) {\n\t\treturn this.LT(i).type;\n\t}\n\n\tLB(k) {\n\t\tif (this.index - k < 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.tokens[this.index - k];\n\t}\n\n\tLT(k) {\n\t\tthis.lazyInit();\n\t\tif (k === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (k < 0) {\n\t\t\treturn this.LB(-k);\n\t\t}\n\t\tconst i = this.index + k - 1;\n\t\tthis.sync(i);\n\t\tif (i >= this.tokens.length) { // return EOF token\n\t\t\t// EOF must be last token\n\t\t\treturn this.tokens[this.tokens.length - 1];\n\t\t}\n\t\treturn this.tokens[i];\n\t}\n\n\t/**\n\t * Allowed derived classes to modify the behavior of operations which change\n\t * the current stream position by adjusting the target token index of a seek\n\t * operation. The default implementation simply returns {@code i}. If an\n\t * exception is thrown in this method, the current stream index should not be\n\t * changed.\n\t *\n\t * <p>For example, {@link CommonTokenStream} overrides this method to ensure\n\t * that\n\t * the seek target is always an on-channel token.</p>\n\t *\n\t * @param {Number} i The target token index.\n\t * @return {Number} The adjusted target token index.\n\t */\n\tadjustSeekIndex(i) {\n\t\treturn i;\n\t}\n\n\tlazyInit() {\n\t\tif (this.index === -1) {\n\t\t\tthis.setup();\n\t\t}\n\t}\n\n\tsetup() {\n\t\tthis.sync(0);\n\t\tthis.index = this.adjustSeekIndex(0);\n\t}\n\n// Reset this token stream by setting its token source.///\n\tsetTokenSource(tokenSource) {\n\t\tthis.tokenSource = tokenSource;\n\t\tthis.tokens = [];\n\t\tthis.index = -1;\n\t\tthis.fetchedEOF = false;\n\t}\n\n\t/**\n\t * Given a starting index, return the index of the next token on channel.\n\t * Return i if tokens[i] is on channel. Return -1 if there are no tokens\n\t * on channel between i and EOF.\n\t */\n\tnextTokenOnChannel(i, channel) {\n\t\tthis.sync(i);\n\t\tif (i >= this.tokens.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet token = this.tokens[i];\n\t\twhile (token.channel !== this.channel) {\n\t\t\tif (token.type === Token.EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\ti += 1;\n\t\t\tthis.sync(i);\n\t\t\ttoken = this.tokens[i];\n\t\t}\n\t\treturn i;\n\t}\n\n\t/**\n\t * Given a starting index, return the index of the previous token on channel.\n\t * Return i if tokens[i] is on channel. Return -1 if there are no tokens\n\t * on channel between i and 0.\n\t */\n\tpreviousTokenOnChannel(i, channel) {\n\t\twhile (i >= 0 && this.tokens[i].channel !== channel) {\n\t\t\ti -= 1;\n\t\t}\n\t\treturn i;\n\t}\n\n\t/**\n\t * Collect all tokens on specified channel to the right of\n\t * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or\n\t * EOF. If channel is -1, find any non default channel token.\n\t */\n\tgetHiddenTokensToRight(tokenIndex,\n\t\t\tchannel) {\n\t\tif (channel === undefined) {\n\t\t\tchannel = -1;\n\t\t}\n\t\tthis.lazyInit();\n\t\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n\t\t\tthrow \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n\t\t}\n\t\tconst nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n\t\tconst from_ = tokenIndex + 1;\n\t\t// if none onchannel to right, nextOnChannel=-1 so set to = last token\n\t\tconst to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;\n\t\treturn this.filterForChannel(from_, to, channel);\n\t}\n\n\t/**\n\t * Collect all tokens on specified channel to the left of\n\t * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.\n\t * If channel is -1, find any non default channel token.\n\t */\n\tgetHiddenTokensToLeft(tokenIndex,\n\t\t\tchannel) {\n\t\tif (channel === undefined) {\n\t\t\tchannel = -1;\n\t\t}\n\t\tthis.lazyInit();\n\t\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n\t\t\tthrow \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n\t\t}\n\t\tconst prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n\t\tif (prevOnChannel === tokenIndex - 1) {\n\t\t\treturn null;\n\t\t}\n\t\t// if none on channel to left, prevOnChannel=-1 then from=0\n\t\tconst from_ = prevOnChannel + 1;\n\t\tconst to = tokenIndex - 1;\n\t\treturn this.filterForChannel(from_, to, channel);\n\t}\n\n\tfilterForChannel(left, right, channel) {\n\t\tconst hidden = [];\n\t\tfor (let i = left; i < right + 1; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (channel === -1) {\n\t\t\t\tif (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {\n\t\t\t\t\thidden.push(t);\n\t\t\t\t}\n\t\t\t} else if (t.channel === channel) {\n\t\t\t\thidden.push(t);\n\t\t\t}\n\t\t}\n\t\tif (hidden.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn hidden;\n\t}\n\n\tgetSourceName() {\n\t\treturn this.tokenSource.getSourceName();\n\t}\n\n// Get the text of all tokens in this buffer.///\n\tgetText(interval) {\n\t\tthis.lazyInit();\n\t\tthis.fill();\n\t\tif (interval === undefined || interval === null) {\n\t\t\tinterval = new Interval(0, this.tokens.length - 1);\n\t\t}\n\t\tlet start = interval.start;\n\t\tif (start instanceof Token) {\n\t\t\tstart = start.tokenIndex;\n\t\t}\n\t\tlet stop = interval.stop;\n\t\tif (stop instanceof Token) {\n\t\t\tstop = stop.tokenIndex;\n\t\t}\n\t\tif (start === null || stop === null || start < 0 || stop < 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (stop >= this.tokens.length) {\n\t\t\tstop = this.tokens.length - 1;\n\t\t}\n\t\tlet s = \"\";\n\t\tfor (let i = start; i < stop + 1; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = s + t.text;\n\t\t}\n\t\treturn s;\n\t}\n\n// Get all tokens from lexer until EOF///\n\tfill() {\n\t\tthis.lazyInit();\n\t\twhile (this.fetch(1000) === 1000) {\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\n\nmodule.exports = BufferedTokenStream;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst CommonToken = require('./Token').CommonToken;\n\nclass TokenFactory {}\n\n/**\n * This default implementation of {@link TokenFactory} creates\n * {@link CommonToken} objects.\n */\nclass CommonTokenFactory extends TokenFactory {\n    constructor(copyText) {\n        super();\n        /**\n         * Indicates whether {@link CommonToken//setText} should be called after\n         * constructing tokens to explicitly set the text. This is useful for cases\n         * where the input stream might not be able to provide arbitrary substrings\n         * of text from the input after the lexer creates a token (e.g. the\n         * implementation of {@link CharStream//getText} in\n         * {@link UnbufferedCharStream} throws an\n         * {@link UnsupportedOperationException}). Explicitly setting the token text\n         * allows {@link Token//getText} to be called at any time regardless of the\n         * input stream implementation.\n         *\n         * <p>\n         * The default value is {@code false} to avoid the performance and memory\n         * overhead of copying text for every token unless explicitly requested.</p>\n         */\n        this.copyText = copyText===undefined ? false : copyText;\n    }\n\n    create(source, type, text, channel, start, stop, line, column) {\n        const t = new CommonToken(source, type, channel, start, stop);\n        t.line = line;\n        t.column = column;\n        if (text !==null) {\n            t.text = text;\n        } else if (this.copyText && source[1] !==null) {\n            t.text = source[1].getText(start,stop);\n        }\n        return t;\n    }\n\n    createThin(type, text) {\n        const t = new CommonToken(null, type);\n        t.text = text;\n        return t;\n    }\n}\n\n/**\n * The default {@link CommonTokenFactory} instance.\n *\n * <p>\n * This token factory does not explicitly copy token text when constructing\n * tokens.</p>\n */\nCommonTokenFactory.DEFAULT = new CommonTokenFactory();\n\nmodule.exports = CommonTokenFactory;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n\nconst Token = require('./Token').Token;\nconst BufferedTokenStream = require('./BufferedTokenStream');\n\n/**\n * This class extends {@link BufferedTokenStream} with functionality to filter\n * token streams to tokens on a particular channel (tokens where\n * {@link Token//getChannel} returns a particular value).\n *\n * <p>\n * This token stream provides access to all tokens by index or when calling\n * methods like {@link //getText}. The channel filtering is only used for code\n * accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and\n * {@link //LB}.</p>\n *\n * <p>\n * By default, tokens are placed on the default channel\n * ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the\n * {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to\n * call {@link Lexer//setChannel}.\n * </p>\n *\n * <p>\n * Note: lexer rules which use the {@code ->skip} lexer command or call\n * {@link Lexer//skip} do not produce tokens at all, so input text matched by\n * such a rule will not be available as part of the token stream, regardless of\n * channel.</p>\n */\nclass CommonTokenStream extends BufferedTokenStream {\n    constructor(lexer, channel) {\n        super(lexer);\n        this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;\n    }\n\n    adjustSeekIndex(i) {\n        return this.nextTokenOnChannel(i, this.channel);\n    }\n\n    LB(k) {\n        if (k===0 || this.index-k<0) {\n            return null;\n        }\n        let i = this.index;\n        let n = 1;\n        // find k good tokens looking backwards\n        while (n <= k) {\n            // skip off-channel tokens\n            i = this.previousTokenOnChannel(i - 1, this.channel);\n            n += 1;\n        }\n        if (i < 0) {\n            return null;\n        }\n        return this.tokens[i];\n    }\n\n    LT(k) {\n        this.lazyInit();\n        if (k === 0) {\n            return null;\n        }\n        if (k < 0) {\n            return this.LB(-k);\n        }\n        let i = this.index;\n        let n = 1; // we know tokens[pos] is a good one\n        // find k good tokens\n        while (n < k) {\n            // skip off-channel tokens, but make sure to not look past EOF\n            if (this.sync(i + 1)) {\n                i = this.nextTokenOnChannel(i + 1, this.channel);\n            }\n            n += 1;\n        }\n        return this.tokens[i];\n    }\n\n    // Count EOF just once.\n    getNumberOfOnChannelTokens() {\n        let n = 0;\n        this.fill();\n        for (let i =0; i< this.tokens.length;i++) {\n            const t = this.tokens[i];\n            if( t.channel===this.channel) {\n                n += 1;\n            }\n            if( t.type===Token.EOF) {\n                break;\n            }\n        }\n        return n;\n    }\n}\n\nmodule.exports = CommonTokenStream;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nrequire('./polyfills/codepointat');\nrequire('./polyfills/fromcodepoint');\n\n/**\n * If decodeToUnicodeCodePoints is true, the input is treated\n * as a series of Unicode code points.\n *\n * Otherwise, the input is treated as a series of 16-bit UTF-16 code\n * units.\n */\nclass InputStream {\n\tconstructor(data, decodeToUnicodeCodePoints) {\n\t\tthis.name = \"<empty>\";\n\t\tthis.strdata = data;\n\t\tthis.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;\n\t\t// _loadString - Vacuum all input from a string and then treat it like a buffer.\n\t\tthis._index = 0;\n\t\tthis.data = [];\n\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\tfor (let i = 0; i < this.strdata.length; ) {\n\t\t\t\tconst codePoint = this.strdata.codePointAt(i);\n\t\t\t\tthis.data.push(codePoint);\n\t\t\t\ti += codePoint <= 0xFFFF ? 1 : 2;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.data = new Array(this.strdata.length);\n\t\t\tfor (let i = 0; i < this.strdata.length; i++) {\n\t\t\t\tconst codeUnit = this.strdata.charCodeAt(i);\n\t\t\t\tthis.data[i] = codeUnit;\n\t\t\t}\n\t\t}\n\t\tthis._size = this.data.length;\n\t}\n\n\t/**\n\t * Reset the stream so that it's in the same state it was\n\t * when the object was created *except* the data array is not\n\t * touched.\n\t */\n\treset() {\n\t\tthis._index = 0;\n\t}\n\n\tconsume() {\n\t\tif (this._index >= this._size) {\n\t\t\t// assert this.LA(1) == Token.EOF\n\t\t\tthrow (\"cannot consume EOF\");\n\t\t}\n\t\tthis._index += 1;\n\t}\n\n\tLA(offset) {\n\t\tif (offset === 0) {\n\t\t\treturn 0; // undefined\n\t\t}\n\t\tif (offset < 0) {\n\t\t\toffset += 1; // e.g., translate LA(-1) to use offset=0\n\t\t}\n\t\tconst pos = this._index + offset - 1;\n\t\tif (pos < 0 || pos >= this._size) { // invalid\n\t\t\treturn Token.EOF;\n\t\t}\n\t\treturn this.data[pos];\n\t}\n\n\tLT(offset) {\n\t\treturn this.LA(offset);\n\t}\n\n// mark/release do nothing; we have entire buffer\n\tmark() {\n\t\treturn -1;\n\t}\n\n\trelease(marker) {\n\t}\n\n\t/**\n\t * consume() ahead until p==_index; can't just set p=_index as we must\n\t * update line and column. If we seek backwards, just set p\n\t */\n\tseek(_index) {\n\t\tif (_index <= this._index) {\n\t\t\tthis._index = _index; // just jump; don't update stream state (line,\n\t\t\t\t\t\t\t\t\t// ...)\n\t\t\treturn;\n\t\t}\n\t\t// seek forward\n\t\tthis._index = Math.min(_index, this._size);\n\t}\n\n\tgetText(start, stop) {\n\t\tif (stop >= this._size) {\n\t\t\tstop = this._size - 1;\n\t\t}\n\t\tif (start >= this._size) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\t\tlet result = \"\";\n\t\t\t\tfor (let i = start; i <= stop; i++) {\n\t\t\t\t\tresult += String.fromCodePoint(this.data[i]);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this.strdata.slice(start, stop + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this.strdata;\n\t}\n\n\tget index(){\n\t\treturn this._index;\n\t}\n\n\tget size(){\n\t\treturn this._size;\n\t}\n}\n\n\nmodule.exports = InputStream;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\n\n/* stop is not included! */\nclass Interval {\n\n\tconstructor(start, stop) {\n\t\tthis.start = start;\n\t\tthis.stop = stop;\n\t}\n\n\tclone() {\n\t\treturn new Interval(this.start, this.stop);\n\t}\n\n\tcontains(item) {\n\t\treturn item >= this.start && item < this.stop;\n\t}\n\n\ttoString() {\n\t\tif(this.start===this.stop-1) {\n\t\t\treturn this.start.toString();\n\t\t} else {\n\t\t\treturn this.start.toString() + \"..\" + (this.stop-1).toString();\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.stop - this.start;\n\t}\n}\n\n\nclass IntervalSet {\n\tconstructor() {\n\t\tthis.intervals = null;\n\t\tthis.readOnly = false;\n\t}\n\n\tfirst(v) {\n\t\tif (this.intervals === null || this.intervals.length===0) {\n\t\t\treturn Token.INVALID_TYPE;\n\t\t} else {\n\t\t\treturn this.intervals[0].start;\n\t\t}\n\t}\n\n\taddOne(v) {\n\t\tthis.addInterval(new Interval(v, v + 1));\n\t}\n\n\taddRange(l, h) {\n\t\tthis.addInterval(new Interval(l, h + 1));\n\t}\n\n\taddInterval(toAdd) {\n\t\tif (this.intervals === null) {\n\t\t\tthis.intervals = [];\n\t\t\tthis.intervals.push(toAdd.clone());\n\t\t} else {\n\t\t\t// find insert pos\n\t\t\tfor (let pos = 0; pos < this.intervals.length; pos++) {\n\t\t\t\tconst existing = this.intervals[pos];\n\t\t\t\t// distinct range -> insert\n\t\t\t\tif (toAdd.stop < existing.start) {\n\t\t\t\t\tthis.intervals.splice(pos, 0, toAdd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// contiguous range -> adjust\n\t\t\t\telse if (toAdd.stop === existing.start) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(toAdd.start, existing.stop)\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// overlapping range -> adjust and reduce\n\t\t\t\telse if (toAdd.start <= existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));\n\t\t\t\t\tthis.reduce(pos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// greater than any existing\n\t\t\tthis.intervals.push(toAdd.clone());\n\t\t}\n\t}\n\n\taddSet(other) {\n\t\tif (other.intervals !== null) {\n\t\t\tother.intervals.forEach( toAdd => this.addInterval(toAdd), this);\n\t\t}\n\t\treturn this;\n\t}\n\n\treduce(pos) {\n\t\t// only need to reduce if pos is not the last\n\t\tif (pos < this.intervals.length - 1) {\n\t\t\tconst current = this.intervals[pos];\n\t\t\tconst next = this.intervals[pos + 1];\n\t\t\t// if next contained in current\n\t\t\tif (current.stop >= next.stop) {\n\t\t\t\tthis.intervals.splice(pos + 1, 1);\n\t\t\t\tthis.reduce(pos);\n\t\t\t} else if (current.stop >= next.start) {\n\t\t\t\tthis.intervals[pos] = new Interval(current.start, next.stop);\n\t\t\t\tthis.intervals.splice(pos + 1, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcomplement(start, stop) {\n\t\tconst result = new IntervalSet();\n\t\tresult.addInterval(new Interval(start, stop + 1));\n\t\tif(this.intervals !== null)\n\t\t\tthis.intervals.forEach(toRemove => result.removeRange(toRemove));\n\t\treturn result;\n\t}\n\n\tcontains(item) {\n\t\tif (this.intervals === null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tfor (let k = 0; k < this.intervals.length; k++) {\n\t\t\t\tif(this.intervals[k].contains(item)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tremoveRange(toRemove) {\n\t\tif(toRemove.start===toRemove.stop-1) {\n\t\t\tthis.removeOne(toRemove.start);\n\t\t} else if (this.intervals !== null) {\n\t\t\tlet pos = 0;\n\t\t\tfor(let n=0; n<this.intervals.length; n++) {\n\t\t\t\tconst existing = this.intervals[pos];\n\t\t\t\t// intervals are ordered\n\t\t\t\tif (toRemove.stop<=existing.start) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for including range, split it\n\t\t\t\telse if(toRemove.start>existing.start && toRemove.stop<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(existing.start, toRemove.start);\n\t\t\t\t\tconst x = new Interval(toRemove.stop, existing.stop);\n\t\t\t\t\tthis.intervals.splice(pos, 0, x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for included range, remove it\n\t\t\t\telse if(toRemove.start<=existing.start && toRemove.stop>=existing.stop) {\n\t\t\t\t\tthis.intervals.splice(pos, 1);\n\t\t\t\t\tpos = pos - 1; // need another pass\n\t\t\t\t}\n\t\t\t\t// check for lower boundary\n\t\t\t\telse if(toRemove.start<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(existing.start, toRemove.start);\n\t\t\t\t}\n\t\t\t\t// check for upper boundary\n\t\t\t\telse if(toRemove.stop<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(toRemove.stop, existing.stop);\n\t\t\t\t}\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveOne(value) {\n\t\tif (this.intervals !== null) {\n\t\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\t\tconst existing = this.intervals[i];\n\t\t\t\t// intervals are ordered\n\t\t\t\tif (value < existing.start) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for single value range\n\t\t\t\telse if (value === existing.start && value === existing.stop - 1) {\n\t\t\t\t\tthis.intervals.splice(i, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for lower boundary\n\t\t\t\telse if (value === existing.start) {\n\t\t\t\t\tthis.intervals[i] = new Interval(existing.start + 1, existing.stop);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for upper boundary\n\t\t\t\telse if (value === existing.stop - 1) {\n\t\t\t\t\tthis.intervals[i] = new Interval(existing.start, existing.stop - 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// split existing range\n\t\t\t\telse if (value < existing.stop - 1) {\n\t\t\t\t\tconst replace = new Interval(existing.start, value);\n\t\t\t\t\texisting.start = value + 1;\n\t\t\t\t\tthis.intervals.splice(i, 0, replace);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString(literalNames, symbolicNames, elemsAreChar) {\n\t\tliteralNames = literalNames || null;\n\t\tsymbolicNames = symbolicNames || null;\n\t\telemsAreChar = elemsAreChar || false;\n\t\tif (this.intervals === null) {\n\t\t\treturn \"{}\";\n\t\t} else if(literalNames!==null || symbolicNames!==null) {\n\t\t\treturn this.toTokenString(literalNames, symbolicNames);\n\t\t} else if(elemsAreChar) {\n\t\t\treturn this.toCharString();\n\t\t} else {\n\t\t\treturn this.toIndexString();\n\t\t}\n\t}\n\n\ttoCharString() {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tif(existing.stop===existing.start+1) {\n\t\t\t\tif ( existing.start===Token.EOF ) {\n\t\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t\t} else {\n\t\t\t\t\tnames.push(\"'\" + String.fromCharCode(existing.start) + \"'\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames.push(\"'\" + String.fromCharCode(existing.start) + \"'..'\" + String.fromCharCode(existing.stop-1) + \"'\");\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\ttoIndexString() {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tif(existing.stop===existing.start+1) {\n\t\t\t\tif ( existing.start===Token.EOF ) {\n\t\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t\t} else {\n\t\t\t\t\tnames.push(existing.start.toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames.push(existing.start.toString() + \"..\" + (existing.stop-1).toString());\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\ttoTokenString(literalNames, symbolicNames) {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tfor (let j = existing.start; j < existing.stop; j++) {\n\t\t\t\tnames.push(this.elementName(literalNames, symbolicNames, j));\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\telementName(literalNames, symbolicNames, token) {\n\t\tif (token === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (token === Token.EPSILON) {\n\t\t\treturn \"<EPSILON>\";\n\t\t} else {\n\t\t\treturn literalNames[token] || symbolicNames[token];\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.intervals.map( interval => interval.length ).reduce((acc, val) => acc + val);\n\t}\n}\n\nmodule.exports = {\n\tInterval,\n\tIntervalSet\n};\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Set, BitSet} = require('./Utils');\nconst {Token} = require('./Token');\nconst {ATNConfig} = require('./atn/ATNConfig');\nconst {IntervalSet} = require('./IntervalSet');\nconst {RuleStopState} = require('./atn/ATNState');\nconst {RuleTransition, NotSetTransition, WildcardTransition, AbstractPredicateTransition} = require('./atn/Transition');\nconst {predictionContextFromRuleContext, PredictionContext, SingletonPredictionContext} = require('./PredictionContext');\n\nclass LL1Analyzer {\n    constructor(atn) {\n        this.atn = atn;\n    }\n\n    /**\n     * Calculates the SLL(1) expected lookahead set for each outgoing transition\n     * of an {@link ATNState}. The returned array has one element for each\n     * outgoing transition in {@code s}. If the closure from transition\n     * <em>i</em> leads to a semantic predicate before matching a symbol, the\n     * element at index <em>i</em> of the result will be {@code null}.\n     *\n     * @param s the ATN state\n     * @return the expected symbols for each outgoing transition of {@code s}.\n     */\n    getDecisionLookahead(s) {\n        if (s === null) {\n            return null;\n        }\n        const count = s.transitions.length;\n        const look = [];\n        for(let alt=0; alt< count; alt++) {\n            look[alt] = new IntervalSet();\n            const lookBusy = new Set();\n            const seeThruPreds = false; // fail to get lookahead upon pred\n            this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,\n                  look[alt], lookBusy, new BitSet(), seeThruPreds, false);\n            // Wipe out lookahead for this alternative if we found nothing\n            // or we had a predicate when we !seeThruPreds\n            if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {\n                look[alt] = null;\n            }\n        }\n        return look;\n    }\n\n    /**\n     * Compute set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     *\n     * <p>If {@code ctx} is {@code null} and the end of the rule containing\n     * {@code s} is reached, {@link Token//EPSILON} is added to the result set.\n     * If {@code ctx} is not {@code null} and the end of the outermost rule is\n     * reached, {@link Token//EOF} is added to the result set.</p>\n     *\n     * @param s the ATN state\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx the complete parser context, or {@code null} if the context\n     * should be ignored\n     *\n     * @return The set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     */\n    LOOK(s, stopState, ctx) {\n        const r = new IntervalSet();\n        const seeThruPreds = true; // ignore preds; get all lookahead\n        ctx = ctx || null;\n        const lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;\n        this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);\n        return r;\n    }\n\n    /**\n     * Compute set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     *\n     * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the\n     * rule containing {@code s} is reached, {@link Token//EPSILON} is added to\n     * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is\n     * {@code true} and {@code stopState} or the end of the outermost rule is\n     * reached, {@link Token//EOF} is added to the result set.</p>\n     *\n     * @param s the ATN state.\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx The outer context, or {@code null} if the outer context should\n     * not be used.\n     * @param look The result lookahead set.\n     * @param lookBusy A set used for preventing epsilon closures in the ATN\n     * from causing a stack overflow. Outside code should pass\n     * {@code new Set<ATNConfig>} for this argument.\n     * @param calledRuleStack A set used for preventing left recursion in the\n     * ATN from causing a stack overflow. Outside code should pass\n     * {@code new BitSet()} for this argument.\n     * @param seeThruPreds {@code true} to true semantic predicates as\n     * implicitly {@code true} and \"see through them\", otherwise {@code false}\n     * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the\n     * result if one is encountered.\n     * @param addEOF Add {@link Token//EOF} to the result if the end of the\n     * outermost context is reached. This parameter has no effect if {@code ctx}\n     * is {@code null}.\n     */\n    _LOOK(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n        const c = new ATNConfig({state:s, alt:0, context: ctx}, null);\n        if (lookBusy.contains(c)) {\n            return;\n        }\n        lookBusy.add(c);\n        if (s === stopState) {\n            if (ctx ===null) {\n                look.addOne(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne(Token.EOF);\n                return;\n            }\n        }\n        if (s instanceof RuleStopState ) {\n            if (ctx ===null) {\n                look.addOne(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne(Token.EOF);\n                return;\n            }\n            if (ctx !== PredictionContext.EMPTY) {\n                const removed = calledRuleStack.contains(s.ruleIndex);\n                try {\n                    calledRuleStack.remove(s.ruleIndex);\n                    // run thru all possible stack tops in ctx\n                    for (let i = 0; i < ctx.length; i++) {\n                        const returnState = this.atn.states[ctx.getReturnState(i)];\n                        this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                    }\n                }finally {\n                    if (removed) {\n                        calledRuleStack.add(s.ruleIndex);\n                    }\n                }\n                return;\n            }\n        }\n        for(let j=0; j<s.transitions.length; j++) {\n            const t = s.transitions[j];\n            if (t.constructor === RuleTransition) {\n                if (calledRuleStack.contains(t.target.ruleIndex)) {\n                    continue;\n                }\n                const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n                try {\n                    calledRuleStack.add(t.target.ruleIndex);\n                    this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    calledRuleStack.remove(t.target.ruleIndex);\n                }\n            } else if (t instanceof AbstractPredicateTransition ) {\n                if (seeThruPreds) {\n                    this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } else {\n                    look.addOne(LL1Analyzer.HIT_PRED);\n                }\n            } else if( t.isEpsilon) {\n                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else if (t.constructor === WildcardTransition) {\n                look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );\n            } else {\n                let set = t.label;\n                if (set !== null) {\n                    if (t instanceof NotSetTransition) {\n                        set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                    }\n                    look.addSet(set);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Special value added to the lookahead sets to indicate that we hit\n * a predicate during analysis if {@code seeThruPreds==false}.\n */\nLL1Analyzer.HIT_PRED = Token.INVALID_TYPE;\n\nmodule.exports = LL1Analyzer;\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst Recognizer = require('./Recognizer');\nconst CommonTokenFactory = require('./CommonTokenFactory');\nconst {RecognitionException} = require('./error/Errors');\nconst {LexerNoViableAltException} = require('./error/Errors');\n\nclass TokenSource {}\n\n/**\n * A lexer is recognizer that draws input symbols from a character stream.\n * lexer grammars result in a subclass of this object. A Lexer object\n * uses simplified match() and error recovery mechanisms in the interest of speed.\n */\nclass Lexer extends Recognizer {\n\tconstructor(input) {\n\t\tsuper();\n\t\tthis._input = input;\n\t\tthis._factory = CommonTokenFactory.DEFAULT;\n\t\tthis._tokenFactorySourcePair = [ this, input ];\n\n\t\tthis._interp = null; // child classes must populate this\n\n\t\t/**\n\t\t * The goal of all lexer rules/methods is to create a token object.\n\t\t * this is an instance variable as multiple rules may collaborate to\n\t\t * create a single token. nextToken will return this object after\n\t\t * matching lexer rule(s). If you subclass to allow multiple token\n\t\t * emissions, then set this to the last token to be matched or\n\t\t * something nonnull so that the auto token emit mechanism will not\n\t\t * emit another token.\n\t\t */\n\t\tthis._token = null;\n\n\t\t/**\n\t\t * What character index in the stream did the current token start at?\n\t\t * Needed, for example, to get the text for current token. Set at\n\t\t * the start of nextToken.\n\t\t */\n\t\tthis._tokenStartCharIndex = -1;\n\n\t\t// The line on which the first character of the token resides///\n\t\tthis._tokenStartLine = -1;\n\n\t\t// The character position of first character within the line///\n\t\tthis._tokenStartColumn = -1;\n\n\t\t// Once we see EOF on char stream, next token will be EOF.\n\t\t// If you have DONE : EOF ; then you see DONE EOF.\n\t\tthis._hitEOF = false;\n\n\t\t// The channel number for the current token///\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\n\t\t// The token type for the current token///\n\t\tthis._type = Token.INVALID_TYPE;\n\n\t\tthis._modeStack = [];\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\n\t\t/**\n\t\t * You can set the text for the current token to override what is in\n\t\t * the input char buffer. Use setText() or can set this instance var.\n\t\t */\n\t\tthis._text = null;\n\t}\n\n\treset() {\n\t\t// wack Lexer state variables\n\t\tif (this._input !== null) {\n\t\t\tthis._input.seek(0); // rewind the input\n\t\t}\n\t\tthis._token = null;\n\t\tthis._type = Token.INVALID_TYPE;\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\tthis._tokenStartCharIndex = -1;\n\t\tthis._tokenStartColumn = -1;\n\t\tthis._tokenStartLine = -1;\n\t\tthis._text = null;\n\n\t\tthis._hitEOF = false;\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\t\tthis._modeStack = [];\n\n\t\tthis._interp.reset();\n\t}\n\n// Return a token from this source; i.e., match a token on the char stream.\n\tnextToken() {\n\t\tif (this._input === null) {\n\t\t\tthrow \"nextToken requires a non-null input stream.\";\n\t\t}\n\n\t\t/**\n\t\t * Mark start location in char stream so unbuffered streams are\n\t\t * guaranteed at least have text of current token\n\t\t */\n\t\tconst tokenStartMarker = this._input.mark();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tif (this._hitEOF) {\n\t\t\t\t\tthis.emitEOF();\n\t\t\t\t\treturn this._token;\n\t\t\t\t}\n\t\t\t\tthis._token = null;\n\t\t\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\t\t\tthis._tokenStartCharIndex = this._input.index;\n\t\t\t\tthis._tokenStartColumn = this._interp.column;\n\t\t\t\tthis._tokenStartLine = this._interp.line;\n\t\t\t\tthis._text = null;\n\t\t\t\tlet continueOuter = false;\n\t\t\t\twhile (true) {\n\t\t\t\t\tthis._type = Token.INVALID_TYPE;\n\t\t\t\t\tlet ttype = Lexer.SKIP;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tttype = this._interp.match(this._input, this._mode);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif(e instanceof RecognitionException) {\n\t\t\t\t\t\t\tthis.notifyListeners(e); // report error\n\t\t\t\t\t\t\tthis.recover(e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log(e.stack);\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._input.LA(1) === Token.EOF) {\n\t\t\t\t\t\tthis._hitEOF = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Token.INVALID_TYPE) {\n\t\t\t\t\t\tthis._type = ttype;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Lexer.SKIP) {\n\t\t\t\t\t\tcontinueOuter = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type !== Lexer.MORE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (continueOuter) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (this._token === null) {\n\t\t\t\t\tthis.emit();\n\t\t\t\t}\n\t\t\t\treturn this._token;\n\t\t\t}\n\t\t} finally {\n\t\t\t// make sure we release marker after match or\n\t\t\t// unbuffered char stream will keep buffering\n\t\t\tthis._input.release(tokenStartMarker);\n\t\t}\n\t}\n\n\t/**\n\t * Instruct the lexer to skip creating a token for current lexer rule\n\t * and look for another token. nextToken() knows to keep looking when\n\t * a lexer rule finishes with token set to SKIP_TOKEN. Recall that\n\t * if token==null at end of any token rule, it creates one for you\n\t * and emits it.\n\t */\n\tskip() {\n\t\tthis._type = Lexer.SKIP;\n\t}\n\n\tmore() {\n\t\tthis._type = Lexer.MORE;\n\t}\n\n\tmode(m) {\n\t\tthis._mode = m;\n\t}\n\n\tpushMode(m) {\n\t\tif (this._interp.debug) {\n\t\t\tconsole.log(\"pushMode \" + m);\n\t\t}\n\t\tthis._modeStack.push(this._mode);\n\t\tthis.mode(m);\n\t}\n\n\tpopMode() {\n\t\tif (this._modeStack.length === 0) {\n\t\t\tthrow \"Empty Stack\";\n\t\t}\n\t\tif (this._interp.debug) {\n\t\t\tconsole.log(\"popMode back to \" + this._modeStack.slice(0, -1));\n\t\t}\n\t\tthis.mode(this._modeStack.pop());\n\t\treturn this._mode;\n\t}\n\n\t/**\n\t * By default does not support multiple emits per nextToken invocation\n\t * for efficiency reasons. Subclass and override this method, nextToken,\n\t * and getToken (to push tokens into a list and pull from that list\n\t * rather than a single variable as this implementation does).\n\t */\n\temitToken(token) {\n\t\tthis._token = token;\n\t}\n\n\t/**\n\t * The standard method called to automatically emit a token at the\n\t * outermost lexical rule. The token object should point into the\n\t * char buffer start..stop. If there is a text override in 'text',\n\t * use that to set the token's text. Override this method to emit\n\t * custom Token objects or provide a new factory.\n\t */\n\temit() {\n\t\tconst t = this._factory.create(this._tokenFactorySourcePair, this._type,\n\t\t\t\tthis._text, this._channel, this._tokenStartCharIndex, this\n\t\t\t\t\t\t.getCharIndex() - 1, this._tokenStartLine,\n\t\t\t\tthis._tokenStartColumn);\n\t\tthis.emitToken(t);\n\t\treturn t;\n\t}\n\n\temitEOF() {\n\t\tconst cpos = this.column;\n\t\tconst lpos = this.line;\n\t\tconst eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,\n\t\t\t\tnull, Token.DEFAULT_CHANNEL, this._input.index,\n\t\t\t\tthis._input.index - 1, lpos, cpos);\n\t\tthis.emitToken(eof);\n\t\treturn eof;\n\t}\n\n// What is the index of the current character of lookahead?///\n\tgetCharIndex() {\n\t\treturn this._input.index;\n\t}\n\n\t/**\n\t * Return a list of all Token objects in input char stream.\n\t * Forces load of all tokens. Does not include EOF token.\n\t */\n\tgetAllTokens() {\n\t\tconst tokens = [];\n\t\tlet t = this.nextToken();\n\t\twhile (t.type !== Token.EOF) {\n\t\t\ttokens.push(t);\n\t\t\tt = this.nextToken();\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tnotifyListeners(e) {\n\t\tconst start = this._tokenStartCharIndex;\n\t\tconst stop = this._input.index;\n\t\tconst text = this._input.getText(start, stop);\n\t\tconst msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n\t\tconst listener = this.getErrorListenerDispatch();\n\t\tlistener.syntaxError(this, null, this._tokenStartLine,\n\t\t\t\tthis._tokenStartColumn, msg, e);\n\t}\n\n\tgetErrorDisplay(s) {\n\t\tconst d = [];\n\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\td.push(s[i]);\n\t\t}\n\t\treturn d.join('');\n\t}\n\n\tgetErrorDisplayForChar(c) {\n\t\tif (c.charCodeAt(0) === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (c === '\\n') {\n\t\t\treturn \"\\\\n\";\n\t\t} else if (c === '\\t') {\n\t\t\treturn \"\\\\t\";\n\t\t} else if (c === '\\r') {\n\t\t\treturn \"\\\\r\";\n\t\t} else {\n\t\t\treturn c;\n\t\t}\n\t}\n\n\tgetCharErrorDisplay(c) {\n\t\treturn \"'\" + this.getErrorDisplayForChar(c) + \"'\";\n\t}\n\n\t/**\n\t * Lexers can normally match any char in it's vocabulary after matching\n\t * a token, so do the easy thing and just kill a character and hope\n\t * it all works out. You can instead use the rule invocation stack\n\t * to do sophisticated error recovery if you are in a fragment rule.\n\t */\n\trecover(re) {\n\t\tif (this._input.LA(1) !== Token.EOF) {\n\t\t\tif (re instanceof LexerNoViableAltException) {\n\t\t\t\t// skip a char and try again\n\t\t\t\tthis._interp.consume(this._input);\n\t\t\t} else {\n\t\t\t\t// TODO: Do we lose character or line position information?\n\t\t\t\tthis._input.consume();\n\t\t\t}\n\t\t}\n\t}\n\n\tget inputStream(){\n\t\treturn this._input;\n\t}\n\n\tset inputStream(input) {\n\t\tthis._input = null;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t\tthis.reset();\n\t\tthis._input = input;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t}\n\n\tget sourceName(){\n\t\treturn this._input.sourceName;\n\t}\n\n\tget type(){\n\t\treturn this._type;\n\t}\n\n\tset type(type) {\n\t\tthis._type = type;\n\t}\n\n\tget line(){\n\t\treturn this._interp.line;\n\t}\n\n\tset line(line) {\n\t\tthis._interp.line = line;\n\t}\n\n\tget column(){\n\t\treturn this._interp.column;\n\t}\n\n\tset column(column) {\n\t\tthis._interp.column = column;\n\t}\n\n\tget text(){\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t} else {\n\t\t\treturn this._interp.getText(this._input);\n\t\t}\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\n\n\n\nLexer.DEFAULT_MODE = 0;\nLexer.MORE = -2;\nLexer.SKIP = -3;\n\nLexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;\nLexer.HIDDEN = Token.HIDDEN_CHANNEL;\nLexer.MIN_CHAR_VALUE = 0x0000;\nLexer.MAX_CHAR_VALUE = 0x10FFFF;\n\n// Set the char stream and reset the lexer\n\n\nmodule.exports = Lexer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst {ParseTreeListener, TerminalNode, ErrorNode} = require('./tree/Tree');\nconst Recognizer = require('./Recognizer');\nconst {DefaultErrorStrategy} = require('./error/ErrorStrategy');\nconst ATNDeserializer = require('./atn/ATNDeserializer');\nconst ATNDeserializationOptions = require('./atn/ATNDeserializationOptions');\nconst Lexer = require('./Lexer');\n\nclass TraceListener extends ParseTreeListener {\n\tconstructor(parser) {\n\t\tsuper();\n\t\tthis.parser = parser;\n\t}\n\n\tenterEveryRule(ctx) {\n\t\tconsole.log(\"enter   \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n\t}\n\n\tvisitTerminal(node) {\n\t\tconsole.log(\"consume \" + node.symbol + \" rule \" + this.parser.ruleNames[this.parser._ctx.ruleIndex]);\n\t}\n\n\texitEveryRule(ctx) {\n\t\tconsole.log(\"exit    \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n\t}\n}\n\nclass Parser extends Recognizer {\n\t/**\n\t * this is all the parsing support code essentially; most of it is error\n\t * recovery stuff.\n\t */\n\tconstructor(input) {\n\t\tsuper();\n\t\t// The input stream.\n\t\tthis._input = null;\n\t\t/**\n\t\t * The error handling strategy for the parser. The default value is a new\n\t\t * instance of {@link DefaultErrorStrategy}.\n\t\t */\n\t\tthis._errHandler = new DefaultErrorStrategy();\n\t\tthis._precedenceStack = [];\n\t\tthis._precedenceStack.push(0);\n\t\t/**\n\t\t * The {@link ParserRuleContext} object for the currently executing rule.\n\t\t * this is always non-null during the parsing process.\n\t\t */\n\t\tthis._ctx = null;\n\t\t/**\n\t\t * Specifies whether or not the parser should construct a parse tree during\n\t\t * the parsing process. The default value is {@code true}.\n\t\t */\n\t\tthis.buildParseTrees = true;\n\t\t/**\n\t\t * When {@link //setTrace}{@code (true)} is called, a reference to the\n\t\t * {@link TraceListener} is stored here so it can be easily removed in a\n\t\t * later call to {@link //setTrace}{@code (false)}. The listener itself is\n\t\t * implemented as a parser listener so this field is not directly used by\n\t\t * other parser methods.\n\t\t */\n\t\tthis._tracer = null;\n\t\t/**\n\t\t * The list of {@link ParseTreeListener} listeners registered to receive\n\t\t * events during the parse.\n\t\t */\n\t\tthis._parseListeners = null;\n\t\t/**\n\t\t * The number of syntax errors reported during parsing. this value is\n\t\t * incremented each time {@link //notifyErrorListeners} is called.\n\t\t */\n\t\tthis._syntaxErrors = 0;\n\t\tthis.setInputStream(input);\n\t}\n\n\t// reset the parser's state\n\treset() {\n\t\tif (this._input !== null) {\n\t\t\tthis._input.seek(0);\n\t\t}\n\t\tthis._errHandler.reset(this);\n\t\tthis._ctx = null;\n\t\tthis._syntaxErrors = 0;\n\t\tthis.setTrace(false);\n\t\tthis._precedenceStack = [];\n\t\tthis._precedenceStack.push(0);\n\t\tif (this._interp !== null) {\n\t\t\tthis._interp.reset();\n\t\t}\n\t}\n\n\t/**\n\t * Match current input symbol against {@code ttype}. If the symbol type\n\t * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are\n\t * called to complete the match process.\n\t *\n\t * <p>If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link //getBuildParseTree} is\n\t * {@code true} and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n\t *\n\t * @param ttype the token type to match\n\t * @return the matched symbol\n\t * @throws RecognitionException if the current input symbol did not match\n\t * {@code ttype} and the error strategy could not recover from the\n\t * mismatched symbol\n\t */\n\tmatch(ttype) {\n\t\tlet t = this.getCurrentToken();\n\t\tif (t.type === ttype) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this.buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token\n\t\t\t\t// insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\t/**\n\t * Match current input symbol as a wildcard. If the symbol type matches\n\t * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}\n\t * and {@link //consume} are called to complete the match process.\n\t *\n\t * <p>If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link //getBuildParseTree} is\n\t * {@code true} and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n\t *\n\t * @return the matched symbol\n\t * @throws RecognitionException if the current input symbol did not match\n\t * a wildcard and the error strategy could not recover from the mismatched\n\t * symbol\n\t */\n\tmatchWildcard() {\n\t\tlet t = this.getCurrentToken();\n\t\tif (t.type > 0) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this._buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token\n\t\t\t\t// insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\tgetParseListeners() {\n\t\treturn this._parseListeners || [];\n\t}\n\n\t/**\n\t * Registers {@code listener} to receive events during the parsing process.\n\t *\n\t * <p>To support output-preserving grammar transformations (including but not\n\t * limited to left-recursion removal, automated left-factoring, and\n\t * optimized code generation), calls to listener methods during the parse\n\t * may differ substantially from calls made by\n\t * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In\n\t * particular, rule entry and exit events may occur in a different order\n\t * during the parse than after the parser. In addition, calls to certain\n\t * rule entry methods may be omitted.</p>\n\t *\n\t * <p>With the following specific exceptions, calls to listener events are\n\t * <em>deterministic</em>, i.e. for identical input the calls to listener\n\t * methods will be the same.</p>\n\t *\n\t * <ul>\n\t * <li>Alterations to the grammar used to generate code may change the\n\t * behavior of the listener calls.</li>\n\t * <li>Alterations to the command line options passed to ANTLR 4 when\n\t * generating the parser may change the behavior of the listener calls.</li>\n\t * <li>Changing the version of the ANTLR Tool used to generate the parser\n\t * may change the behavior of the listener calls.</li>\n\t * </ul>\n\t *\n\t * @param listener the listener to add\n\t *\n\t * @throws NullPointerException if {@code} listener is {@code null}\n\t */\n\taddParseListener(listener) {\n\t\tif (listener === null) {\n\t\t\tthrow \"listener\";\n\t\t}\n\t\tif (this._parseListeners === null) {\n\t\t\tthis._parseListeners = [];\n\t\t}\n\t\tthis._parseListeners.push(listener);\n\t}\n\n\t/**\n\t * Remove {@code listener} from the list of parse listeners.\n\t *\n\t * <p>If {@code listener} is {@code null} or has not been added as a parse\n\t * listener, this method does nothing.</p>\n\t * @param listener the listener to remove\n\t */\n\tremoveParseListener(listener) {\n\t\tif (this._parseListeners !== null) {\n\t\t\tconst idx = this._parseListeners.indexOf(listener);\n\t\t\tif (idx >= 0) {\n\t\t\t\tthis._parseListeners.splice(idx, 1);\n\t\t\t}\n\t\t\tif (this._parseListeners.length === 0) {\n\t\t\t\tthis._parseListeners = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove all parse listeners.\n\tremoveParseListeners() {\n\t\tthis._parseListeners = null;\n\t}\n\n\t// Notify any parse listeners of an enter rule event.\n\ttriggerEnterRuleEvent() {\n\t\tif (this._parseListeners !== null) {\n\t\t\tconst ctx = this._ctx;\n\t\t\tthis._parseListeners.forEach(function(listener) {\n\t\t\t\tlistener.enterEveryRule(ctx);\n\t\t\t\tctx.enterRule(listener);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Notify any parse listeners of an exit rule event.\n\t * @see //addParseListener\n\t */\n\ttriggerExitRuleEvent() {\n\t\tif (this._parseListeners !== null) {\n\t\t\t// reverse order walk of listeners\n\t\t\tconst ctx = this._ctx;\n\t\t\tthis._parseListeners.slice(0).reverse().forEach(function(listener) {\n\t\t\t\tctx.exitRule(listener);\n\t\t\t\tlistener.exitEveryRule(ctx);\n\t\t\t});\n\t\t}\n\t}\n\n\tgetTokenFactory() {\n\t\treturn this._input.tokenSource._factory;\n\t}\n\n\t// Tell our token source and error strategy about a new way to create tokens.\n\tsetTokenFactory(factory) {\n\t\tthis._input.tokenSource._factory = factory;\n\t}\n\n\t/**\n\t * The ATN with bypass alternatives is expensive to create so we create it\n\t * lazily.\n\t *\n\t * @throws UnsupportedOperationException if the current parser does not\n\t * implement the {@link //getSerializedATN()} method.\n\t */\n\tgetATNWithBypassAlts() {\n\t\tconst serializedAtn = this.getSerializedATN();\n\t\tif (serializedAtn === null) {\n\t\t\tthrow \"The current parser does not support an ATN with bypass alternatives.\";\n\t\t}\n\t\tlet result = this.bypassAltsAtnCache[serializedAtn];\n\t\tif (result === null) {\n\t\t\tconst deserializationOptions = new ATNDeserializationOptions();\n\t\t\tdeserializationOptions.generateRuleBypassTransitions = true;\n\t\t\tresult = new ATNDeserializer(deserializationOptions)\n\t\t\t\t\t.deserialize(serializedAtn);\n\t\t\tthis.bypassAltsAtnCache[serializedAtn] = result;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The preferred method of getting a tree pattern. For example, here's a\n\t * sample use:\n\t *\n\t * <pre>\n\t * ParseTree t = parser.expr();\n\t * ParseTreePattern p = parser.compileParseTreePattern(\"&lt;ID&gt;+0\",\n\t * MyParser.RULE_expr);\n\t * ParseTreeMatch m = p.match(t);\n\t * String id = m.get(\"ID\");\n\t * </pre>\n\t */\n\tcompileParseTreePattern(pattern, patternRuleIndex, lexer) {\n\t\tlexer = lexer || null;\n\t\tif (lexer === null) {\n\t\t\tif (this.getTokenStream() !== null) {\n\t\t\t\tconst tokenSource = this.getTokenStream().tokenSource;\n\t\t\t\tif (tokenSource instanceof Lexer) {\n\t\t\t\t\tlexer = tokenSource;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lexer === null) {\n\t\t\tthrow \"Parser can't discover a lexer to use\";\n\t\t}\n\t\tconst m = new ParseTreePatternMatcher(lexer, this);\n\t\treturn m.compile(pattern, patternRuleIndex);\n\t}\n\n\tgetInputStream() {\n\t\treturn this.getTokenStream();\n\t}\n\n\tsetInputStream(input) {\n\t\tthis.setTokenStream(input);\n\t}\n\n\tgetTokenStream() {\n\t\treturn this._input;\n\t}\n\n\t// Set the token stream and reset the parser.\n\tsetTokenStream(input) {\n\t\tthis._input = null;\n\t\tthis.reset();\n\t\tthis._input = input;\n\t}\n\n\t/**\n\t * Match needs to return the current input symbol, which gets put\n\t * into the label for the associated token ref; e.g., x=ID.\n\t */\n\tgetCurrentToken() {\n\t\treturn this._input.LT(1);\n\t}\n\n\tnotifyErrorListeners(msg, offendingToken, err) {\n\t\toffendingToken = offendingToken || null;\n\t\terr = err || null;\n\t\tif (offendingToken === null) {\n\t\t\toffendingToken = this.getCurrentToken();\n\t\t}\n\t\tthis._syntaxErrors += 1;\n\t\tconst line = offendingToken.line;\n\t\tconst column = offendingToken.column;\n\t\tconst listener = this.getErrorListenerDispatch();\n\t\tlistener.syntaxError(this, offendingToken, line, column, msg, err);\n\t}\n\n\t/**\n\t * Consume and return the {@linkplain //getCurrentToken current symbol}.\n\t *\n\t * <p>E.g., given the following input with {@code A} being the current\n\t * lookahead symbol, this function moves the cursor to {@code B} and returns\n\t * {@code A}.</p>\n\t *\n\t * <pre>\n\t * A B\n\t * ^\n\t * </pre>\n\t *\n\t * If the parser is not in error recovery mode, the consumed symbol is added\n\t * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and\n\t * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.\n\t * If the parser <em>is</em> in error recovery mode, the consumed symbol is\n\t * added to the parse tree using\n\t * {@link ParserRuleContext//addErrorNode(Token)}, and\n\t * {@link ParseTreeListener//visitErrorNode} is called on any parse\n\t * listeners.\n\t */\n\tconsume() {\n\t\tconst o = this.getCurrentToken();\n\t\tif (o.type !== Token.EOF) {\n\t\t\tthis.getInputStream().consume();\n\t\t}\n\t\tconst hasListener = this._parseListeners !== null && this._parseListeners.length > 0;\n\t\tif (this.buildParseTrees || hasListener) {\n\t\t\tlet node;\n\t\t\tif (this._errHandler.inErrorRecoveryMode(this)) {\n\t\t\t\tnode = this._ctx.addErrorNode(o);\n\t\t\t} else {\n\t\t\t\tnode = this._ctx.addTokenNode(o);\n\t\t\t}\n\t\t\tnode.invokingState = this.state;\n\t\t\tif (hasListener) {\n\t\t\t\tthis._parseListeners.forEach(function(listener) {\n\t\t\t\t\tif (node instanceof ErrorNode || (node.isErrorNode !== undefined && node.isErrorNode())) {\n\t\t\t\t\t\tlistener.visitErrorNode(node);\n\t\t\t\t\t} else if (node instanceof TerminalNode) {\n\t\t\t\t\t\tlistener.visitTerminal(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn o;\n\t}\n\n\taddContextToParseTree() {\n\t\t// add current context to parent if we have a parent\n\t\tif (this._ctx.parentCtx !== null) {\n\t\t\tthis._ctx.parentCtx.addChild(this._ctx);\n\t\t}\n\t}\n\n\t/**\n\t * Always called by generated parsers upon entry to a rule. Access field\n\t * {@link //_ctx} get the current context.\n\t */\n\tenterRule(localctx, state, ruleIndex) {\n\t\tthis.state = state;\n\t\tthis._ctx = localctx;\n\t\tthis._ctx.start = this._input.LT(1);\n\t\tif (this.buildParseTrees) {\n\t\t\tthis.addContextToParseTree();\n\t\t}\n\t\tthis.triggerEnterRuleEvent();\n\t}\n\n\texitRule() {\n\t\tthis._ctx.stop = this._input.LT(-1);\n\t\t// trigger event on _ctx, before it reverts to parent\n\t\tthis.triggerExitRuleEvent();\n\t\tthis.state = this._ctx.invokingState;\n\t\tthis._ctx = this._ctx.parentCtx;\n\t}\n\n\tenterOuterAlt(localctx, altNum) {\n\t\tlocalctx.setAltNumber(altNum);\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif (this.buildParseTrees && this._ctx !== localctx) {\n\t\t\tif (this._ctx.parentCtx !== null) {\n\t\t\t\tthis._ctx.parentCtx.removeLastChild();\n\t\t\t\tthis._ctx.parentCtx.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\tthis._ctx = localctx;\n\t}\n\n\t/**\n\t * Get the precedence level for the top-most precedence rule.\n\t *\n\t * @return The precedence level for the top-most precedence rule, or -1 if\n\t * the parser context is not nested within a precedence rule.\n\t */\n\tgetPrecedence() {\n\t\tif (this._precedenceStack.length === 0) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn this._precedenceStack[this._precedenceStack.length-1];\n\t\t}\n\t}\n\n\tenterRecursionRule(localctx, state, ruleIndex, precedence) {\n\t   this.state = state;\n\t   this._precedenceStack.push(precedence);\n\t   this._ctx = localctx;\n\t   this._ctx.start = this._input.LT(1);\n\t   this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n   }\n\n\t// Like {@link //enterRule} but for recursive rules.\n\tpushNewRecursionContext(localctx, state, ruleIndex) {\n\t\tconst previous = this._ctx;\n\t\tprevious.parentCtx = localctx;\n\t\tprevious.invokingState = state;\n\t\tprevious.stop = this._input.LT(-1);\n\n\t\tthis._ctx = localctx;\n\t\tthis._ctx.start = previous.start;\n\t\tif (this.buildParseTrees) {\n\t\t\tthis._ctx.addChild(previous);\n\t\t}\n\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n\t}\n\n\tunrollRecursionContexts(parentCtx) {\n\t\tthis._precedenceStack.pop();\n\t\tthis._ctx.stop = this._input.LT(-1);\n\t\tconst retCtx = this._ctx; // save current ctx (return value)\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tconst parseListeners = this.getParseListeners();\n\t\tif (parseListeners !== null && parseListeners.length > 0) {\n\t\t\twhile (this._ctx !== parentCtx) {\n\t\t\t\tthis.triggerExitRuleEvent();\n\t\t\t\tthis._ctx = this._ctx.parentCtx;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._ctx = parentCtx;\n\t\t}\n\t\t// hook into tree\n\t\tretCtx.parentCtx = parentCtx;\n\t\tif (this.buildParseTrees && parentCtx !== null) {\n\t\t\t// add return ctx into invoking rule's tree\n\t\t\tparentCtx.addChild(retCtx);\n\t\t}\n\t}\n\n\tgetInvokingContext(ruleIndex) {\n\t\tlet ctx = this._ctx;\n\t\twhile (ctx !== null) {\n\t\t\tif (ctx.ruleIndex === ruleIndex) {\n\t\t\t\treturn ctx;\n\t\t\t}\n\t\t\tctx = ctx.parentCtx;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprecpred(localctx, precedence) {\n\t\treturn precedence >= this._precedenceStack[this._precedenceStack.length-1];\n\t}\n\n\tinContext(context) {\n\t\t// TODO: useful in parser?\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks whether or not {@code symbol} can follow the current state in the\n\t * ATN. The behavior of this method is equivalent to the following, but is\n\t * implemented such that the complete context-sensitive follow set does not\n\t * need to be explicitly constructed.\n\t *\n\t * <pre>\n\t * return getExpectedTokens().contains(symbol);\n\t * </pre>\n\t *\n\t * @param symbol the symbol type to check\n\t * @return {@code true} if {@code symbol} can follow the current state in\n\t * the ATN, otherwise {@code false}.\n\t */\n\tisExpectedToken(symbol) {\n\t\tconst atn = this._interp.atn;\n\t\tlet ctx = this._ctx;\n\t\tconst s = atn.states[this.state];\n\t\tlet following = atn.nextTokens(s);\n\t\tif (following.contains(symbol)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!following.contains(Token.EPSILON)) {\n\t\t\treturn false;\n\t\t}\n\t\twhile (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n\t\t\tconst invokingState = atn.states[ctx.invokingState];\n\t\t\tconst rt = invokingState.transitions[0];\n\t\t\tfollowing = atn.nextTokens(rt.followState);\n\t\t\tif (following.contains(symbol)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tctx = ctx.parentCtx;\n\t\t}\n\t\tif (following.contains(Token.EPSILON) && symbol === Token.EOF) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Computes the set of input symbols which could follow the current parser\n\t * state and context, as given by {@link //getState} and {@link //getContext},\n\t * respectively.\n\t *\n\t * @see ATN//getExpectedTokens(int, RuleContext)\n\t */\n\tgetExpectedTokens() {\n\t\treturn this._interp.atn.getExpectedTokens(this.state, this._ctx);\n\t}\n\n\tgetExpectedTokensWithinCurrentRule() {\n\t\tconst atn = this._interp.atn;\n\t\tconst s = atn.states[this.state];\n\t\treturn atn.nextTokens(s);\n\t}\n\n\t// Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.\n\tgetRuleIndex(ruleName) {\n\t\tconst ruleIndex = this.getRuleIndexMap()[ruleName];\n\t\tif (ruleIndex !== null) {\n\t\t\treturn ruleIndex;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/**\n\t * Return List&lt;String&gt; of the rule names in your parser instance\n\t * leading up to a call to the current rule. You could override if\n\t * you want more details such as the file/line info of where\n\t * in the ATN a rule is invoked.\n\t *\n\t * this is very useful for error messages.\n\t */\n\tgetRuleInvocationStack(p) {\n\t\tp = p || null;\n\t\tif (p === null) {\n\t\t\tp = this._ctx;\n\t\t}\n\t\tconst stack = [];\n\t\twhile (p !== null) {\n\t\t\t// compute what follows who invoked us\n\t\t\tconst ruleIndex = p.ruleIndex;\n\t\t\tif (ruleIndex < 0) {\n\t\t\t\tstack.push(\"n/a\");\n\t\t\t} else {\n\t\t\t\tstack.push(this.ruleNames[ruleIndex]);\n\t\t\t}\n\t\t\tp = p.parentCtx;\n\t\t}\n\t\treturn stack;\n\t}\n\n\t// For debugging and other purposes.\n\tgetDFAStrings() {\n\t\treturn this._interp.decisionToDFA.toString();\n\t}\n\n\t// For debugging and other purposes.\n\tdumpDFA() {\n\t\tlet seenOne = false;\n\t\tfor (let i = 0; i < this._interp.decisionToDFA.length; i++) {\n\t\t\tconst dfa = this._interp.decisionToDFA[i];\n\t\t\tif (dfa.states.length > 0) {\n\t\t\t\tif (seenOne) {\n\t\t\t\t\tconsole.log();\n\t\t\t\t}\n\t\t\t\tthis.printer.println(\"Decision \" + dfa.decision + \":\");\n\t\t\t\tthis.printer.print(dfa.toString(this.literalNames, this.symbolicNames));\n\t\t\t\tseenOne = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\t\"\t\t\tprinter = function() {\\r\\n\" +\n\t\t\"\t\t\t\tthis.println = function(s) { document.getElementById('output') += s + '\\\\n'; }\\r\\n\" +\n\t\t\"\t\t\t\tthis.print = function(s) { document.getElementById('output') += s; }\\r\\n\" +\n\t\t\"\t\t\t};\\r\\n\" +\n\t\t*/\n\tgetSourceName() {\n\t\treturn this._input.sourceName;\n\t}\n\n\t/**\n\t * During a parse is sometimes useful to listen in on the rule entry and exit\n\t * events as well as token matches. this is for quick and dirty debugging.\n\t */\n\tsetTrace(trace) {\n\t\tif (!trace) {\n\t\t\tthis.removeParseListener(this._tracer);\n\t\t\tthis._tracer = null;\n\t\t} else {\n\t\t\tif (this._tracer !== null) {\n\t\t\t\tthis.removeParseListener(this._tracer);\n\t\t\t}\n\t\t\tthis._tracer = new TraceListener(this);\n\t\t\tthis.addParseListener(this._tracer);\n\t\t}\n\t}\n}\n\n/**\n * this field maps from the serialized ATN string to the deserialized {@link\n * ATN} with\n * bypass alternatives.\n *\n * @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()\n */\nParser.bypassAltsAtnCache = {};\n\nmodule.exports = Parser;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst RuleContext = require('./RuleContext');\nconst Tree = require('./tree/Tree');\nconst INVALID_INTERVAL = Tree.INVALID_INTERVAL;\nconst TerminalNode = Tree.TerminalNode;\nconst TerminalNodeImpl = Tree.TerminalNodeImpl;\nconst ErrorNodeImpl = Tree.ErrorNodeImpl;\nconst Interval = require(\"./IntervalSet\").Interval;\n\n/**\n * A rule invocation record for parsing.\n *\n *  Contains all of the information about the current rule not stored in the\n *  RuleContext. It handles parse tree children list, Any ATN state\n *  tracing, and the default values available for rule indications:\n *  start, stop, rule index, current alt number, current\n *  ATN state.\n *\n *  Subclasses made for each rule and grammar track the parameters,\n *  return values, locals, and labels specific to that rule. These\n *  are the objects that are returned from rules.\n *\n *  Note text is not an actual field of a rule return value; it is computed\n *  from start and stop using the input stream's toString() method.  I\n *  could add a ctor to this so that we can pass in and store the input\n *  stream, but I'm not sure we want to do that.  It would seem to be undefined\n *  to get the .text property anyway if the rule matches tokens from multiple\n *  input streams.\n *\n *  I do not use getters for fields of objects that are used simply to\n *  group values such as this aggregate.  The getters/setters are there to\n *  satisfy the superclass interface.\n */\nclass ParserRuleContext extends RuleContext {\n\tconstructor(parent, invokingStateNumber) {\n\t\tparent = parent || null;\n\t\tinvokingStateNumber = invokingStateNumber || null;\n\t\tsuper(parent, invokingStateNumber);\n\t\tthis.ruleIndex = -1;\n\t\t/**\n\t\t * If we are debugging or building a parse tree for a visitor,\n\t\t * we need to track all of the tokens and rule invocations associated\n\t\t * with this rule's context. This is empty for parsing w/o tree constr.\n\t\t * operation because we don't the need to track the details about\n\t\t * how we parse this rule.\n\t\t */\n\t\tthis.children = null;\n\t\tthis.start = null;\n\t\tthis.stop = null;\n\t\t/**\n\t\t * The exception that forced this rule to return. If the rule successfully\n\t\t * completed, this is {@code null}.\n\t\t */\n\t\tthis.exception = null;\n\t}\n\n\t// COPY a ctx (I'm deliberately not using copy constructor)\n\tcopyFrom(ctx) {\n\t\t// from RuleContext\n\t\tthis.parentCtx = ctx.parentCtx;\n\t\tthis.invokingState = ctx.invokingState;\n\t\tthis.children = null;\n\t\tthis.start = ctx.start;\n\t\tthis.stop = ctx.stop;\n\t\t// copy any error nodes to alt label node\n\t\tif(ctx.children) {\n\t\t\tthis.children = [];\n\t\t\t// reset parent pointer for any error nodes\n\t\t\tctx.children.map(function(child) {\n\t\t\t\tif (child instanceof ErrorNodeImpl) {\n\t\t\t\t\tthis.children.push(child);\n\t\t\t\t\tchild.parentCtx = this;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t// Double dispatch methods for listeners\n\tenterRule(listener) {\n\t}\n\n\texitRule(listener) {\n\t}\n\n\t// Does not set parent link; other add methods do that\n\taddChild(child) {\n\t\tif (this.children === null) {\n\t\t\tthis.children = [];\n\t\t}\n\t\tthis.children.push(child);\n\t\treturn child;\n\t}\n\n\t/** Used by enterOuterAlt to toss out a RuleContext previously added as\n\t * we entered a rule. If we have // label, we will need to remove\n\t * generic ruleContext object.\n\t */\n\tremoveLastChild() {\n\t\tif (this.children !== null) {\n\t\t\tthis.children.pop();\n\t\t}\n\t}\n\n\taddTokenNode(token) {\n\t\tconst node = new TerminalNodeImpl(token);\n\t\tthis.addChild(node);\n\t\tnode.parentCtx = this;\n\t\treturn node;\n\t}\n\n\taddErrorNode(badToken) {\n\t\tconst node = new ErrorNodeImpl(badToken);\n\t\tthis.addChild(node);\n\t\tnode.parentCtx = this;\n\t\treturn node;\n\t}\n\n\tgetChild(i, type) {\n\t\ttype = type || null;\n\t\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\t\treturn null;\n\t\t}\n\t\tif (type === null) {\n\t\t\treturn this.children[i];\n\t\t} else {\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif(child instanceof type) {\n\t\t\t\t\tif(i===0) {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetToken(ttype, i) {\n\t\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\t\treturn null;\n\t\t}\n\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\tconst child = this.children[j];\n\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\tif(i===0) {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetTokens(ttype ) {\n\t\tif (this.children=== null) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst tokens = [];\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\t\ttokens.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokens;\n\t\t}\n\t}\n\n\tgetTypedRuleContext(ctxType, i) {\n\t\treturn this.getChild(i, ctxType);\n\t}\n\n\tgetTypedRuleContexts(ctxType) {\n\t\tif (this.children=== null) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst contexts = [];\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif (child instanceof ctxType) {\n\t\t\t\t\tcontexts.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn contexts;\n\t\t}\n\t}\n\n\tgetChildCount() {\n\t\tif (this.children=== null) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn this.children.length;\n\t\t}\n\t}\n\n\tgetSourceInterval() {\n\t\tif( this.start === null || this.stop === null) {\n\t\t\treturn INVALID_INTERVAL;\n\t\t} else {\n\t\t\treturn new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n\t\t}\n\t}\n}\n\nRuleContext.EMPTY = new ParserRuleContext();\n\nclass InterpreterRuleContext extends ParserRuleContext {\n\tconstructor(parent, invokingStateNumber, ruleIndex) {\n\t\tsuper(parent, invokingStateNumber);\n\t\tthis.ruleIndex = ruleIndex;\n\t}\n}\n\nmodule.exports = ParserRuleContext;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst RuleContext = require('./RuleContext');\nconst {Hash, Map, equalArrays} = require('./Utils');\n\nclass PredictionContext {\n\n\tconstructor(cachedHashCode) {\n\t\tthis.cachedHashCode = cachedHashCode;\n\t}\n\n\t/**\n\t * Stores the computed hash code of this {@link PredictionContext}. The hash\n\t * code is computed in parts to match the following reference algorithm.\n\t *\n\t * <pre>\n\t * private int referenceHashCode() {\n\t * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link\n\t * //INITIAL_HASH});\n\t *\n\t * for (int i = 0; i &lt; {@link //size()}; i++) {\n\t * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent\n\t * getParent}(i));\n\t * }\n\t *\n\t * for (int i = 0; i &lt; {@link //size()}; i++) {\n\t * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link\n\t * //getReturnState getReturnState}(i));\n\t * }\n\t *\n\t * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link\n\t * //size()});\n\t * return hash;\n\t * }\n\t * </pre>\n\t * This means only the {@link //EMPTY} context is in set.\n\t */\n\tisEmpty() {\n\t\treturn this === PredictionContext.EMPTY;\n\t}\n\n\thasEmptyPath() {\n\t\treturn this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;\n\t}\n\n\thashCode() {\n\t\treturn this.cachedHashCode;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.cachedHashCode);\n\t}\n}\n\n/**\n * Represents {@code $} in local context prediction, which means wildcard.\n * {@code//+x =//}.\n */\nPredictionContext.EMPTY = null;\n\n/**\n * Represents {@code $} in an array in full context mode, when {@code $}\n * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,\n * {@code $} = {@link //EMPTY_RETURN_STATE}.\n */\nPredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;\n\nPredictionContext.globalNodeCount = 1;\nPredictionContext.id = PredictionContext.globalNodeCount;\n\n\n/*\nfunction calculateHashString(parent, returnState) {\n\treturn \"\" + parent + returnState;\n}\n*/\n\n/**\n * Used to cache {@link PredictionContext} objects. Its used for the shared\n * context cash associated with contexts in DFA states. This cache\n * can be used for both lexers and parsers.\n */\nclass PredictionContextCache {\n\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * Add a context to the cache and return it. If the context already exists,\n\t * return that one instead and do not add a new context to the cache.\n\t * Protect shared cache from unsafe thread access.\n\t */\n\tadd(ctx) {\n\t\tif (ctx === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY;\n\t\t}\n\t\tconst existing = this.cache.get(ctx) || null;\n\t\tif (existing !== null) {\n\t\t\treturn existing;\n\t\t}\n\t\tthis.cache.put(ctx, ctx);\n\t\treturn ctx;\n\t}\n\n\tget(ctx) {\n\t\treturn this.cache.get(ctx) || null;\n\t}\n\n\tget length(){\n\t\treturn this.cache.length;\n\t}\n}\n\n\nclass SingletonPredictionContext extends PredictionContext {\n\n\tconstructor(parent, returnState) {\n\t\tlet hashCode = 0;\n\t\tconst hash = new Hash();\n\t\tif(parent !== null) {\n\t\t\thash.update(parent, returnState);\n\t\t} else {\n\t\t\thash.update(1);\n\t\t}\n\t\thashCode = hash.finish();\n\t\tsuper(hashCode);\n\t\tthis.parentCtx = parent;\n\t\tthis.returnState = returnState;\n\t}\n\n\tgetParent(index) {\n\t\treturn this.parentCtx;\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnState;\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof SingletonPredictionContext)) {\n\t\t\treturn false;\n\t\t} else if (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t} else {\n\t\t\tif(this.returnState !== other.returnState)\n\t\t\t\treturn false;\n\t\t\telse if(this.parentCtx==null)\n\t\t\t\treturn other.parentCtx==null\n\t\t\telse\n\t\t\t\treturn this.parentCtx.equals(other.parentCtx);\n\t\t}\n\t}\n\n\ttoString() {\n\t\tconst up = this.parentCtx === null ? \"\" : this.parentCtx.toString();\n\t\tif (up.length === 0) {\n\t\t\tif (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\treturn \"$\";\n\t\t\t} else {\n\t\t\t\treturn \"\" + this.returnState;\n\t\t\t}\n\t\t} else {\n\t\t\treturn \"\" + this.returnState + \" \" + up;\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn 1;\n\t}\n\n\tstatic create(parent, returnState) {\n\t\tif (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {\n\t\t\t// someone can pass in the bits of an array ctx that mean $\n\t\t\treturn PredictionContext.EMPTY;\n\t\t} else {\n\t\t\treturn new SingletonPredictionContext(parent, returnState);\n\t\t}\n\t}\n}\n\nclass EmptyPredictionContext extends SingletonPredictionContext {\n\n\tconstructor() {\n\t\tsuper(null, PredictionContext.EMPTY_RETURN_STATE);\n\t}\n\n\tisEmpty() {\n\t\treturn true;\n\t}\n\n\tgetParent(index) {\n\t\treturn null;\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnState;\n\t}\n\n\tequals(other) {\n\t\treturn this === other;\n\t}\n\n\ttoString() {\n\t\treturn \"$\";\n\t}\n}\n\n\nPredictionContext.EMPTY = new EmptyPredictionContext();\n\nclass ArrayPredictionContext extends PredictionContext {\n\n\tconstructor(parents, returnStates) {\n\t\t/**\n\t\t * Parent can be null only if full ctx mode and we make an array\n\t\t * from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using\n\t\t * null parent and\n\t\t * returnState == {@link //EMPTY_RETURN_STATE}.\n\t\t */\n\t\tconst h = new Hash();\n\t\th.update(parents, returnStates);\n\t\tconst hashCode = h.finish();\n\t\tsuper(hashCode);\n\t\tthis.parents = parents;\n\t\tthis.returnStates = returnStates;\n\t\treturn this;\n\t}\n\n\tisEmpty() {\n\t\t// since EMPTY_RETURN_STATE can only appear in the last position, we\n\t\t// don't need to verify that size==1\n\t\treturn this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;\n\t}\n\n\tgetParent(index) {\n\t\treturn this.parents[index];\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnStates[index];\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof ArrayPredictionContext)) {\n\t\t\treturn false;\n\t\t} else if (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t} else {\n\t\t\treturn equalArrays(this.returnStates, other.returnStates) &&\n\t\t\t\tequalArrays(this.parents, other.parents);\n\t\t}\n\t}\n\n\ttoString() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn \"[]\";\n\t\t} else {\n\t\t\tlet s = \"[\";\n\t\t\tfor (let i = 0; i < this.returnStates.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts = s + \", \";\n\t\t\t\t}\n\t\t\t\tif (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\ts = s + \"$\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts = s + this.returnStates[i];\n\t\t\t\tif (this.parents[i] !== null) {\n\t\t\t\t\ts = s + \" \" + this.parents[i];\n\t\t\t\t} else {\n\t\t\t\t\ts = s + \"null\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s + \"]\";\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.returnStates.length;\n\t}\n}\n\n\n/**\n * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.\n * Return {@link //EMPTY} if {@code outerContext} is empty or null.\n */\nfunction predictionContextFromRuleContext(atn, outerContext) {\n\tif (outerContext === undefined || outerContext === null) {\n\t\touterContext = RuleContext.EMPTY;\n\t}\n\t// if we are in RuleContext of start rule, s, then PredictionContext\n\t// is EMPTY. Nobody called us. (if we are empty, return empty)\n\tif (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {\n\t\treturn PredictionContext.EMPTY;\n\t}\n\t// If we have a parent, convert it to a PredictionContext graph\n\tconst parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);\n\tconst state = atn.states[outerContext.invokingState];\n\tconst transition = state.transitions[0];\n\treturn SingletonPredictionContext.create(parent, transition.followState.stateNumber);\n}\n/*\nfunction calculateListsHashString(parents, returnStates) {\n\tconst s = \"\";\n\tparents.map(function(p) {\n\t\ts = s + p;\n\t});\n\treturnStates.map(function(r) {\n\t\ts = s + r;\n\t});\n\treturn s;\n}\n*/\nfunction merge(a, b, rootIsWildcard, mergeCache) {\n\t// share same graph if both same\n\tif (a === b) {\n\t\treturn a;\n\t}\n\tif (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\treturn mergeSingletons(a, b, rootIsWildcard, mergeCache);\n\t}\n\t// At least one of a or b is array\n\t// If one is $ and rootIsWildcard, return $ as// wildcard\n\tif (rootIsWildcard) {\n\t\tif (a instanceof EmptyPredictionContext) {\n\t\t\treturn a;\n\t\t}\n\t\tif (b instanceof EmptyPredictionContext) {\n\t\t\treturn b;\n\t\t}\n\t}\n\t// convert singleton so both are arrays to normalize\n\tif (a instanceof SingletonPredictionContext) {\n\t\ta = new ArrayPredictionContext([a.getParent()], [a.returnState]);\n\t}\n\tif (b instanceof SingletonPredictionContext) {\n\t\tb = new ArrayPredictionContext([b.getParent()], [b.returnState]);\n\t}\n\treturn mergeArrays(a, b, rootIsWildcard, mergeCache);\n}\n\n/**\n * Merge two {@link SingletonPredictionContext} instances.\n *\n * <p>Stack tops equal, parents merge is same; return left graph.<br>\n * <embed src=\"images/SingletonMerge_SameRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Same stack top, parents differ; merge parents giving array node, then\n * remainders of those graphs. A new root node is created to point to the\n * merged parents.<br>\n * <embed src=\"images/SingletonMerge_SameRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to same parent. Make array node for the\n * root where both element in the root point to the same (original)\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to different parents. Make array node for\n * the root where each element points to the corresponding original\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n * @param mergeCache\n */\nfunction mergeSingletons(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tlet previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\n\tconst rootMerge = mergeRoot(a, b, rootIsWildcard);\n\tif (rootMerge !== null) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, rootMerge);\n\t\t}\n\t\treturn rootMerge;\n\t}\n\tif (a.returnState === b.returnState) {\n\t\tconst parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);\n\t\t// if parent is same as existing a or b parent or reduced to a parent,\n\t\t// return it\n\t\tif (parent === a.parentCtx) {\n\t\t\treturn a; // ax + bx = ax, if a=b\n\t\t}\n\t\tif (parent === b.parentCtx) {\n\t\t\treturn b; // ax + bx = bx, if a=b\n\t\t}\n\t\t// else: ax + ay = a'[x,y]\n\t\t// merge parents x and y, giving array node with x,y then remainders\n\t\t// of those graphs. dup a, a' points at merged array\n\t\t// new joined parent so create new singleton pointing to it, a'\n\t\tconst spc = SingletonPredictionContext.create(parent, a.returnState);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, spc);\n\t\t}\n\t\treturn spc;\n\t} else { // a != b payloads differ\n\t\t// see if we can collapse parents due to $+x parents if local ctx\n\t\tlet singleParent = null;\n\t\tif (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// bx =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [a,b]x\n\t\t\tsingleParent = a.parentCtx;\n\t\t}\n\t\tif (singleParent !== null) { // parents are same\n\t\t\t// sort payloads and use same parent\n\t\t\tconst payloads = [ a.returnState, b.returnState ];\n\t\t\tif (a.returnState > b.returnState) {\n\t\t\t\tpayloads[0] = b.returnState;\n\t\t\t\tpayloads[1] = a.returnState;\n\t\t\t}\n\t\t\tconst parents = [ singleParent, singleParent ];\n\t\t\tconst apc = new ArrayPredictionContext(parents, payloads);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, apc);\n\t\t\t}\n\t\t\treturn apc;\n\t\t}\n\t\t// parents differ and can't merge them. Just pack together\n\t\t// into array; can't merge.\n\t\t// ax + by = [ax,by]\n\t\tconst payloads = [ a.returnState, b.returnState ];\n\t\tlet parents = [ a.parentCtx, b.parentCtx ];\n\t\tif (a.returnState > b.returnState) { // sort by payload\n\t\t\tpayloads[0] = b.returnState;\n\t\t\tpayloads[1] = a.returnState;\n\t\t\tparents = [ b.parentCtx, a.parentCtx ];\n\t\t}\n\t\tconst a_ = new ArrayPredictionContext(parents, payloads);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a_);\n\t\t}\n\t\treturn a_;\n\t}\n}\n\n/**\n * Handle case where at least one of {@code a} or {@code b} is\n * {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used\n * to represent {@link //EMPTY}.\n *\n * <h2>Local-Context Merges</h2>\n *\n * <p>These local-context merge operations are used when {@code rootIsWildcard}\n * is true.</p>\n *\n * <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>\n * <embed src=\"images/LocalMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is\n * {@code //EMPTY}; return left graph.<br>\n * <embed src=\"images/LocalMerge_EmptyParent.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Special case of last merge if local context.<br>\n * <embed src=\"images/LocalMerge_DiffRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <h2>Full-Context Merges</h2>\n *\n * <p>These full-context merge operations are used when {@code rootIsWildcard}\n * is false.</p>\n *\n * <p><embed src=\"images/FullMerge_EmptyRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and\n * null parent).<br>\n * <embed src=\"images/FullMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p><embed src=\"images/FullMerge_SameRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n */\nfunction mergeRoot(a, b, rootIsWildcard) {\n\tif (rootIsWildcard) {\n\t\tif (a === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // // + b =//\n\t\t}\n\t\tif (b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // a +// =//\n\t\t}\n\t} else {\n\t\tif (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // $ + $ = $\n\t\t} else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]\n\t\t\tconst payloads = [ b.returnState,\n\t\t\t\t\tPredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tconst parents = [ b.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t} else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)\n\t\t\tconst payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tconst parents = [ a.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Merge two {@link ArrayPredictionContext} instances.\n *\n * <p>Different tops, different parents.<br>\n * <embed src=\"images/ArrayMerge_DiffTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, same parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSamePar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, different parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, all shared parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSharePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Equal tops, merge parents and reduce top to\n * {@link SingletonPredictionContext}.<br>\n * <embed src=\"images/ArrayMerge_EqualTop.svg\" type=\"image/svg+xml\"/></p>\n */\nfunction mergeArrays(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tlet previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\t// merge sorted payloads a + b => M\n\tlet i = 0; // walks a\n\tlet j = 0; // walks b\n\tlet k = 0; // walks target M array\n\n\tlet mergedReturnStates = [];\n\tlet mergedParents = [];\n\t// walk and merge to yield mergedParents, mergedReturnStates\n\twhile (i < a.returnStates.length && j < b.returnStates.length) {\n\t\tconst a_parent = a.parents[i];\n\t\tconst b_parent = b.parents[j];\n\t\tif (a.returnStates[i] === b.returnStates[j]) {\n\t\t\t// same payload (stack tops are equal), must yield merged singleton\n\t\t\tconst payload = a.returnStates[i];\n\t\t\t// $+$ = $\n\t\t\tconst bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&\n\t\t\t\t\ta_parent === null && b_parent === null;\n\t\t\tconst ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ax\n\t\t\tif (bothDollars || ax_ax) {\n\t\t\t\tmergedParents[k] = a_parent; // choose left\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t} else { // ax+ay -> a'[x,y]\n\t\t\t\tmergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t}\n\t\t\ti += 1; // hop over left one as usual\n\t\t\tj += 1; // but also skip one in right side since we merge\n\t\t} else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M\n\t\t\tmergedParents[k] = a_parent;\n\t\t\tmergedReturnStates[k] = a.returnStates[i];\n\t\t\ti += 1;\n\t\t} else { // b > a, copy b[j] to M\n\t\t\tmergedParents[k] = b_parent;\n\t\t\tmergedReturnStates[k] = b.returnStates[j];\n\t\t\tj += 1;\n\t\t}\n\t\tk += 1;\n\t}\n\t// copy over any payloads remaining in either array\n\tif (i < a.returnStates.length) {\n\t\tfor (let p = i; p < a.returnStates.length; p++) {\n\t\t\tmergedParents[k] = a.parents[p];\n\t\t\tmergedReturnStates[k] = a.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t} else {\n\t\tfor (let p = j; p < b.returnStates.length; p++) {\n\t\t\tmergedParents[k] = b.parents[p];\n\t\t\tmergedReturnStates[k] = b.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t}\n\t// trim merged if we combined a few that had same stack tops\n\tif (k < mergedParents.length) { // write index < last position; trim\n\t\tif (k === 1) { // for just one merged element, return singleton top\n\t\t\tconst a_ = SingletonPredictionContext.create(mergedParents[0],\n\t\t\t\t\tmergedReturnStates[0]);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, a_);\n\t\t\t}\n\t\t\treturn a_;\n\t\t}\n\t\tmergedParents = mergedParents.slice(0, k);\n\t\tmergedReturnStates = mergedReturnStates.slice(0, k);\n\t}\n\n\tconst M = new ArrayPredictionContext(mergedParents, mergedReturnStates);\n\n\t// if we created same array as a or b, return that instead\n\t// TODO: track whether this is possible above during merge sort for speed\n\tif (M === a) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a);\n\t\t}\n\t\treturn a;\n\t}\n\tif (M === b) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, b);\n\t\t}\n\t\treturn b;\n\t}\n\tcombineCommonParents(mergedParents);\n\n\tif (mergeCache !== null) {\n\t\tmergeCache.set(a, b, M);\n\t}\n\treturn M;\n}\n\n/**\n * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}\n * ones.\n */\nfunction combineCommonParents(parents) {\n\tconst uniqueParents = new Map();\n\n\tfor (let p = 0; p < parents.length; p++) {\n\t\tconst parent = parents[p];\n\t\tif (!(uniqueParents.containsKey(parent))) {\n\t\t\tuniqueParents.put(parent, parent);\n\t\t}\n\t}\n\tfor (let q = 0; q < parents.length; q++) {\n\t\tparents[q] = uniqueParents.get(parents[q]);\n\t}\n}\n\nfunction getCachedPredictionContext(context, contextCache, visited) {\n\tif (context.isEmpty()) {\n\t\treturn context;\n\t}\n\tlet existing = visited.get(context) || null;\n\tif (existing !== null) {\n\t\treturn existing;\n\t}\n\texisting = contextCache.get(context);\n\tif (existing !== null) {\n\t\tvisited.put(context, existing);\n\t\treturn existing;\n\t}\n\tlet changed = false;\n\tlet parents = [];\n\tfor (let i = 0; i < parents.length; i++) {\n\t\tconst parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);\n\t\tif (changed || parent !== context.getParent(i)) {\n\t\t\tif (!changed) {\n\t\t\t\tparents = [];\n\t\t\t\tfor (let j = 0; j < context.length; j++) {\n\t\t\t\t\tparents[j] = context.getParent(j);\n\t\t\t\t}\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tparents[i] = parent;\n\t\t}\n\t}\n\tif (!changed) {\n\t\tcontextCache.add(context);\n\t\tvisited.put(context, context);\n\t\treturn context;\n\t}\n\tlet updated = null;\n\tif (parents.length === 0) {\n\t\tupdated = PredictionContext.EMPTY;\n\t} else if (parents.length === 1) {\n\t\tupdated = SingletonPredictionContext.create(parents[0], context\n\t\t\t\t.getReturnState(0));\n\t} else {\n\t\tupdated = new ArrayPredictionContext(parents, context.returnStates);\n\t}\n\tcontextCache.add(updated);\n\tvisited.put(updated, updated);\n\tvisited.put(context, updated);\n\n\treturn updated;\n}\n\n// ter's recursive version of Sam's getAllNodes()\nfunction getAllContextNodes(context, nodes, visited) {\n\tif (nodes === null) {\n\t\tnodes = [];\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else if (visited === null) {\n\t\tvisited = new Map();\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else {\n\t\tif (context === null || visited.containsKey(context)) {\n\t\t\treturn nodes;\n\t\t}\n\t\tvisited.put(context, context);\n\t\tnodes.push(context);\n\t\tfor (let i = 0; i < context.length; i++) {\n\t\t\tgetAllContextNodes(context.getParent(i), nodes, visited);\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\nmodule.exports = {\n\tmerge,\n\tPredictionContext,\n\tPredictionContextCache,\n\tSingletonPredictionContext,\n\tpredictionContextFromRuleContext,\n\tgetCachedPredictionContext\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst {ConsoleErrorListener} = require('./error/ErrorListener');\nconst {ProxyErrorListener} = require('./error/ErrorListener');\n\nclass Recognizer {\n    constructor() {\n        this._listeners = [ ConsoleErrorListener.INSTANCE ];\n        this._interp = null;\n        this._stateNumber = -1;\n    }\n\n    checkVersion(toolVersion) {\n        const runtimeVersion = \"4.9.3\";\n        if (runtimeVersion!==toolVersion) {\n            console.log(\"ANTLR runtime and generated code versions disagree: \"+runtimeVersion+\"!=\"+toolVersion);\n        }\n    }\n\n    addErrorListener(listener) {\n        this._listeners.push(listener);\n    }\n\n    removeErrorListeners() {\n        this._listeners = [];\n    }\n\n    getLiteralNames() {\n        return Object.getPrototypeOf(this).constructor.literalNames || [];\n    }\n\n    getSymbolicNames() {\n        return Object.getPrototypeOf(this).constructor.symbolicNames || [];\n    }\n\n    getTokenNames() {\n        if(!this.tokenNames) {\n            const literalNames = this.getLiteralNames();\n            const symbolicNames = this.getSymbolicNames();\n            const length = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;\n            this.tokenNames = [];\n            for(let i=0; i<length; i++) {\n                this.tokenNames[i] = literalNames[i] || symbolicNames[i] || \"<INVALID\";\n            }\n        }\n        return this.tokenNames;\n    }\n\n    getTokenTypeMap() {\n        const tokenNames = this.getTokenNames();\n        if (tokenNames===null) {\n            throw(\"The current recognizer does not provide a list of token names.\");\n        }\n        let result = this.tokenTypeMapCache[tokenNames];\n        if(result===undefined) {\n            result = tokenNames.reduce(function(o, k, i) { o[k] = i; });\n            result.EOF = Token.EOF;\n            this.tokenTypeMapCache[tokenNames] = result;\n        }\n        return result;\n    }\n\n    /**\n     * Get a map from rule names to rule indexes.\n     * <p>Used for XPath and tree pattern compilation.</p>\n     */\n    getRuleIndexMap() {\n        const ruleNames = this.ruleNames;\n        if (ruleNames===null) {\n            throw(\"The current recognizer does not provide a list of rule names.\");\n        }\n        let result = this.ruleIndexMapCache[ruleNames]; // todo: should it be Recognizer.ruleIndexMapCache ?\n        if(result===undefined) {\n            result = ruleNames.reduce(function(o, k, i) { o[k] = i; });\n            this.ruleIndexMapCache[ruleNames] = result;\n        }\n        return result;\n    }\n\n    getTokenType(tokenName) {\n        const ttype = this.getTokenTypeMap()[tokenName];\n        if (ttype !==undefined) {\n            return ttype;\n        } else {\n            return Token.INVALID_TYPE;\n        }\n    }\n\n    // What is the error header, normally line/character position information?\n    getErrorHeader(e) {\n        const line = e.getOffendingToken().line;\n        const column = e.getOffendingToken().column;\n        return \"line \" + line + \":\" + column;\n    }\n\n    /**\n     * How should a token be displayed in an error message? The default\n     * is to display just the text, but during development you might\n     * want to have a lot of information spit out.  Override in that case\n     * to use t.toString() (which, for CommonToken, dumps everything about\n     * the token). This is better than forcing you to override a method in\n     * your token objects because you don't have to go modify your lexer\n     * so that it creates a new Java type.\n     *\n     * @deprecated This method is not called by the ANTLR 4 Runtime. Specific\n     * implementations of {@link ANTLRErrorStrategy} may provide a similar\n     * feature when necessary. For example, see\n     * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/\n    getTokenErrorDisplay(t) {\n        if (t===null) {\n            return \"<no token>\";\n        }\n        let s = t.text;\n        if (s===null) {\n            if (t.type===Token.EOF) {\n                s = \"<EOF>\";\n            } else {\n                s = \"<\" + t.type + \">\";\n            }\n        }\n        s = s.replace(\"\\n\",\"\\\\n\").replace(\"\\r\",\"\\\\r\").replace(\"\\t\",\"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n\n    getErrorListenerDispatch() {\n        return new ProxyErrorListener(this._listeners);\n    }\n\n    /**\n     * subclass needs to override these if there are sempreds or actions\n     * that the ATN interp needs to execute\n     */\n    sempred(localctx, ruleIndex, actionIndex) {\n        return true;\n    }\n\n    precpred(localctx , precedence) {\n        return true;\n    }\n\n    get state(){\n        return this._stateNumber;\n    }\n\n    set state(state) {\n        this._stateNumber = state;\n    }\n}\n\nRecognizer.tokenTypeMapCache = {};\nRecognizer.ruleIndexMapCache = {};\n\nmodule.exports = Recognizer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {RuleNode} = require('./tree/Tree');\nconst {INVALID_INTERVAL} = require('./tree/Tree');\nconst Trees = require('./tree/Trees');\n\nclass RuleContext extends RuleNode {\n\t/** A rule context is a record of a single rule invocation. It knows\n\t * which context invoked it, if any. If there is no parent context, then\n\t * naturally the invoking state is not valid.  The parent link\n\t * provides a chain upwards from the current rule invocation to the root\n\t * of the invocation tree, forming a stack. We actually carry no\n\t * information about the rule associated with this context (except\n\t * when parsing). We keep only the state number of the invoking state from\n\t * the ATN submachine that invoked this. Contrast this with the s\n\t * pointer inside ParserRuleContext that tracks the current state\n\t * being \"executed\" for the current rule.\n\t *\n\t * The parent contexts are useful for computing lookahead sets and\n\t * getting error information.\n\t *\n\t * These objects are used during parsing and prediction.\n\t * For the special case of parsers, we use the subclass\n\t * ParserRuleContext.\n\t *\n\t * @see ParserRuleContext\n\t */\n\tconstructor(parent, invokingState) {\n\t\t// What context invoked this rule?\n\t\tsuper();\n\t\tthis.parentCtx = parent || null;\n\t\t/**\n\t\t * What state invoked the rule associated with this context?\n\t\t * The \"return address\" is the followState of invokingState\n\t\t * If parent is null, this should be -1.\n\t\t */\n\t\tthis.invokingState = invokingState || -1;\n\t}\n\n\tdepth() {\n\t\tlet n = 0;\n\t\tlet p = this;\n\t\twhile (p !== null) {\n\t\t\tp = p.parentCtx;\n\t\t\tn += 1;\n\t\t}\n\t\treturn n;\n\t}\n\n\t/**\n\t * A context is empty if there is no invoking state; meaning nobody call\n\t * current context.\n\t */\n\tisEmpty() {\n\t\treturn this.invokingState === -1;\n\t}\n\n// satisfy the ParseTree / SyntaxTree interface\n\tgetSourceInterval() {\n\t\treturn INVALID_INTERVAL;\n\t}\n\n\tgetRuleContext() {\n\t\treturn this;\n\t}\n\n\tgetPayload() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the combined text of all child nodes. This method only considers\n\t * tokens which have been added to the parse tree.\n\t * <p>\n\t * Since tokens on hidden channels (e.g. whitespace or comments) are not\n\t * added to the parse trees, they will not appear in the output of this\n\t * method.\n\t */\n\tgetText() {\n\t\tif (this.getChildCount() === 0) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn this.children.map(function(child) {\n\t\t\t\treturn child.getText();\n\t\t\t}).join(\"\");\n\t\t}\n\t}\n\n\t/**\n\t * For rule associated with this parse tree internal node, return\n\t * the outer alternative number used to match the input. Default\n\t * implementation does not compute nor store this alt num. Create\n\t * a subclass of ParserRuleContext with backing field and set\n\t * option contextSuperClass.\n\t * to set it.\n\t */\n\tgetAltNumber() {\n\t    // use constant value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n\t    return 0;\n    }\n\n\t/**\n\t * Set the outer alternative number for this context node. Default\n\t * implementation does nothing to avoid backing field overhead for\n\t * trees that don't need it.  Create\n\t * a subclass of ParserRuleContext with backing field and set\n\t * option contextSuperClass.\n\t */\n\tsetAltNumber(altNumber) { }\n\n\tgetChild(i) {\n\t\treturn null;\n\t}\n\n\tgetChildCount() {\n\t\treturn 0;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitChildren(this);\n\t}\n\n\t/**\n\t * Print out a whole tree, not just a node, in LISP format\n\t * (root child1 .. childN). Print just a node if this is a leaf.\n\t */\n\ttoStringTree(ruleNames, recog) {\n\t\treturn Trees.toStringTree(this, ruleNames, recog);\n\t}\n\n\ttoString(ruleNames, stop) {\n\t\truleNames = ruleNames || null;\n\t\tstop = stop || null;\n\t\tlet p = this;\n\t\tlet s = \"[\";\n\t\twhile (p !== null && p !== stop) {\n\t\t\tif (ruleNames === null) {\n\t\t\t\tif (!p.isEmpty()) {\n\t\t\t\t\ts += p.invokingState;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst ri = p.ruleIndex;\n\t\t\t\tconst ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]\n\t\t\t\t\t\t: \"\" + ri;\n\t\t\t\ts += ruleName;\n\t\t\t}\n\t\t\tif (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {\n\t\t\t\ts += \" \";\n\t\t\t}\n\t\t\tp = p.parentCtx;\n\t\t}\n\t\ts += \"]\";\n\t\treturn s;\n\t}\n}\n\nmodule.exports = RuleContext;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * A token has properties: text, type, line, character position in the line\n * (so we can ignore tabs), token channel, index, and source from which\n * we obtained this token.\n */\nclass Token {\n\tconstructor() {\n\t\tthis.source = null;\n\t\tthis.type = null; // token type of the token\n\t\tthis.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL\n\t\tthis.start = null; // optional; return -1 if not implemented.\n\t\tthis.stop = null; // optional; return -1 if not implemented.\n\t\tthis.tokenIndex = null; // from 0..n-1 of the token object in the input stream\n\t\tthis.line = null; // line=1..n of the 1st character\n\t\tthis.column = null; // beginning of the line at which it occurs, 0..n-1\n\t\tthis._text = null; // text of the token.\n\t}\n\n\tgetTokenSource() {\n\t\treturn this.source[0];\n\t}\n\n\tgetInputStream() {\n\t\treturn this.source[1];\n\t}\n\n\tget text(){\n\t\treturn this._text;\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\nToken.INVALID_TYPE = 0;\n\n/**\n * During lookahead operations, this \"token\" signifies we hit rule end ATN state\n * and did not follow it despite needing to.\n */\nToken.EPSILON = -2;\n\nToken.MIN_USER_TOKEN_TYPE = 1;\n\nToken.EOF = -1;\n\n/**\n * All tokens go to the parser (unless skip() is called in that rule)\n * on a particular \"channel\". The parser tunes to a particular channel\n * so that whitespace etc... can go to the parser on a \"hidden\" channel.\n */\nToken.DEFAULT_CHANNEL = 0;\n\n/**\n * Anything on different channel than DEFAULT_CHANNEL is not parsed\n * by parser.\n */\nToken.HIDDEN_CHANNEL = 1;\n\n\nclass CommonToken extends Token {\n\tconstructor(source, type, channel, start, stop) {\n\t\tsuper();\n\t\tthis.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;\n\t\tthis.type = type !== undefined ? type : null;\n\t\tthis.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;\n\t\tthis.start = start !== undefined ? start : -1;\n\t\tthis.stop = stop !== undefined ? stop : -1;\n\t\tthis.tokenIndex = -1;\n\t\tif (this.source[0] !== null) {\n\t\t\tthis.line = source[0].line;\n\t\t\tthis.column = source[0].column;\n\t\t} else {\n\t\t\tthis.column = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n\t *\n\t * <p>\n\t * If {@code oldToken} is also a {@link CommonToken} instance, the newly\n\t * constructed token will share a reference to the {@link //text} field and\n\t * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will\n\t * be assigned the result of calling {@link //getText}, and {@link //source}\n\t * will be constructed from the result of {@link Token//getTokenSource} and\n\t * {@link Token//getInputStream}.</p>\n\t *\n\t * @param oldToken The token to copy.\n\t */\n\tclone() {\n\t\tconst t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);\n\t\tt.tokenIndex = this.tokenIndex;\n\t\tt.line = this.line;\n\t\tt.column = this.column;\n\t\tt.text = this.text;\n\t\treturn t;\n\t}\n\n\ttoString() {\n\t\tlet txt = this.text;\n\t\tif (txt !== null) {\n\t\t\ttxt = txt.replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\");\n\t\t} else {\n\t\t\ttxt = \"<no text>\";\n\t\t}\n\t\treturn \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" +\n\t\t\t\ttxt + \"',<\" + this.type + \">\" +\n\t\t\t\t(this.channel > 0 ? \",channel=\" + this.channel : \"\") + \",\" +\n\t\t\t\tthis.line + \":\" + this.column + \"]\";\n\t}\n\n\tget text(){\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t}\n\t\tconst input = this.getInputStream();\n\t\tif (input === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst n = input.size;\n\t\tif (this.start < n && this.stop < n) {\n\t\t\treturn input.getText(this.start, this.stop);\n\t\t} else {\n\t\t\treturn \"<EOF>\";\n\t\t}\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\n/**\n * An empty {@link Pair} which is used as the default value of\n * {@link //source} for tokens that do not have a source.\n */\nCommonToken.EMPTY_SOURCE = [ null, null ];\n\nmodule.exports = {\n\tToken,\n\tCommonToken\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nfunction valueToString(v) {\n    return v === null ? \"null\" : v;\n}\n\nfunction arrayToString(a) {\n    return Array.isArray(a) ? (\"[\" + a.map(valueToString).join(\", \") + \"]\") : \"null\";\n}\n\nString.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));\n\nString.prototype.hashCode = function () {\n    const key = this.toString();\n    let h1b, k1;\n\n    const remainder = key.length & 3; // key.length % 4\n    const bytes = key.length - remainder;\n    let h1 = String.prototype.seed;\n    const c1 = 0xcc9e2d51;\n    const c2 = 0x1b873593;\n    let i = 0;\n\n    while (i < bytes) {\n        k1 =\n            ((key.charCodeAt(i) & 0xff)) |\n            ((key.charCodeAt(++i) & 0xff) << 8) |\n            ((key.charCodeAt(++i) & 0xff) << 16) |\n            ((key.charCodeAt(++i) & 0xff) << 24);\n        ++i;\n\n        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n\n    k1 = 0;\n\n    switch (remainder) {\n        case 3:\n            k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            k1 ^= (key.charCodeAt(i) & 0xff);\n\n            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n            h1 ^= k1;\n    }\n\n    h1 ^= key.length;\n\n    h1 ^= h1 >>> 16;\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n    h1 ^= h1 >>> 13;\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n    h1 ^= h1 >>> 16;\n\n    return h1 >>> 0;\n};\n\nfunction standardEqualsFunction(a, b) {\n    return a ? a.equals(b) : a==b;\n}\n\nfunction standardHashCodeFunction(a) {\n    return a ? a.hashCode() : -1;\n}\n\nclass Set {\n    constructor(hashFunction, equalsFunction) {\n        this.data = {};\n        this.hashFunction = hashFunction || standardHashCodeFunction;\n        this.equalsFunction = equalsFunction || standardEqualsFunction;\n    }\n\n    add(value) {\n        const hash = this.hashFunction(value);\n        const key = \"hash_\" + hash;\n        if (key in this.data) {\n            const values = this.data[key];\n            for (let i = 0; i < values.length; i++) {\n                if (this.equalsFunction(value, values[i])) {\n                    return values[i];\n                }\n            }\n            values.push(value);\n            return value;\n        } else {\n            this.data[key] = [value];\n            return value;\n        }\n    }\n\n    contains(value) {\n        return this.get(value) != null;\n    }\n\n    get(value) {\n        const hash = this.hashFunction(value);\n        const key = \"hash_\" + hash;\n        if (key in this.data) {\n            const values = this.data[key];\n            for (let i = 0; i < values.length; i++) {\n                if (this.equalsFunction(value, values[i])) {\n                    return values[i];\n                }\n            }\n        }\n        return null;\n    }\n\n    values() {\n        let l = [];\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l.concat(this.data[key]);\n            }\n        }\n        return l;\n    }\n\n    toString() {\n        return arrayToString(this.values());\n    }\n\n    get length(){\n        let l = 0;\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l + this.data[key].length;\n            }\n        }\n        return l;\n    }\n}\n\n\nclass BitSet {\n    constructor() {\n        this.data = [];\n    }\n\n    add(value) {\n        this.data[value] = true;\n    }\n\n    or(set) {\n        const bits = this;\n        Object.keys(set.data).map(function (alt) {\n            bits.add(alt);\n        });\n    }\n\n    remove(value) {\n        delete this.data[value];\n    }\n\n    contains(value) {\n        return this.data[value] === true;\n    }\n\n    values() {\n        return Object.keys(this.data);\n    }\n\n    minValue() {\n        return Math.min.apply(null, this.values());\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        hash.update(this.values());\n        return hash.finish();\n    }\n\n    equals(other) {\n        if (!(other instanceof BitSet)) {\n            return false;\n        }\n        return this.hashCode() === other.hashCode();\n    }\n\n    toString() {\n        return \"{\" + this.values().join(\", \") + \"}\";\n    }\n\n    get length(){\n        return this.values().length;\n    }\n}\n\n\nclass Map {\n    constructor(hashFunction, equalsFunction) {\n        this.data = {};\n        this.hashFunction = hashFunction || standardHashCodeFunction;\n        this.equalsFunction = equalsFunction || standardEqualsFunction;\n    }\n\n    put(key, value) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if (hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key)) {\n                    const oldValue = entry.value;\n                    entry.value = value;\n                    return oldValue;\n                }\n            }\n            entries.push({key:key, value:value});\n            return value;\n        } else {\n            this.data[hashKey] = [{key:key, value:value}];\n            return value;\n        }\n    }\n\n    containsKey(key) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if(hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    get(key) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if(hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key))\n                    return entry.value;\n            }\n        }\n        return null;\n    }\n\n    entries() {\n        let l = [];\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l.concat(this.data[key]);\n            }\n        }\n        return l;\n    }\n\n    getKeys() {\n        return this.entries().map(function(e) {\n            return e.key;\n        });\n    }\n\n    getValues() {\n        return this.entries().map(function(e) {\n                return e.value;\n        });\n    }\n\n    toString() {\n        const ss = this.entries().map(function(entry) {\n            return '{' + entry.key + ':' + entry.value + '}';\n        });\n        return '[' + ss.join(\", \") + ']';\n    }\n\n    get length(){\n        let l = 0;\n        for (const hashKey in this.data) {\n            if (hashKey.indexOf(\"hash_\") === 0) {\n                l = l + this.data[hashKey].length;\n            }\n        }\n        return l;\n    }\n}\n\n\nclass AltDict {\n    constructor() {\n        this.data = {};\n    }\n\n    get(key) {\n        key = \"k-\" + key;\n        if (key in this.data) {\n            return this.data[key];\n        } else {\n            return null;\n        }\n    }\n\n    put(key, value) {\n        key = \"k-\" + key;\n        this.data[key] = value;\n    }\n\n    values() {\n        const data = this.data;\n        const keys = Object.keys(this.data);\n        return keys.map(function (key) {\n            return data[key];\n        });\n    }\n}\n\n\nclass DoubleDict {\n    constructor(defaultMapCtor) {\n        this.defaultMapCtor = defaultMapCtor || Map;\n        this.cacheMap = new this.defaultMapCtor();\n    }\n\n    get(a, b) {\n        const d = this.cacheMap.get(a) || null;\n        return d === null ? null : (d.get(b) || null);\n    }\n\n    set(a, b, o) {\n        let d = this.cacheMap.get(a) || null;\n        if (d === null) {\n            d = new this.defaultMapCtor();\n            this.cacheMap.put(a, d);\n        }\n        d.put(b, o);\n    }\n}\n\nclass Hash {\n    constructor() {\n        this.count = 0;\n        this.hash = 0;\n    }\n\n    update() {\n        for(let i=0;i<arguments.length;i++) {\n            const value = arguments[i];\n            if (value == null)\n                continue;\n            if(Array.isArray(value))\n                this.update.apply(this, value);\n            else {\n                let k = 0;\n                switch (typeof(value)) {\n                    case 'undefined':\n                    case 'function':\n                        continue;\n                    case 'number':\n                    case 'boolean':\n                        k = value;\n                        break;\n                    case 'string':\n                        k = value.hashCode();\n                        break;\n                    default:\n                        if(value.updateHashCode)\n                            value.updateHashCode(this);\n                        else\n                            console.log(\"No updateHashCode for \" + value.toString())\n                        continue;\n                }\n                k = k * 0xCC9E2D51;\n                k = (k << 15) | (k >>> (32 - 15));\n                k = k * 0x1B873593;\n                this.count = this.count + 1;\n                let hash = this.hash ^ k;\n                hash = (hash << 13) | (hash >>> (32 - 13));\n                hash = hash * 5 + 0xE6546B64;\n                this.hash = hash;\n            }\n        }\n    }\n\n    finish() {\n        let hash = this.hash ^ (this.count * 4);\n        hash = hash ^ (hash >>> 16);\n        hash = hash * 0x85EBCA6B;\n        hash = hash ^ (hash >>> 13);\n        hash = hash * 0xC2B2AE35;\n        hash = hash ^ (hash >>> 16);\n        return hash;\n    }\n}\n\nfunction hashStuff() {\n    const hash = new Hash();\n    hash.update.apply(hash, arguments);\n    return hash.finish();\n}\n\n\nfunction escapeWhitespace(s, escapeSpaces) {\n    s = s.replace(/\\t/g, \"\\\\t\")\n         .replace(/\\n/g, \"\\\\n\")\n         .replace(/\\r/g, \"\\\\r\");\n    if (escapeSpaces) {\n        s = s.replace(/ /g, \"\\u00B7\");\n    }\n    return s;\n}\n\nfunction titleCase(str) {\n    return str.replace(/\\w\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1);\n    });\n}\n\nfunction equalArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b))\n        return false;\n    if (a === b)\n        return true;\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] === b[i])\n            continue;\n        if (!a[i].equals || !a[i].equals(b[i]))\n            return false;\n    }\n    return true;\n}\n\nmodule.exports = {\n    Hash,\n    Set,\n    Map,\n    BitSet,\n    AltDict,\n    DoubleDict,\n    hashStuff,\n    escapeWhitespace,\n    arrayToString,\n    titleCase,\n    equalArrays\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst LL1Analyzer = require('./../LL1Analyzer');\nconst {IntervalSet} = require('./../IntervalSet');\nconst {Token} = require('./../Token');\n\nclass ATN {\n\n    constructor(grammarType , maxTokenType) {\n        /**\n         * Used for runtime deserialization of ATNs from strings\n         * The type of the ATN.\n        */\n        this.grammarType = grammarType;\n        // The maximum value for any symbol recognized by a transition in the ATN.\n        this.maxTokenType = maxTokenType;\n        this.states = [];\n        /**\n         * Each subrule/rule is a decision point and we must track them so we\n         * can go back later and build DFA predictors for them.  This includes\n         * all the rules, subrules, optional blocks, ()+, ()* etc...\n         */\n        this.decisionToState = [];\n        // Maps from rule index to starting state number.\n        this.ruleToStartState = [];\n        // Maps from rule index to stop state number.\n        this.ruleToStopState = null;\n        this.modeNameToStartState = {};\n        /**\n         * For lexer ATNs, this maps the rule index to the resulting token type.\n         * For parser ATNs, this maps the rule index to the generated bypass token\n         * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}\n         * deserialization option was specified; otherwise, this is {@code null}\n         */\n        this.ruleToTokenType = null;\n        /**\n         * For lexer ATNs, this is an array of {@link LexerAction} objects which may\n         * be referenced by action transitions in the ATN\n         */\n        this.lexerActions = null;\n        this.modeToStartState = [];\n    }\n\n    /**\n     * Compute the set of valid tokens that can occur starting in state {@code s}.\n     * If {@code ctx} is null, the set of tokens will not include what can follow\n     * the rule surrounding {@code s}. In other words, the set will be\n     * restricted to tokens reachable staying within {@code s}'s rule\n     */\n    nextTokensInContext(s, ctx) {\n        const anal = new LL1Analyzer(this);\n        return anal.LOOK(s, null, ctx);\n    }\n\n    /**\n     * Compute the set of valid tokens that can occur starting in {@code s} and\n     * staying in same rule. {@link Token//EPSILON} is in set if we reach end of\n     * rule\n     */\n    nextTokensNoContext(s) {\n        if (s.nextTokenWithinRule !== null ) {\n            return s.nextTokenWithinRule;\n        }\n        s.nextTokenWithinRule = this.nextTokensInContext(s, null);\n        s.nextTokenWithinRule.readOnly = true;\n        return s.nextTokenWithinRule;\n    }\n\n    nextTokens(s, ctx) {\n        if ( ctx===undefined ) {\n            return this.nextTokensNoContext(s);\n        } else {\n            return this.nextTokensInContext(s, ctx);\n        }\n    }\n\n    addState(state) {\n        if ( state !== null ) {\n            state.atn = this;\n            state.stateNumber = this.states.length;\n        }\n        this.states.push(state);\n    }\n\n    removeState(state) {\n        this.states[state.stateNumber] = null; // just free mem, don't shift states in list\n    }\n\n    defineDecisionState(s) {\n        this.decisionToState.push(s);\n        s.decision = this.decisionToState.length-1;\n        return s.decision;\n    }\n\n    getDecisionState(decision) {\n        if (this.decisionToState.length===0) {\n            return null;\n        } else {\n            return this.decisionToState[decision];\n        }\n    }\n\n    /**\n     * Computes the set of input symbols which could follow ATN state number\n     * {@code stateNumber} in the specified full {@code context}. This method\n     * considers the complete parser context, but does not evaluate semantic\n     * predicates (i.e. all predicates encountered during the calculation are\n     * assumed true). If a path in the ATN exists from the starting state to the\n     * {@link RuleStopState} of the outermost context without matching any\n     * symbols, {@link Token//EOF} is added to the returned set.\n     *\n     * <p>If {@code context} is {@code null}, it is treated as\n     * {@link ParserRuleContext//EMPTY}.</p>\n     *\n     * @param stateNumber the ATN state number\n     * @param ctx the full parse context\n     *\n     * @return {IntervalSet} The set of potentially valid input symbols which could follow the\n     * specified state in the specified context.\n     *\n     * @throws IllegalArgumentException if the ATN does not contain a state with\n     * number {@code stateNumber}\n     */\n    getExpectedTokens(stateNumber, ctx ) {\n        if ( stateNumber < 0 || stateNumber >= this.states.length ) {\n            throw(\"Invalid state number.\");\n        }\n        const s = this.states[stateNumber];\n        let following = this.nextTokens(s);\n        if (!following.contains(Token.EPSILON)) {\n            return following;\n        }\n        const expected = new IntervalSet();\n        expected.addSet(following);\n        expected.removeOne(Token.EPSILON);\n        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n            const invokingState = this.states[ctx.invokingState];\n            const rt = invokingState.transitions[0];\n            following = this.nextTokens(rt.followState);\n            expected.addSet(following);\n            expected.removeOne(Token.EPSILON);\n            ctx = ctx.parentCtx;\n        }\n        if (following.contains(Token.EPSILON)) {\n            expected.addOne(Token.EOF);\n        }\n        return expected;\n    }\n}\n\nATN.INVALID_ALT_NUMBER = 0;\n\nmodule.exports = ATN;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {DecisionState} = require('./ATNState');\nconst {SemanticContext} = require('./SemanticContext');\nconst {Hash} = require(\"../Utils\");\n\n\nfunction checkParams(params, isCfg) {\n\tif(params===null) {\n\t\tconst result = { state:null, alt:null, context:null, semanticContext:null };\n\t\tif(isCfg) {\n\t\t\tresult.reachesIntoOuterContext = 0;\n\t\t}\n\t\treturn result;\n\t} else {\n\t\tconst props = {};\n\t\tprops.state = params.state || null;\n\t\tprops.alt = (params.alt === undefined) ? null : params.alt;\n\t\tprops.context = params.context || null;\n\t\tprops.semanticContext = params.semanticContext || null;\n\t\tif(isCfg) {\n\t\t\tprops.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;\n\t\t\tprops.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;\n\t\t}\n\t\treturn props;\n\t}\n}\n\nclass ATNConfig {\n    /**\n     * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).\n     * The syntactic context is a graph-structured stack node whose\n     * path(s) to the root is the rule invocation(s)\n     * chain used to arrive at the state.  The semantic context is\n     * the tree of semantic predicates encountered before reaching\n     * an ATN state\n     */\n    constructor(params, config) {\n        this.checkContext(params, config);\n        params = checkParams(params);\n        config = checkParams(config, true);\n        // The ATN state associated with this configuration///\n        this.state = params.state!==null ? params.state : config.state;\n        // What alt (or lexer rule) is predicted by this configuration///\n        this.alt = params.alt!==null ? params.alt : config.alt;\n        /**\n         * The stack of invoking states leading to the rule/states associated\n         * with this config.  We track only those contexts pushed during\n         * execution of the ATN simulator\n         */\n        this.context = params.context!==null ? params.context : config.context;\n        this.semanticContext = params.semanticContext!==null ? params.semanticContext :\n            (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);\n        // TODO: make it a boolean then\n        /**\n         * We cannot execute predicates dependent upon local context unless\n         * we know for sure we are in the correct context. Because there is\n         * no way to do this efficiently, we simply cannot evaluate\n         * dependent predicates unless we are in the rule that initially\n         * invokes the ATN simulator.\n         * closure() tracks the depth of how far we dip into the\n         * outer context: depth &gt; 0.  Note that it may not be totally\n         * accurate depth since I don't ever decrement\n         */\n        this.reachesIntoOuterContext = config.reachesIntoOuterContext;\n        this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;\n    }\n\n    checkContext(params, config) {\n        if((params.context===null || params.context===undefined) &&\n                (config===null || config.context===null || config.context===undefined)) {\n            this.context = null;\n        }\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        this.updateHashCode(hash);\n        return hash.finish();\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);\n    }\n\n    /**\n     * An ATN configuration is equal to another if both have\n     * the same state, they predict the same alternative, and\n     * syntactic/semantic contexts are the same\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof ATNConfig)) {\n            return false;\n        } else {\n            return this.state.stateNumber===other.state.stateNumber &&\n                this.alt===other.alt &&\n                (this.context===null ? other.context===null : this.context.equals(other.context)) &&\n                this.semanticContext.equals(other.semanticContext) &&\n                this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;\n        }\n    }\n\n    hashCodeForConfigSet() {\n        const hash = new Hash();\n        hash.update(this.state.stateNumber, this.alt, this.semanticContext);\n        return hash.finish();\n    }\n\n    equalsForConfigSet(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof ATNConfig)) {\n            return false;\n        } else {\n            return this.state.stateNumber===other.state.stateNumber &&\n                this.alt===other.alt &&\n                this.semanticContext.equals(other.semanticContext);\n        }\n    }\n\n    toString() {\n        return \"(\" + this.state + \",\" + this.alt +\n            (this.context!==null ? \",[\" + this.context.toString() + \"]\" : \"\") +\n            (this.semanticContext !== SemanticContext.NONE ?\n                    (\",\" + this.semanticContext.toString())\n                    : \"\") +\n            (this.reachesIntoOuterContext>0 ?\n                    (\",up=\" + this.reachesIntoOuterContext)\n                    : \"\") + \")\";\n    }\n}\n\n\nclass LexerATNConfig extends ATNConfig {\n    constructor(params, config) {\n        super(params, config);\n\n        // This is the backing field for {@link //getLexerActionExecutor}.\n        const lexerActionExecutor = params.lexerActionExecutor || null;\n        this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);\n        this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;\n        this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;\n        this.equalsForConfigSet = LexerATNConfig.prototype.equals;\n        return this;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);\n    }\n\n    equals(other) {\n        return this === other ||\n                (other instanceof LexerATNConfig &&\n                this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision &&\n                (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&\n                super.equals(other));\n    }\n\n    checkNonGreedyDecision(source, target) {\n        return source.passedThroughNonGreedyDecision ||\n            (target instanceof DecisionState) && target.nonGreedy;\n    }\n}\n\n\nmodule.exports.ATNConfig = ATNConfig;\nmodule.exports.LexerATNConfig = LexerATNConfig;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst ATN = require('./ATN');\nconst Utils = require('./../Utils');\nconst {SemanticContext} = require('./SemanticContext');\nconst {merge} = require('./../PredictionContext');\n\nfunction hashATNConfig(c) {\n\treturn c.hashCodeForConfigSet();\n}\n\nfunction equalATNConfigs(a, b) {\n\tif ( a===b ) {\n\t\treturn true;\n\t} else if ( a===null || b===null ) {\n\t\treturn false;\n\t} else\n       return a.equalsForConfigSet(b);\n }\n\n/**\n * Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track\n * info about the set, with support for combining similar configurations using a\n * graph-structured stack\n */\nclass ATNConfigSet {\n\tconstructor(fullCtx) {\n\t\t/**\n\t\t * The reason that we need this is because we don't want the hash map to use\n\t\t * the standard hash code and equals. We need all configurations with the\n\t\t * same\n\t\t * {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively\n\t\t * doubles\n\t\t * the number of objects associated with ATNConfigs. The other solution is\n\t\t * to\n\t\t * use a hash table that lets us specify the equals/hashcode operation.\n\t\t * All configs but hashed by (s, i, _, pi) not including context. Wiped out\n\t\t * when we go readonly as this set becomes a DFA state\n\t\t */\n\t\tthis.configLookup = new Utils.Set(hashATNConfig, equalATNConfigs);\n\t\t/**\n\t\t * Indicates that this configuration set is part of a full context\n\t\t * LL prediction. It will be used to determine how to merge $. With SLL\n\t\t * it's a wildcard whereas it is not for LL context merge\n\t\t */\n\t\tthis.fullCtx = fullCtx === undefined ? true : fullCtx;\n\t\t/**\n\t\t * Indicates that the set of configurations is read-only. Do not\n\t\t * allow any code to manipulate the set; DFA states will point at\n\t\t * the sets and they must not change. This does not protect the other\n\t\t * fields; in particular, conflictingAlts is set after\n\t\t * we've made this readonly\n\t\t */\n\t\tthis.readOnly = false;\n\t\t// Track the elements as they are added to the set; supports get(i)///\n\t\tthis.configs = [];\n\n\t\t// TODO: these fields make me pretty uncomfortable but nice to pack up info\n\t\t// together, saves recomputation\n\t\t// TODO: can we track conflicts as they are added to save scanning configs\n\t\t// later?\n\t\tthis.uniqueAlt = 0;\n\t\tthis.conflictingAlts = null;\n\n\t\t/**\n\t\t * Used in parser and lexer. In lexer, it indicates we hit a pred\n\t\t * while computing a closure operation. Don't make a DFA state from this\n\t\t */\n\t\tthis.hasSemanticContext = false;\n\t\tthis.dipsIntoOuterContext = false;\n\n\t\tthis.cachedHashCode = -1;\n\t}\n\n\t/**\n\t * Adding a new config means merging contexts with existing configs for\n\t * {@code (s, i, pi, _)}, where {@code s} is the\n\t * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and\n\t * {@code pi} is the {@link ATNConfig//semanticContext}. We use\n\t * {@code (s,i,pi)} as key.\n\t *\n\t * <p>This method updates {@link //dipsIntoOuterContext} and\n\t * {@link //hasSemanticContext} when necessary.</p>\n\t */\n\tadd(config, mergeCache) {\n\t\tif (mergeCache === undefined) {\n\t\t\tmergeCache = null;\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tif (config.semanticContext !== SemanticContext.NONE) {\n\t\t\tthis.hasSemanticContext = true;\n\t\t}\n\t\tif (config.reachesIntoOuterContext > 0) {\n\t\t\tthis.dipsIntoOuterContext = true;\n\t\t}\n\t\tconst existing = this.configLookup.add(config);\n\t\tif (existing === config) {\n\t\t\tthis.cachedHashCode = -1;\n\t\t\tthis.configs.push(config); // track order here\n\t\t\treturn true;\n\t\t}\n\t\t// a previous (s,i,pi,_), merge with it and save result\n\t\tconst rootIsWildcard = !this.fullCtx;\n\t\tconst merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);\n\t\t/**\n\t\t * no need to check for existing.context, config.context in cache\n\t\t * since only way to create new graphs is \"call rule\" and here. We\n\t\t * cache at both places\n\t\t */\n\t\texisting.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);\n\t\t// make sure to preserve the precedence filter suppression during the merge\n\t\tif (config.precedenceFilterSuppressed) {\n\t\t\texisting.precedenceFilterSuppressed = true;\n\t\t}\n\t\texisting.context = merged; // replace context; no need to alt mapping\n\t\treturn true;\n\t}\n\n\tgetStates() {\n\t\tconst states = new Utils.Set();\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tstates.add(this.configs[i].state);\n\t\t}\n\t\treturn states;\n\t}\n\n\tgetPredicates() {\n\t\tconst preds = [];\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tconst c = this.configs[i].semanticContext;\n\t\t\tif (c !== SemanticContext.NONE) {\n\t\t\t\tpreds.push(c.semanticContext);\n\t\t\t}\n\t\t}\n\t\treturn preds;\n\t}\n\n\toptimizeConfigs(interpreter) {\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tif (this.configLookup.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tconst config = this.configs[i];\n\t\t\tconfig.context = interpreter.getCachedContext(config.context);\n\t\t}\n\t}\n\n\taddAll(coll) {\n\t\tfor (let i = 0; i < coll.length; i++) {\n\t\t\tthis.add(coll[i]);\n\t\t}\n\t\treturn false;\n\t}\n\n\tequals(other) {\n\t\treturn this === other ||\n\t\t\t(other instanceof ATNConfigSet &&\n\t\t\tUtils.equalArrays(this.configs, other.configs) &&\n\t\t\tthis.fullCtx === other.fullCtx &&\n\t\t\tthis.uniqueAlt === other.uniqueAlt &&\n\t\t\tthis.conflictingAlts === other.conflictingAlts &&\n\t\t\tthis.hasSemanticContext === other.hasSemanticContext &&\n\t\t\tthis.dipsIntoOuterContext === other.dipsIntoOuterContext);\n\t}\n\n\thashCode() {\n\t\tconst hash = new Utils.Hash();\n\t\thash.update(this.configs);\n\t\treturn hash.finish();\n\t}\n\n\tupdateHashCode(hash) {\n\t\tif (this.readOnly) {\n\t\t\tif (this.cachedHashCode === -1) {\n\t\t\t\tthis.cachedHashCode = this.hashCode();\n\t\t\t}\n\t\t\thash.update(this.cachedHashCode);\n\t\t} else {\n\t\t\thash.update(this.hashCode());\n\t\t}\n\t}\n\n\tisEmpty() {\n\t\treturn this.configs.length === 0;\n\t}\n\n\tcontains(item) {\n\t\tif (this.configLookup === null) {\n\t\t\tthrow \"This method is not implemented for readonly sets.\";\n\t\t}\n\t\treturn this.configLookup.contains(item);\n\t}\n\n\tcontainsFast(item) {\n\t\tif (this.configLookup === null) {\n\t\t\tthrow \"This method is not implemented for readonly sets.\";\n\t\t}\n\t\treturn this.configLookup.containsFast(item);\n\t}\n\n\tclear() {\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tthis.configs = [];\n\t\tthis.cachedHashCode = -1;\n\t\tthis.configLookup = new Utils.Set();\n\t}\n\n\tsetReadonly(readOnly) {\n\t\tthis.readOnly = readOnly;\n\t\tif (readOnly) {\n\t\t\tthis.configLookup = null; // can't mod, no need for lookup cache\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn Utils.arrayToString(this.configs) +\n\t\t\t(this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") +\n\t\t\t(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") +\n\t\t\t(this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") +\n\t\t\t(this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n\t}\n\n\tget items(){\n\t\treturn this.configs;\n\t}\n\n\tget length(){\n\t\treturn this.configs.length;\n\t}\n}\n\n\nclass OrderedATNConfigSet extends ATNConfigSet {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.configLookup = new Utils.Set();\n\t}\n}\n\nmodule.exports = {\n\tATNConfigSet,\n\tOrderedATNConfigSet\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nclass ATNDeserializationOptions {\n\tconstructor(copyFrom) {\n\t\tif(copyFrom===undefined) {\n\t\t\tcopyFrom = null;\n\t\t}\n\t\tthis.readOnly = false;\n\t\tthis.verifyATN = copyFrom===null ? true : copyFrom.verifyATN;\n\t\tthis.generateRuleBypassTransitions = copyFrom===null ? false : copyFrom.generateRuleBypassTransitions;\n\t}\n}\n\nATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();\nATNDeserializationOptions.defaultOptions.readOnly = true;\n\n//    def __setattr__(self, key, value):\n//        if key!=\"readOnly\" and self.readOnly:\n//            raise Exception(\"The object is read only.\")\n//        super(type(self), self).__setattr__(key,value)\n\nmodule.exports = ATNDeserializationOptions\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst ATN = require('./ATN');\nconst ATNType = require('./ATNType');\n\nconst {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n} = require('./ATNState');\n\nconst {\n    Transition,\n    AtomTransition,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    RangeTransition,\n    ActionTransition,\n    EpsilonTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition\n} = require('./Transition')\n\nconst {IntervalSet} = require('./../IntervalSet');\nconst ATNDeserializationOptions = require('./ATNDeserializationOptions');\n\nconst {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction,\n} = require('./LexerAction');\n\n// This is the earliest supported serialized UUID.\n// stick to serialized version for now, we don't need a UUID instance\nconst BASE_SERIALIZED_UUID = \"AADB8D7E-AEEF-4415-AD2B-8204D6CF042E\";\n\n//\n// This UUID indicates the serialized ATN contains two sets of\n// IntervalSets, where the second set's values are encoded as\n// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.\n//\nconst ADDED_UNICODE_SMP = \"59627784-3BE5-417A-B9EB-8131A7286089\";\n\n// This list contains all of the currently supported UUIDs, ordered by when\n// the feature first appeared in this branch.\nconst SUPPORTED_UUIDS = [ BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP ];\n\nconst SERIALIZED_VERSION = 3;\n\n// This is the current serialized UUID.\nconst SERIALIZED_UUID = ADDED_UNICODE_SMP;\n\nfunction initArray( length, value) {\n\tconst tmp = [];\n\ttmp[length-1] = value;\n\treturn tmp.map(function(i) {return value;});\n}\n\nclass ATNDeserializer {\n    constructor(options) {\n\n        if ( options=== undefined || options === null ) {\n            options = ATNDeserializationOptions.defaultOptions;\n        }\n        this.deserializationOptions = options;\n        this.stateFactories = null;\n        this.actionFactories = null;\n    }\n\n    /**\n     * Determines if a particular serialized representation of an ATN supports\n     * a particular feature, identified by the {@link UUID} used for serializing\n     * the ATN at the time the feature was first introduced.\n     *\n     * @param feature The {@link UUID} marking the first time the feature was\n     * supported in the serialized ATN.\n     * @param actualUuid The {@link UUID} of the actual serialized ATN which is\n     * currently being deserialized.\n     * @return {@code true} if the {@code actualUuid} value represents a\n     * serialized ATN at or after the feature identified by {@code feature} was\n     * introduced; otherwise, {@code false}.\n    */\n    isFeatureSupported(feature, actualUuid) {\n        const idx1 = SUPPORTED_UUIDS.indexOf(feature);\n        if (idx1<0) {\n            return false;\n        }\n        const idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);\n        return idx2 >= idx1;\n    }\n\n    deserialize(data) {\n        this.reset(data);\n        this.checkVersion();\n        this.checkUUID();\n        const atn = this.readATN();\n        this.readStates(atn);\n        this.readRules(atn);\n        this.readModes(atn);\n        const sets = [];\n        // First, deserialize sets with 16-bit arguments <= U+FFFF.\n        this.readSets(atn, sets, this.readInt.bind(this));\n        // Next, if the ATN was serialized with the Unicode SMP feature,\n        // deserialize sets with 32-bit arguments <= U+10FFFF.\n        if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {\n            this.readSets(atn, sets, this.readInt32.bind(this));\n        }\n        this.readEdges(atn, sets);\n        this.readDecisions(atn);\n        this.readLexerActions(atn);\n        this.markPrecedenceDecisions(atn);\n        this.verifyATN(atn);\n        if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {\n            this.generateRuleBypassTransitions(atn);\n            // re-verify after modification\n            this.verifyATN(atn);\n        }\n        return atn;\n    }\n\n    reset(data) {\n        const adjust = function(c) {\n            const v = c.charCodeAt(0);\n            return v>1  ? v-2 : v + 65534;\n        };\n        const temp = data.split(\"\").map(adjust);\n        // don't adjust the first value since that's the version number\n        temp[0] = data.charCodeAt(0);\n        this.data = temp;\n        this.pos = 0;\n    }\n\n    checkVersion() {\n        const version = this.readInt();\n        if ( version !== SERIALIZED_VERSION ) {\n            throw (\"Could not deserialize ATN with version \" + version + \" (expected \" + SERIALIZED_VERSION + \").\");\n        }\n    }\n\n    checkUUID() {\n        const uuid = this.readUUID();\n        if (SUPPORTED_UUIDS.indexOf(uuid)<0) {\n            throw (\"Could not deserialize ATN with UUID: \" + uuid +\n                            \" (expected \" + SERIALIZED_UUID + \" or a legacy UUID).\", uuid, SERIALIZED_UUID);\n        }\n        this.uuid = uuid;\n    }\n\n    readATN() {\n        const grammarType = this.readInt();\n        const maxTokenType = this.readInt();\n        return new ATN(grammarType, maxTokenType);\n    }\n\n    readStates(atn) {\n        let j, pair, stateNumber;\n        const  loopBackStateNumbers = [];\n        const  endStateNumbers = [];\n        const  nstates = this.readInt();\n        for(let i=0; i<nstates; i++) {\n            const  stype = this.readInt();\n            // ignore bad type of states\n            if (stype===ATNState.INVALID_TYPE) {\n                atn.addState(null);\n                continue;\n            }\n            let ruleIndex = this.readInt();\n            if (ruleIndex === 0xFFFF) {\n                ruleIndex = -1;\n            }\n            const  s = this.stateFactory(stype, ruleIndex);\n            if (stype === ATNState.LOOP_END) { // special case\n                const  loopBackStateNumber = this.readInt();\n                loopBackStateNumbers.push([s, loopBackStateNumber]);\n            } else if(s instanceof BlockStartState) {\n                const  endStateNumber = this.readInt();\n                endStateNumbers.push([s, endStateNumber]);\n            }\n            atn.addState(s);\n        }\n        // delay the assignment of loop back and end states until we know all the\n        // state instances have been initialized\n        for (j=0; j<loopBackStateNumbers.length; j++) {\n            pair = loopBackStateNumbers[j];\n            pair[0].loopBackState = atn.states[pair[1]];\n        }\n\n        for (j=0; j<endStateNumbers.length; j++) {\n            pair = endStateNumbers[j];\n            pair[0].endState = atn.states[pair[1]];\n        }\n\n        let numNonGreedyStates = this.readInt();\n        for (j=0; j<numNonGreedyStates; j++) {\n            stateNumber = this.readInt();\n            atn.states[stateNumber].nonGreedy = true;\n        }\n\n        let numPrecedenceStates = this.readInt();\n        for (j=0; j<numPrecedenceStates; j++) {\n            stateNumber = this.readInt();\n            atn.states[stateNumber].isPrecedenceRule = true;\n        }\n    }\n\n    readRules(atn) {\n        let i;\n        const nrules = this.readInt();\n        if (atn.grammarType === ATNType.LEXER ) {\n            atn.ruleToTokenType = initArray(nrules, 0);\n        }\n        atn.ruleToStartState = initArray(nrules, 0);\n        for (i=0; i<nrules; i++) {\n            const s = this.readInt();\n            atn.ruleToStartState[i] = atn.states[s];\n            if ( atn.grammarType === ATNType.LEXER ) {\n                let tokenType = this.readInt();\n                if (tokenType === 0xFFFF) {\n                    tokenType = Token.EOF;\n                }\n                atn.ruleToTokenType[i] = tokenType;\n            }\n        }\n        atn.ruleToStopState = initArray(nrules, 0);\n        for (i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (!(state instanceof RuleStopState)) {\n                continue;\n            }\n            atn.ruleToStopState[state.ruleIndex] = state;\n            atn.ruleToStartState[state.ruleIndex].stopState = state;\n        }\n    }\n\n    readModes(atn) {\n        const nmodes = this.readInt();\n        for (let i=0; i<nmodes; i++) {\n            let s = this.readInt();\n            atn.modeToStartState.push(atn.states[s]);\n        }\n    }\n\n    readSets(atn, sets, readUnicode) {\n        const m = this.readInt();\n        for (let i=0; i<m; i++) {\n            const iset = new IntervalSet();\n            sets.push(iset);\n            const n = this.readInt();\n            const containsEof = this.readInt();\n            if (containsEof!==0) {\n                iset.addOne(-1);\n            }\n            for (let j=0; j<n; j++) {\n                const i1 = readUnicode();\n                const i2 = readUnicode();\n                iset.addRange(i1, i2);\n            }\n        }\n    }\n\n    readEdges(atn, sets) {\n        let i, j, state, trans, target;\n        const nedges = this.readInt();\n        for (i=0; i<nedges; i++) {\n            const src = this.readInt();\n            const trg = this.readInt();\n            const ttype = this.readInt();\n            const arg1 = this.readInt();\n            const arg2 = this.readInt();\n            const arg3 = this.readInt();\n            trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n            const srcState = atn.states[src];\n            srcState.addTransition(trans);\n        }\n        // edges for rule stop states can be derived, so they aren't serialized\n        for (i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            for (j=0; j<state.transitions.length; j++) {\n                const t = state.transitions[j];\n                if (!(t instanceof RuleTransition)) {\n                    continue;\n                }\n                let outermostPrecedenceReturn = -1;\n                if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {\n                    if (t.precedence === 0) {\n                        outermostPrecedenceReturn = t.target.ruleIndex;\n                    }\n                }\n\n                trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);\n                atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);\n            }\n        }\n\n        for (i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            if (state instanceof BlockStartState) {\n                // we need to know the end state to set its start state\n                if (state.endState === null) {\n                    throw (\"IllegalState\");\n                }\n                // block end states can only be associated to a single block start\n                // state\n                if ( state.endState.startState !== null) {\n                    throw (\"IllegalState\");\n                }\n                state.endState.startState = state;\n            }\n            if (state instanceof PlusLoopbackState) {\n                for (j=0; j<state.transitions.length; j++) {\n                    target = state.transitions[j].target;\n                    if (target instanceof PlusBlockStartState) {\n                        target.loopBackState = state;\n                    }\n                }\n            } else if (state instanceof StarLoopbackState) {\n                for (j=0; j<state.transitions.length; j++) {\n                    target = state.transitions[j].target;\n                    if (target instanceof StarLoopEntryState) {\n                        target.loopBackState = state;\n                    }\n                }\n            }\n        }\n    }\n\n    readDecisions(atn) {\n        const ndecisions = this.readInt();\n        for (let i=0; i<ndecisions; i++) {\n            const s = this.readInt();\n            const decState = atn.states[s];\n            atn.decisionToState.push(decState);\n            decState.decision = i;\n        }\n    }\n\n    readLexerActions(atn) {\n        if (atn.grammarType === ATNType.LEXER) {\n            const count = this.readInt();\n            atn.lexerActions = initArray(count, null);\n            for (let i=0; i<count; i++) {\n                const actionType = this.readInt();\n                let data1 = this.readInt();\n                if (data1 === 0xFFFF) {\n                    data1 = -1;\n                }\n                let data2 = this.readInt();\n                if (data2 === 0xFFFF) {\n                    data2 = -1;\n                }\n\n                atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);\n            }\n        }\n    }\n\n    generateRuleBypassTransitions(atn) {\n        let i;\n        const count = atn.ruleToStartState.length;\n        for(i=0; i<count; i++) {\n            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n        }\n        for(i=0; i<count; i++) {\n            this.generateRuleBypassTransition(atn, i);\n        }\n    }\n\n    generateRuleBypassTransition(atn, idx) {\n        let i, state;\n        const bypassStart = new BasicBlockStartState();\n        bypassStart.ruleIndex = idx;\n        atn.addState(bypassStart);\n\n        const bypassStop = new BlockEndState();\n        bypassStop.ruleIndex = idx;\n        atn.addState(bypassStop);\n\n        bypassStart.endState = bypassStop;\n        atn.defineDecisionState(bypassStart);\n\n        bypassStop.startState = bypassStart;\n\n        let excludeTransition = null;\n        let endState = null;\n\n        if (atn.ruleToStartState[idx].isPrecedenceRule) {\n            // wrap from the beginning of the rule to the StarLoopEntryState\n            endState = null;\n            for(i=0; i<atn.states.length; i++) {\n                state = atn.states[i];\n                if (this.stateIsEndStateFor(state, idx)) {\n                    endState = state;\n                    excludeTransition = state.loopBackState.transitions[0];\n                    break;\n                }\n            }\n            if (excludeTransition === null) {\n                throw (\"Couldn't identify final state of the precedence rule prefix section.\");\n            }\n        } else {\n            endState = atn.ruleToStopState[idx];\n        }\n\n        // all non-excluded transitions that currently target end state need to\n        // target blockEnd instead\n        for(i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            for(let j=0; j<state.transitions.length; j++) {\n                const transition = state.transitions[j];\n                if (transition === excludeTransition) {\n                    continue;\n                }\n                if (transition.target === endState) {\n                    transition.target = bypassStop;\n                }\n            }\n        }\n\n        // all transitions leaving the rule start state need to leave blockStart\n        // instead\n        const ruleToStartState = atn.ruleToStartState[idx];\n        const count = ruleToStartState.transitions.length;\n        while ( count > 0) {\n            bypassStart.addTransition(ruleToStartState.transitions[count-1]);\n            ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);\n        }\n        // link the new states\n        atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));\n        bypassStop.addTransition(new EpsilonTransition(endState));\n\n        const matchState = new BasicState();\n        atn.addState(matchState);\n        matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));\n        bypassStart.addTransition(new EpsilonTransition(matchState));\n    }\n\n    stateIsEndStateFor(state, idx) {\n        if ( state.ruleIndex !== idx) {\n            return null;\n        }\n        if (!( state instanceof StarLoopEntryState)) {\n            return null;\n        }\n        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n        if (!( maybeLoopEndState instanceof LoopEndState)) {\n            return null;\n        }\n        if (maybeLoopEndState.epsilonOnlyTransitions &&\n            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n            return state;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n     * the {@link StarLoopEntryState//isPrecedenceDecision} field to the\n     * correct value.\n     * @param atn The ATN.\n     */\n    markPrecedenceDecisions(atn) {\n        for(let i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (!( state instanceof StarLoopEntryState)) {\n                continue;\n            }\n            // We analyze the ATN to determine if this ATN decision state is the\n            // decision for the closure block that determines whether a\n            // precedence rule should continue or complete.\n            if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n                const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n                if (maybeLoopEndState instanceof LoopEndState) {\n                    if ( maybeLoopEndState.epsilonOnlyTransitions &&\n                            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n                        state.isPrecedenceDecision = true;\n                    }\n                }\n            }\n        }\n    }\n\n    verifyATN(atn) {\n        if (!this.deserializationOptions.verifyATN) {\n            return;\n        }\n        // verify assumptions\n        for(let i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (state === null) {\n                continue;\n            }\n            this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);\n            if (state instanceof PlusBlockStartState) {\n                this.checkCondition(state.loopBackState !== null);\n            } else  if (state instanceof StarLoopEntryState) {\n                this.checkCondition(state.loopBackState !== null);\n                this.checkCondition(state.transitions.length === 2);\n                if (state.transitions[0].target instanceof StarBlockStartState) {\n                    this.checkCondition(state.transitions[1].target instanceof LoopEndState);\n                    this.checkCondition(!state.nonGreedy);\n                } else if (state.transitions[0].target instanceof LoopEndState) {\n                    this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);\n                    this.checkCondition(state.nonGreedy);\n                } else {\n                    throw(\"IllegalState\");\n                }\n            } else if (state instanceof StarLoopbackState) {\n                this.checkCondition(state.transitions.length === 1);\n                this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);\n            } else if (state instanceof LoopEndState) {\n                this.checkCondition(state.loopBackState !== null);\n            } else if (state instanceof RuleStartState) {\n                this.checkCondition(state.stopState !== null);\n            } else if (state instanceof BlockStartState) {\n                this.checkCondition(state.endState !== null);\n            } else if (state instanceof BlockEndState) {\n                this.checkCondition(state.startState !== null);\n            } else if (state instanceof DecisionState) {\n                this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);\n            } else {\n                this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));\n            }\n        }\n    }\n\n    checkCondition(condition, message) {\n        if (!condition) {\n            if (message === undefined || message===null) {\n                message = \"IllegalState\";\n            }\n            throw (message);\n        }\n    }\n\n    readInt() {\n        return this.data[this.pos++];\n    }\n\n    readInt32() {\n        const low = this.readInt();\n        const high = this.readInt();\n        return low | (high << 16);\n    }\n\n    readLong() {\n        const low = this.readInt32();\n        const high = this.readInt32();\n        return (low & 0x00000000FFFFFFFF) | (high << 32);\n    }\n\n    readUUID() {\n        const bb = [];\n        for(let i=7;i>=0;i--) {\n            const int = this.readInt();\n            /* jshint bitwise: false */\n            bb[(2*i)+1] = int & 0xFF;\n            bb[2*i] = (int >> 8) & 0xFF;\n        }\n        return byteToHex[bb[0]] + byteToHex[bb[1]] +\n        byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +\n        byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +\n        byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +\n        byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +\n        byteToHex[bb[10]] + byteToHex[bb[11]] +\n        byteToHex[bb[12]] + byteToHex[bb[13]] +\n        byteToHex[bb[14]] + byteToHex[bb[15]];\n    }\n\n    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {\n        const target = atn.states[trg];\n        switch(type) {\n        case Transition.EPSILON:\n            return new EpsilonTransition(target);\n        case Transition.RANGE:\n            return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n        case Transition.RULE:\n            return new RuleTransition(atn.states[arg1], arg2, arg3, target);\n        case Transition.PREDICATE:\n            return new PredicateTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.PRECEDENCE:\n            return new PrecedencePredicateTransition(target, arg1);\n        case Transition.ATOM:\n            return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);\n        case Transition.ACTION:\n            return new ActionTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.SET:\n            return new SetTransition(target, sets[arg1]);\n        case Transition.NOT_SET:\n            return new NotSetTransition(target, sets[arg1]);\n        case Transition.WILDCARD:\n            return new WildcardTransition(target);\n        default:\n            throw \"The specified transition type: \" + type + \" is not valid.\";\n        }\n    }\n\n    stateFactory(type, ruleIndex) {\n        if (this.stateFactories === null) {\n            const sf = [];\n            sf[ATNState.INVALID_TYPE] = null;\n            sf[ATNState.BASIC] = () => new BasicState();\n            sf[ATNState.RULE_START] = () => new RuleStartState();\n            sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();\n            sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();\n            sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();\n            sf[ATNState.TOKEN_START] = () => new TokensStartState();\n            sf[ATNState.RULE_STOP] = () => new RuleStopState();\n            sf[ATNState.BLOCK_END] = () => new BlockEndState();\n            sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();\n            sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();\n            sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();\n            sf[ATNState.LOOP_END] = () => new LoopEndState();\n            this.stateFactories = sf;\n        }\n        if (type>this.stateFactories.length || this.stateFactories[type] === null) {\n            throw(\"The specified state type \" + type + \" is not valid.\");\n        } else {\n            const s = this.stateFactories[type]();\n            if (s!==null) {\n                s.ruleIndex = ruleIndex;\n                return s;\n            }\n        }\n    }\n\n    lexerActionFactory(type, data1, data2) {\n        if (this.actionFactories === null) {\n            const af = [];\n            af[LexerActionType.CHANNEL] = (data1, data2) => new LexerChannelAction(data1);\n            af[LexerActionType.CUSTOM] = (data1, data2) => new LexerCustomAction(data1, data2);\n            af[LexerActionType.MODE] = (data1, data2) => new LexerModeAction(data1);\n            af[LexerActionType.MORE] = (data1, data2) => LexerMoreAction.INSTANCE;\n            af[LexerActionType.POP_MODE] = (data1, data2) => LexerPopModeAction.INSTANCE;\n            af[LexerActionType.PUSH_MODE] = (data1, data2) => new LexerPushModeAction(data1);\n            af[LexerActionType.SKIP] = (data1, data2) => LexerSkipAction.INSTANCE;\n            af[LexerActionType.TYPE] = (data1, data2) => new LexerTypeAction(data1);\n            this.actionFactories = af;\n        }\n        if (type>this.actionFactories.length || this.actionFactories[type] === null) {\n            throw(\"The specified lexer action type \" + type + \" is not valid.\");\n        } else {\n            return this.actionFactories[type](data1, data2);\n        }\n    }\n}\n\nfunction createByteToHex() {\n\tconst bth = [];\n\tfor (let i = 0; i < 256; i++) {\n\t\tbth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();\n\t}\n\treturn bth;\n}\n\nconst byteToHex = createByteToHex();\n\n\nmodule.exports = ATNDeserializer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {DFAState} = require('./../dfa/DFAState');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {getCachedPredictionContext} = require('./../PredictionContext');\nconst {Map} = require('./../Utils');\n\nclass ATNSimulator {\n    constructor(atn, sharedContextCache) {\n        /**\n         * The context cache maps all PredictionContext objects that are ==\n         * to a single cached copy. This cache is shared across all contexts\n         * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet\n         * to use only cached nodes/graphs in addDFAState(). We don't want to\n         * fill this during closure() since there are lots of contexts that\n         * pop up but are not used ever again. It also greatly slows down closure().\n         *\n         * <p>This cache makes a huge difference in memory and a little bit in speed.\n         * For the Java grammar on java.*, it dropped the memory requirements\n         * at the end from 25M to 16M. We don't store any of the full context\n         * graphs in the DFA because they are limited to local context only,\n         * but apparently there's a lot of repetition there as well. We optimize\n         * the config contexts before storing the config set in the DFA states\n         * by literally rebuilding them with cached subgraphs only.</p>\n         *\n         * <p>I tried a cache for use during closure operations, that was\n         * whacked after each adaptivePredict(). It cost a little bit\n         * more time I think and doesn't save on the overall footprint\n         * so it's not worth the complexity.</p>\n         */\n        this.atn = atn;\n        this.sharedContextCache = sharedContextCache;\n        return this;\n    }\n\n    getCachedContext(context) {\n        if (this.sharedContextCache ===null) {\n            return context;\n        }\n        const visited = new Map();\n        return getCachedPredictionContext(context, this.sharedContextCache, visited);\n    }\n}\n\n// Must distinguish between missing edge and edge we know leads nowhere///\nATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());\n\n\nmodule.exports = ATNSimulator;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst INITIAL_NUM_TRANSITIONS = 4;\n\n/**\n * The following images show the relation of states and\n * {@link ATNState//transitions} for various grammar constructs.\n *\n * <ul>\n *\n * <li>Solid edges marked with an &//0949; indicate a required\n * {@link EpsilonTransition}.</li>\n *\n * <li>Dashed edges indicate locations where any transition derived from\n * {@link Transition} might appear.</li>\n *\n * <li>Dashed nodes are place holders for either a sequence of linked\n * {@link BasicState} states or the inclusion of a block representing a nested\n * construct in one of the forms below.</li>\n *\n * <li>Nodes showing multiple outgoing alternatives with a {@code ...} support\n * any number of alternatives (one or more). Nodes without the {@code ...} only\n * support the exact number of alternatives shown in the diagram.</li>\n *\n * </ul>\n *\n * <h2>Basic Blocks</h2>\n *\n * <h3>Rule</h3>\n *\n * <embed src=\"images/Rule.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Block of 1 or more alternatives</h3>\n *\n * <embed src=\"images/Block.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Greedy Loops</h2>\n *\n * <h3>Greedy Closure: {@code (...)*}</h3>\n *\n * <embed src=\"images/ClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Positive Closure: {@code (...)+}</h3>\n *\n * <embed src=\"images/PositiveClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Optional: {@code (...)?}</h3>\n *\n * <embed src=\"images/OptionalGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Non-Greedy Loops</h2>\n *\n * <h3>Non-Greedy Closure: {@code (...)*?}</h3>\n *\n * <embed src=\"images/ClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>\n *\n * <embed src=\"images/PositiveClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Optional: {@code (...)??}</h3>\n *\n * <embed src=\"images/OptionalNonGreedy.svg\" type=\"image/svg+xml\"/>\n */\nclass ATNState {\n    constructor() {\n        // Which ATN are we in?\n        this.atn = null;\n        this.stateNumber = ATNState.INVALID_STATE_NUMBER;\n        this.stateType = null;\n        this.ruleIndex = 0; // at runtime, we don't have Rule objects\n        this.epsilonOnlyTransitions = false;\n        // Track the transitions emanating from this ATN state.\n        this.transitions = [];\n        // Used to cache lookahead during parsing, not used during construction\n        this.nextTokenWithinRule = null;\n    }\n\n    toString() {\n        return this.stateNumber;\n    }\n\n    equals(other) {\n        if (other instanceof ATNState) {\n            return this.stateNumber===other.stateNumber;\n        } else {\n            return false;\n        }\n    }\n\n    isNonGreedyExitState() {\n        return false;\n    }\n\n    addTransition(trans, index) {\n        if(index===undefined) {\n            index = -1;\n        }\n        if (this.transitions.length===0) {\n            this.epsilonOnlyTransitions = trans.isEpsilon;\n        } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {\n            this.epsilonOnlyTransitions = false;\n        }\n        if (index===-1) {\n            this.transitions.push(trans);\n        } else {\n            this.transitions.splice(index, 1, trans);\n        }\n    }\n}\n\n// constants for serialization\nATNState.INVALID_TYPE = 0;\nATNState.BASIC = 1;\nATNState.RULE_START = 2;\nATNState.BLOCK_START = 3;\nATNState.PLUS_BLOCK_START = 4;\nATNState.STAR_BLOCK_START = 5;\nATNState.TOKEN_START = 6;\nATNState.RULE_STOP = 7;\nATNState.BLOCK_END = 8;\nATNState.STAR_LOOP_BACK = 9;\nATNState.STAR_LOOP_ENTRY = 10;\nATNState.PLUS_LOOP_BACK = 11;\nATNState.LOOP_END = 12;\n\nATNState.serializationNames = [\n            \"INVALID\",\n            \"BASIC\",\n            \"RULE_START\",\n            \"BLOCK_START\",\n            \"PLUS_BLOCK_START\",\n            \"STAR_BLOCK_START\",\n            \"TOKEN_START\",\n            \"RULE_STOP\",\n            \"BLOCK_END\",\n            \"STAR_LOOP_BACK\",\n            \"STAR_LOOP_ENTRY\",\n            \"PLUS_LOOP_BACK\",\n            \"LOOP_END\" ];\n\nATNState.INVALID_STATE_NUMBER = -1;\n\n\nclass BasicState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BASIC;\n    }\n}\n\nclass DecisionState extends ATNState {\n    constructor() {\n        super();\n        this.decision = -1;\n        this.nonGreedy = false;\n        return this;\n    }\n}\n\n/**\n *  The start of a regular {@code (...)} block\n */\nclass BlockStartState extends DecisionState {\n    constructor() {\n        super();\n        this.endState = null;\n        return this;\n    }\n}\n\nclass BasicBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BLOCK_START;\n        return this;\n    }\n}\n\n/**\n * Terminal node of a simple {@code (a|b|c)} block\n */\nclass BlockEndState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BLOCK_END;\n        this.startState = null;\n        return this;\n    }\n}\n\n/**\n * The last node in the ATN for a rule, unless that rule is the start symbol.\n * In that case, there is one transition to EOF. Later, we might encode\n * references to all calls to this rule to compute FOLLOW sets for\n * error handling\n */\nclass RuleStopState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.RULE_STOP;\n        return this;\n    }\n}\n\nclass RuleStartState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.RULE_START;\n        this.stopState = null;\n        this.isPrecedenceRule = false;\n        return this;\n    }\n}\n\n/**\n * Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:\n * one to the loop back to start of the block and one to exit.\n */\nclass PlusLoopbackState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.PLUS_LOOP_BACK;\n        return this;\n    }\n}\n\n/**\n * Start of {@code (A|B|...)+} loop. Technically a decision state, but\n * we don't use for code generation; somebody might need it, so I'm defining\n * it for completeness. In reality, the {@link PlusLoopbackState} node is the\n * real decision-making note for {@code A+}\n */\nclass PlusBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.PLUS_BLOCK_START;\n        this.loopBackState = null;\n        return this;\n    }\n}\n\n/**\n * The block that begins a closure loop\n */\nclass StarBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_BLOCK_START;\n        return this;\n    }\n}\n\nclass StarLoopbackState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_LOOP_BACK;\n        return this;\n    }\n}\n\nclass StarLoopEntryState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_LOOP_ENTRY;\n        this.loopBackState = null;\n        // Indicates whether this state can benefit from a precedence DFA during SLL decision making.\n        this.isPrecedenceDecision = null;\n        return this;\n    }\n}\n\n/**\n * Mark the end of a * or + loop\n */\nclass LoopEndState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.LOOP_END;\n        this.loopBackState = null;\n        return this;\n    }\n}\n\n/**\n * The Tokens rule start state linking to each lexer rule start state\n */\nclass TokensStartState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.TOKEN_START;\n        return this;\n    }\n}\n\nmodule.exports = {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * Represents the type of recognizer an ATN applies to\n */\nmodule.exports = {\n    LEXER: 0,\n    PARSER: 1\n};\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst Lexer = require('./../Lexer');\nconst ATN = require('./ATN');\nconst ATNSimulator = require('./ATNSimulator');\nconst {DFAState} = require('./../dfa/DFAState');\nconst {OrderedATNConfigSet} = require('./ATNConfigSet');\nconst {PredictionContext} = require('./../PredictionContext');\nconst {SingletonPredictionContext} = require('./../PredictionContext');\nconst {RuleStopState} = require('./ATNState');\nconst {LexerATNConfig} = require('./ATNConfig');\nconst {Transition} = require('./Transition');\nconst LexerActionExecutor = require('./LexerActionExecutor');\nconst {LexerNoViableAltException} = require('./../error/Errors');\n\nfunction resetSimState(sim) {\n\tsim.index = -1;\n\tsim.line = 0;\n\tsim.column = -1;\n\tsim.dfaState = null;\n}\n\nclass SimState {\n\tconstructor() {\n\t\tresetSimState(this);\n\t}\n\n\treset() {\n\t\tresetSimState(this);\n\t}\n}\n\nclass LexerATNSimulator extends ATNSimulator {\n\t/**\n\t * When we hit an accept state in either the DFA or the ATN, we\n\t * have to notify the character stream to start buffering characters\n\t * via {@link IntStream//mark} and record the current state. The current sim state\n\t * includes the current index into the input, the current line,\n\t * and current character position in that line. Note that the Lexer is\n\t * tracking the starting line and characterization of the token. These\n\t * variables track the \"state\" of the simulator when it hits an accept state.\n\t *\n\t * <p>We track these variables separately for the DFA and ATN simulation\n\t * because the DFA simulation often has to fail over to the ATN\n\t * simulation. If the ATN simulation fails, we need the DFA to fall\n\t * back to its previously accepted state, if any. If the ATN succeeds,\n\t * then the ATN does the accept and the DFA simulator that invoked it\n\t * can simply return the predicted token type.</p>\n\t */\n\tconstructor(recog, atn, decisionToDFA, sharedContextCache) {\n\t\tsuper(atn, sharedContextCache);\n\t\tthis.decisionToDFA = decisionToDFA;\n\t\tthis.recog = recog;\n\t\t/**\n\t\t * The current token's starting index into the character stream.\n\t\t * Shared across DFA to ATN simulation in case the ATN fails and the\n\t\t * DFA did not have a previous accept state. In this case, we use the\n\t\t * ATN-generated exception object\n\t\t */\n\t\tthis.startIndex = -1;\n\t\t// line number 1..n within the input///\n\t\tthis.line = 1;\n\t\t/**\n\t\t * The index of the character relative to the beginning of the line\n\t\t * 0..n-1\n\t\t */\n\t\tthis.column = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t\t/**\n\t\t * Used during DFA/ATN exec to record the most recent accept configuration\n\t\t * info\n\t\t */\n\t\tthis.prevAccept = new SimState();\n\t}\n\n\tcopyState(simulator) {\n\t\tthis.column = simulator.column;\n\t\tthis.line = simulator.line;\n\t\tthis.mode = simulator.mode;\n\t\tthis.startIndex = simulator.startIndex;\n\t}\n\n\tmatch(input, mode) {\n\t\tthis.match_calls += 1;\n\t\tthis.mode = mode;\n\t\tconst mark = input.mark();\n\t\ttry {\n\t\t\tthis.startIndex = input.index;\n\t\t\tthis.prevAccept.reset();\n\t\t\tconst dfa = this.decisionToDFA[mode];\n\t\t\tif (dfa.s0 === null) {\n\t\t\t\treturn this.matchATN(input);\n\t\t\t} else {\n\t\t\t\treturn this.execATN(input, dfa.s0);\n\t\t\t}\n\t\t} finally {\n\t\t\tinput.release(mark);\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.prevAccept.reset();\n\t\tthis.startIndex = -1;\n\t\tthis.line = 1;\n\t\tthis.column = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t}\n\n\tmatchATN(input) {\n\t\tconst startState = this.atn.modeToStartState[this.mode];\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"matchATN mode \" + this.mode + \" start: \" + startState);\n\t\t}\n\t\tconst old_mode = this.mode;\n\t\tconst s0_closure = this.computeStartState(input, startState);\n\t\tconst suppressEdge = s0_closure.hasSemanticContext;\n\t\ts0_closure.hasSemanticContext = false;\n\n\t\tconst next = this.addDFAState(s0_closure);\n\t\tif (!suppressEdge) {\n\t\t\tthis.decisionToDFA[this.mode].s0 = next;\n\t\t}\n\n\t\tconst predict = this.execATN(input, next);\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"DFA after matchATN: \" + this.decisionToDFA[old_mode].toLexerString());\n\t\t}\n\t\treturn predict;\n\t}\n\n\texecATN(input, ds0) {\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"start state closure=\" + ds0.configs);\n\t\t}\n\t\tif (ds0.isAcceptState) {\n\t\t\t// allow zero-length tokens\n\t\t\tthis.captureSimState(this.prevAccept, input, ds0);\n\t\t}\n\t\tlet t = input.LA(1);\n\t\tlet s = ds0; // s is current/from DFA state\n\n\t\twhile (true) { // while more work\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"execATN loop starting closure: \" + s.configs);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t * avoid looking up the DFA state again, which is expensive.\n\t\t\t * If the previous target was already part of the DFA, we might\n\t\t\t * be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t * it means that semantic predicates didn't prevent us from\n\t\t\t * creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t * the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t * it's configuration set; there's no point in re-computing it.\n\t\t\t * This is kind of like doing DFA simulation within the ATN\n\t\t\t * simulation because DFA simulation is really just a way to avoid\n\t\t\t * computing reach/closure sets. Technically, once we know that\n\t\t\t * we have a previously added DFA state, we could jump over to\n\t\t\t * the DFA simulator. But, that would mean popping back and forth\n\t\t\t * a lot and making things more complicated algorithmically.\n\t\t\t * This optimization makes a lot of sense for loops within DFA.\n\t\t\t * A character will take us back to an existing DFA state\n\t\t\t * that already has lots of edges out of it. e.g., .* in comments.\n\t\t\t * print(\"Target for:\" + str(s) + \" and:\" + str(t))\n\t\t\t */\n\t\t\tlet target = this.getExistingTargetState(s, t);\n\t\t\t// print(\"Existing:\" + str(target))\n\t\t\tif (target === null) {\n\t\t\t\ttarget = this.computeTargetState(input, s, t);\n\t\t\t\t// print(\"Computed:\" + str(target))\n\t\t\t}\n\t\t\tif (target === ATNSimulator.ERROR) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// If this is a consumable input element, make sure to consume before\n\t\t\t// capturing the accept state so the input index, line, and char\n\t\t\t// position accurately reflect the state of the interpreter at the\n\t\t\t// end of the token.\n\t\t\tif (t !== Token.EOF) {\n\t\t\t\tthis.consume(input);\n\t\t\t}\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tthis.captureSimState(this.prevAccept, input, target);\n\t\t\t\tif (t === Token.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = input.LA(1);\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\t\treturn this.failOrAccept(this.prevAccept, input, s.configs, t);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns {@code null}.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @return The existing target DFA state for the given input symbol\n\t * {@code t}, or {@code null} if the target state for this edge is not\n\t * already cached\n\t */\n\tgetExistingTargetState(s, t) {\n\t\tif (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];\n\t\tif(target===undefined) {\n\t\t\ttarget = null;\n\t\t}\n\t\tif (LexerATNSimulator.debug && target !== null) {\n\t\t\tconsole.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param input The input stream\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t *\n\t * @return The computed target DFA state for the given input symbol\n\t * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n\t * returns {@link //ERROR}.\n\t */\n\tcomputeTargetState(input, s, t) {\n\t\tconst reach = new OrderedATNConfigSet();\n\t\t// if we don't find an existing DFA state\n\t\t// Fill reach starting from closure, following t transitions\n\t\tthis.getReachableConfigSet(input, s.configs, reach, t);\n\n\t\tif (reach.items.length === 0) { // we got nowhere on t from s\n\t\t\tif (!reach.hasSemanticContext) {\n\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t\t// cause a failover from DFA later.\n\t\t\t\tthis.addDFAEdge(s, t, ATNSimulator.ERROR);\n\t\t\t}\n\t\t\t// stop when we can't match any more char\n\t\t\treturn ATNSimulator.ERROR;\n\t\t}\n\t\t// Add an edge from s to target DFA found/created for reach\n\t\treturn this.addDFAEdge(s, t, null, reach);\n\t}\n\n\tfailOrAccept(prevAccept, input, reach, t) {\n\t\tif (this.prevAccept.dfaState !== null) {\n\t\t\tconst lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;\n\t\t\tthis.accept(input, lexerActionExecutor, this.startIndex,\n\t\t\t\t\tprevAccept.index, prevAccept.line, prevAccept.column);\n\t\t\treturn prevAccept.dfaState.prediction;\n\t\t} else {\n\t\t\t// if no accept and EOF is first char, return EOF\n\t\t\tif (t === Token.EOF && input.index === this.startIndex) {\n\t\t\t\treturn Token.EOF;\n\t\t\t}\n\t\t\tthrow new LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n\t\t}\n\t}\n\n\t/**\n\t * Given a starting configuration set, figure out all ATN configurations\n\t * we can reach upon input {@code t}. Parameter {@code reach} is a return\n\t * parameter.\n\t */\n\tgetReachableConfigSet(input, closure,\n\t\t\treach, t) {\n\t\t// this is used to skip processing for configs which have a lower priority\n\t\t// than a config that already reached an accept state for the same rule\n\t\tlet skipAlt = ATN.INVALID_ALT_NUMBER;\n\t\tfor (let i = 0; i < closure.items.length; i++) {\n\t\t\tconst cfg = closure.items[i];\n\t\t\tconst currentAltReachedAcceptState = (cfg.alt === skipAlt);\n\t\t\tif (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"testing %s at %s\\n\", this.getTokenName(t), cfg\n\t\t\t\t\t\t.toString(this.recog, true));\n\t\t\t}\n\t\t\tfor (let j = 0; j < cfg.state.transitions.length; j++) {\n\t\t\t\tconst trans = cfg.state.transitions[j]; // for each transition\n\t\t\t\tconst target = this.getReachableTarget(trans, t);\n\t\t\t\tif (target !== null) {\n\t\t\t\t\tlet lexerActionExecutor = cfg.lexerActionExecutor;\n\t\t\t\t\tif (lexerActionExecutor !== null) {\n\t\t\t\t\t\tlexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n\t\t\t\t\t}\n\t\t\t\t\tconst treatEofAsEpsilon = (t === Token.EOF);\n\t\t\t\t\tconst config = new LexerATNConfig({state:target, lexerActionExecutor:lexerActionExecutor}, cfg);\n\t\t\t\t\tif (this.closure(input, config, reach,\n\t\t\t\t\t\t\tcurrentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n\t\t\t\t\t\t// any remaining configs for this alt have a lower priority\n\t\t\t\t\t\t// than the one that just reached an accept state.\n\t\t\t\t\t\tskipAlt = cfg.alt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taccept(input, lexerActionExecutor,\n\t\t\t   startIndex, index, line, charPos) {\n\t\t   if (LexerATNSimulator.debug) {\n\t\t\t   console.log(\"ACTION %s\\n\", lexerActionExecutor);\n\t\t   }\n\t\t   // seek to after last char in token\n\t\t   input.seek(index);\n\t\t   this.line = line;\n\t\t   this.column = charPos;\n\t\t   if (lexerActionExecutor !== null && this.recog !== null) {\n\t\t\t   lexerActionExecutor.execute(this.recog, input, startIndex);\n\t\t   }\n\t   }\n\n\tgetReachableTarget(trans, t) {\n\t\tif (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\treturn trans.target;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tcomputeStartState(input, p) {\n\t\tconst initialContext = PredictionContext.EMPTY;\n\t\tconst configs = new OrderedATNConfigSet();\n\t\tfor (let i = 0; i < p.transitions.length; i++) {\n\t\t\tconst target = p.transitions[i].target;\n\t\t\tconst cfg = new LexerATNConfig({state:target, alt:i+1, context:initialContext}, null);\n\t\t\tthis.closure(input, cfg, configs, false, false, false);\n\t\t}\n\t\treturn configs;\n\t}\n\n\t/**\n\t * Since the alternatives within any lexer decision are ordered by\n\t * preference, this method stops pursuing the closure as soon as an accept\n\t * state is reached. After the first accept state is reached by depth-first\n\t * search from {@code config}, all other (potentially reachable) states for\n\t * this rule would have a lower priority.\n\t *\n\t * @return {Boolean} {@code true} if an accept state is reached, otherwise\n\t * {@code false}.\n\t */\n\tclosure(input, config, configs,\n\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n\t\tlet cfg = null;\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n\t\t}\n\t\tif (config.state instanceof RuleStopState) {\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tif (this.recog !== null) {\n\t\t\t\t\tconsole.log(\"closure at %s rule stop %s\\n\", this.recog.ruleNames[config.state.ruleIndex], config);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t\tif (config.context === null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tconfigs.add(new LexerATNConfig({ state:config.state, context:PredictionContext.EMPTY}, config));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (config.context !== null && !config.context.isEmpty()) {\n\t\t\t\tfor (let i = 0; i < config.context.length; i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tconst newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tconst returnState = this.atn.states[config.context.getReturnState(i)];\n\t\t\t\t\t\tcfg = new LexerATNConfig({ state:returnState, context:newContext }, config);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg,\n\t\t\t\t\t\t\t\tconfigs, currentAltReachedAcceptState, speculative,\n\t\t\t\t\t\t\t\ttreatEofAsEpsilon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\t\t// optimization\n\t\tif (!config.state.epsilonOnlyTransitions) {\n\t\t\tif (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\t\tfor (let j = 0; j < config.state.transitions.length; j++) {\n\t\t\tconst trans = config.state.transitions[j];\n\t\t\tcfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);\n\t\t\tif (cfg !== null) {\n\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg, configs,\n\t\t\t\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\t// side-effect: can alter configs.hasSemanticContext\n\tgetEpsilonTarget(input, config, trans,\n\t\t\tconfigs, speculative, treatEofAsEpsilon) {\n\t\tlet cfg = null;\n\t\tif (trans.serializationType === Transition.RULE) {\n\t\t\tconst newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);\n\t\t\tcfg = new LexerATNConfig( { state:trans.target, context:newContext}, config);\n\t\t} else if (trans.serializationType === Transition.PRECEDENCE) {\n\t\t\tthrow \"Precedence predicates are not supported in lexers.\";\n\t\t} else if (trans.serializationType === Transition.PREDICATE) {\n\t\t\t// Track traversing semantic predicates. If we traverse,\n\t\t\t// we cannot add a DFA state for this \"reach\" computation\n\t\t\t// because the DFA would not test the predicate again in the\n\t\t\t// future. Rather than creating collections of semantic predicates\n\t\t\t// like v3 and testing them on prediction, v4 will test them on the\n\t\t\t// fly all the time using the ATN not the DFA. This is slower but\n\t\t\t// semantically it's not used that often. One of the key elements to\n\t\t\t// this predicate mechanism is not adding DFA states that see\n\t\t\t// predicates immediately afterwards in the ATN. For example,\n\n\t\t\t// a : ID {p1}? | ID {p2}? ;\n\n\t\t\t// should create the start state for rule 'a' (to save start state\n\t\t\t// competition), but should not create target of ID state. The\n\t\t\t// collection of ATN states the following ID references includes\n\t\t\t// states reached by traversing predicates. Since this is when we\n\t\t\t// test them, we cannot cash the DFA state target of ID.\n\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"EVAL rule \" + trans.ruleIndex + \":\" + trans.predIndex);\n\t\t\t}\n\t\t\tconfigs.hasSemanticContext = true;\n\t\t\tif (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {\n\t\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t\t}\n\t\t} else if (trans.serializationType === Transition.ACTION) {\n\t\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t\t// execute actions anywhere in the start rule for a token.\n\t\t\t\t//\n\t\t\t\t// TODO: if the entry rule is invoked recursively, some\n\t\t\t\t// actions may be executed during the recursive call. The\n\t\t\t\t// problem can appear when hasEmptyPath() is true but\n\t\t\t\t// isEmpty() is false. In this case, the config needs to be\n\t\t\t\t// split into two contexts - one with just the empty path\n\t\t\t\t// and another with everything but the empty path.\n\t\t\t\t// Unfortunately, the current algorithm does not allow\n\t\t\t\t// getEpsilonTarget to return two configurations, so\n\t\t\t\t// additional modifications are needed before we can support\n\t\t\t\t// the split operation.\n\t\t\t\tconst lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,\n\t\t\t\t\t\tthis.atn.lexerActions[trans.actionIndex]);\n\t\t\t\tcfg = new LexerATNConfig({ state:trans.target, lexerActionExecutor:lexerActionExecutor }, config);\n\t\t\t} else {\n\t\t\t\t// ignore actions in referenced rules\n\t\t\t\tcfg = new LexerATNConfig( { state:trans.target}, config);\n\t\t\t}\n\t\t} else if (trans.serializationType === Transition.EPSILON) {\n\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t} else if (trans.serializationType === Transition.ATOM ||\n\t\t\t\t\ttrans.serializationType === Transition.RANGE ||\n\t\t\t\t\ttrans.serializationType === Transition.SET) {\n\t\t\tif (treatEofAsEpsilon) {\n\t\t\t\tif (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\t\t\tcfg = new LexerATNConfig( { state:trans.target }, config);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cfg;\n\t}\n\n\t/**\n\t * Evaluate a predicate specified in the lexer.\n\t *\n\t * <p>If {@code speculative} is {@code true}, this method was called before\n\t * {@link //consume} for the matched character. This method should call\n\t * {@link //consume} before evaluating the predicate to ensure position\n\t * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},\n\t * and {@link Lexer//getcolumn}, properly reflect the current\n\t * lexer state. This method should restore {@code input} and the simulator\n\t * to the original state before returning (i.e. undo the actions made by the\n\t * call to {@link //consume}.</p>\n\t *\n\t * @param input The input stream.\n\t * @param ruleIndex The rule containing the predicate.\n\t * @param predIndex The index of the predicate within the rule.\n\t * @param speculative {@code true} if the current index in {@code input} is\n\t * one character before the predicate's location.\n\t *\n\t * @return {@code true} if the specified predicate evaluates to\n\t * {@code true}.\n\t */\n\tevaluatePredicate(input, ruleIndex,\n\t\t\tpredIndex, speculative) {\n\t\t// assume true if no recognizer was provided\n\t\tif (this.recog === null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!speculative) {\n\t\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t\t}\n\t\tconst savedcolumn = this.column;\n\t\tconst savedLine = this.line;\n\t\tconst index = input.index;\n\t\tconst marker = input.mark();\n\t\ttry {\n\t\t\tthis.consume(input);\n\t\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t\t} finally {\n\t\t\tthis.column = savedcolumn;\n\t\t\tthis.line = savedLine;\n\t\t\tinput.seek(index);\n\t\t\tinput.release(marker);\n\t\t}\n\t}\n\n\tcaptureSimState(settings, input, dfaState) {\n\t\tsettings.index = input.index;\n\t\tsettings.line = this.line;\n\t\tsettings.column = this.column;\n\t\tsettings.dfaState = dfaState;\n\t}\n\n\taddDFAEdge(from_, tk, to, cfgs) {\n\t\tif (to === undefined) {\n\t\t\tto = null;\n\t\t}\n\t\tif (cfgs === undefined) {\n\t\t\tcfgs = null;\n\t\t}\n\t\tif (to === null && cfgs !== null) {\n\t\t\t// leading to this call, ATNConfigSet.hasSemanticContext is used as a\n\t\t\t// marker indicating dynamic predicate evaluation makes this edge\n\t\t\t// dependent on the specific input sequence, so the static edge in the\n\t\t\t// DFA should be omitted. The target DFAState is still created since\n\t\t\t// execATN has the ability to resynchronize with the DFA state cache\n\t\t\t// following the predicate evaluation step.\n\t\t\t//\n\t\t\t// TJP notes: next time through the DFA, we see a pred again and eval.\n\t\t\t// If that gets us to a previously created (but dangling) DFA\n\t\t\t// state, we can continue in pure DFA mode from there.\n\t\t\t// /\n\t\t\tconst suppressEdge = cfgs.hasSemanticContext;\n\t\t\tcfgs.hasSemanticContext = false;\n\n\t\t\tto = this.addDFAState(cfgs);\n\n\t\t\tif (suppressEdge) {\n\t\t\t\treturn to;\n\t\t\t}\n\t\t}\n\t\t// add the edge\n\t\tif (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t\t// Only track edges within the DFA bounds\n\t\t\treturn to;\n\t\t}\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + tk);\n\t\t}\n\t\tif (from_.edges === null) {\n\t\t\t// make room for tokens 1..n and -1 masquerading as index 0\n\t\t\tfrom_.edges = [];\n\t\t}\n\t\tfrom_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect\n\n\t\treturn to;\n\t}\n\n\t/**\n\t * Add a new DFA state if there isn't one with this set of\n\t * configurations already. This method also detects the first\n\t * configuration containing an ATN rule stop state. Later, when\n\t * traversing the DFA, we will know which rule to accept.\n\t */\n\taddDFAState(configs) {\n\t\tconst proposed = new DFAState(null, configs);\n\t\tlet firstConfigWithRuleStopState = null;\n\t\tfor (let i = 0; i < configs.items.length; i++) {\n\t\t\tconst cfg = configs.items[i];\n\t\t\tif (cfg.state instanceof RuleStopState) {\n\t\t\t\tfirstConfigWithRuleStopState = cfg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (firstConfigWithRuleStopState !== null) {\n\t\t\tproposed.isAcceptState = true;\n\t\t\tproposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n\t\t\tproposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n\t\t}\n\t\tconst dfa = this.decisionToDFA[this.mode];\n\t\tconst existing = dfa.states.get(proposed);\n\t\tif (existing!==null) {\n\t\t\treturn existing;\n\t\t}\n\t\tconst newState = proposed;\n\t\tnewState.stateNumber = dfa.states.length;\n\t\tconfigs.setReadonly(true);\n\t\tnewState.configs = configs;\n\t\tdfa.states.add(newState);\n\t\treturn newState;\n\t}\n\n\tgetDFA(mode) {\n\t\treturn this.decisionToDFA[mode];\n\t}\n\n// Get the text matched so far for the current token.\n\tgetText(input) {\n\t\t// index is first lookahead char, don't include.\n\t\treturn input.getText(this.startIndex, input.index - 1);\n\t}\n\n\tconsume(input) {\n\t\tconst curChar = input.LA(1);\n\t\tif (curChar === \"\\n\".charCodeAt(0)) {\n\t\t\tthis.line += 1;\n\t\t\tthis.column = 0;\n\t\t} else {\n\t\t\tthis.column += 1;\n\t\t}\n\t\tinput.consume();\n\t}\n\n\tgetTokenName(tt) {\n\t\tif (tt === -1) {\n\t\t\treturn \"EOF\";\n\t\t} else {\n\t\t\treturn \"'\" + String.fromCharCode(tt) + \"'\";\n\t\t}\n\t}\n}\n\nLexerATNSimulator.debug = false;\nLexerATNSimulator.dfa_debug = false;\n\nLexerATNSimulator.MIN_DFA_EDGE = 0;\nLexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN\n\nLexerATNSimulator.match_calls = 0;\n\nmodule.exports = LexerATNSimulator;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst LexerActionType = {\n    // The type of a {@link LexerChannelAction} action.\n    CHANNEL: 0,\n    // The type of a {@link LexerCustomAction} action\n    CUSTOM: 1,\n    // The type of a {@link LexerModeAction} action.\n    MODE: 2,\n    //The type of a {@link LexerMoreAction} action.\n    MORE: 3,\n    //The type of a {@link LexerPopModeAction} action.\n    POP_MODE: 4,\n    //The type of a {@link LexerPushModeAction} action.\n    PUSH_MODE: 5,\n    //The type of a {@link LexerSkipAction} action.\n    SKIP: 6,\n    //The type of a {@link LexerTypeAction} action.\n    TYPE: 7\n}\n\nclass LexerAction {\n    constructor(action) {\n        this.actionType = action;\n        this.isPositionDependent = false;\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        this.updateHashCode(hash);\n        return hash.finish()\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType);\n    }\n\n    equals(other) {\n        return this === other;\n    }\n}\n\n\n/**\n * Implements the {@code skip} lexer action by calling {@link Lexer//skip}.\n *\n * <p>The {@code skip} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerSkipAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.SKIP);\n    }\n\n    execute(lexer) {\n        lexer.skip();\n    }\n\n    toString() {\n        return \"skip\";\n    }\n}\n\n// Provides a singleton instance of this parameterless lexer action.\nLexerSkipAction.INSTANCE = new LexerSkipAction();\n\n/**\n * Implements the {@code type} lexer action by calling {@link Lexer//setType}\n * with the assigned type\n */\nclass LexerTypeAction extends LexerAction {\n    constructor(type) {\n        super(LexerActionType.TYPE);\n        this.type = type;\n    }\n\n    execute(lexer) {\n        lexer.type = this.type;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.type);\n    }\n\n    equals(other) {\n        if(this === other) {\n            return true;\n        } else if (! (other instanceof LexerTypeAction)) {\n            return false;\n        } else {\n            return this.type === other.type;\n        }\n    }\n\n    toString() {\n        return \"type(\" + this.type + \")\";\n    }\n}\n\n\n/**\n * Implements the {@code pushMode} lexer action by calling\n * {@link Lexer//pushMode} with the assigned mode\n */\nclass LexerPushModeAction extends LexerAction {\n    constructor(mode) {\n        super(LexerActionType.PUSH_MODE);\n        this.mode = mode;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//pushMode} with the\n     * value provided by {@link //getMode}.</p>\n     */\n    execute(lexer) {\n        lexer.pushMode(this.mode);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.mode);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerPushModeAction)) {\n            return false;\n        } else {\n            return this.mode === other.mode;\n        }\n    }\n\n    toString() {\n        return \"pushMode(\" + this.mode + \")\";\n    }\n}\n\n/**\n * Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.\n *\n * <p>The {@code popMode} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerPopModeAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.POP_MODE);\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n     */\n    execute(lexer) {\n        lexer.popMode();\n    }\n\n    toString() {\n        return \"popMode\";\n    }\n}\n\nLexerPopModeAction.INSTANCE = new LexerPopModeAction();\n\n/**\n * Implements the {@code more} lexer action by calling {@link Lexer//more}.\n *\n * <p>The {@code more} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerMoreAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.MORE);\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n     */\n    execute(lexer) {\n        lexer.more();\n    }\n\n    toString() {\n        return \"more\";\n    }\n}\n\nLexerMoreAction.INSTANCE = new LexerMoreAction();\n\n\n/**\n * Implements the {@code mode} lexer action by calling {@link Lexer//mode} with\n * the assigned mode\n */\nclass LexerModeAction extends LexerAction {\n    constructor(mode) {\n        super(LexerActionType.MODE);\n        this.mode = mode;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//mode} with the\n     * value provided by {@link //getMode}.</p>\n     */\n    execute(lexer) {\n        lexer.mode(this.mode);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.mode);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerModeAction)) {\n            return false;\n        } else {\n            return this.mode === other.mode;\n        }\n    }\n\n    toString() {\n        return \"mode(\" + this.mode + \")\";\n    }\n}\n\n/**\n * Executes a custom lexer action by calling {@link Recognizer//action} with the\n * rule and action indexes assigned to the custom action. The implementation of\n * a custom action is added to the generated code for the lexer in an override\n * of {@link Recognizer//action} when the grammar is compiled.\n *\n * <p>This class may represent embedded actions created with the <code>{...}</code>\n * syntax in ANTLR 4, as well as actions created for lexer commands where the\n * command argument could not be evaluated when the grammar was compiled.</p>\n */\nclass LexerCustomAction extends LexerAction {\n    /**\n     * Constructs a custom lexer action with the specified rule and action\n     * indexes.\n     *\n     * @param ruleIndex The rule index to use for calls to\n     * {@link Recognizer//action}.\n     * @param actionIndex The action index to use for calls to\n     * {@link Recognizer//action}.\n     */\n    constructor(ruleIndex, actionIndex) {\n        super(LexerActionType.CUSTOM);\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex;\n        this.isPositionDependent = true;\n    }\n\n    /**\n     * <p>Custom actions are implemented by calling {@link Lexer//action} with the\n     * appropriate rule and action indexes.</p>\n     */\n    execute(lexer) {\n        lexer.action(null, this.ruleIndex, this.actionIndex);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.ruleIndex, this.actionIndex);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerCustomAction)) {\n            return false;\n        } else {\n            return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n        }\n    }\n}\n\n/**\n * Implements the {@code channel} lexer action by calling\n * {@link Lexer//setChannel} with the assigned channel.\n * Constructs a new {@code channel} action with the specified channel value.\n * @param channel The channel value to pass to {@link Lexer//setChannel}\n */\nclass LexerChannelAction extends LexerAction {\n    constructor(channel) {\n        super(LexerActionType.CHANNEL);\n        this.channel = channel;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//setChannel} with the\n     * value provided by {@link //getChannel}.</p>\n     */\n    execute(lexer) {\n        lexer._channel = this.channel;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.channel);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerChannelAction)) {\n            return false;\n        } else {\n            return this.channel === other.channel;\n        }\n    }\n\n    toString() {\n        return \"channel(\" + this.channel + \")\";\n    }\n}\n\n\n/**\n * This implementation of {@link LexerAction} is used for tracking input offsets\n * for position-dependent actions within a {@link LexerActionExecutor}.\n *\n * <p>This action is not serialized as part of the ATN, and is only required for\n * position-dependent lexer actions which appear at a location other than the\n * end of a rule. For more information about DFA optimizations employed for\n * lexer actions, see {@link LexerActionExecutor//append} and\n * {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>\n *\n * Constructs a new indexed custom action by associating a character offset\n * with a {@link LexerAction}.\n *\n * <p>Note: This class is only required for lexer actions for which\n * {@link LexerAction//isPositionDependent} returns {@code true}.</p>\n *\n * @param offset The offset into the input {@link CharStream}, relative to\n * the token start index, at which the specified lexer action should be\n * executed.\n * @param action The lexer action to execute at a particular offset in the\n * input {@link CharStream}.\n */\nclass LexerIndexedCustomAction extends LexerAction {\n    constructor(offset, action) {\n        super(action.actionType);\n        this.offset = offset;\n        this.action = action;\n        this.isPositionDependent = true;\n    }\n\n    /**\n     * <p>This method calls {@link //execute} on the result of {@link //getAction}\n     * using the provided {@code lexer}.</p>\n     */\n    execute(lexer) {\n        // assume the input stream position was properly set by the calling code\n        this.action.execute(lexer);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.offset, this.action);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerIndexedCustomAction)) {\n            return false;\n        } else {\n            return this.offset === other.offset && this.action === other.action;\n        }\n    }\n}\n\nmodule.exports = {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerIndexedCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {hashStuff} = require(\"../Utils\");\nconst {LexerIndexedCustomAction} = require('./LexerAction');\n\nclass LexerActionExecutor {\n\t/**\n\t * Represents an executor for a sequence of lexer actions which traversed during\n\t * the matching operation of a lexer rule (token).\n\t *\n\t * <p>The executor tracks position information for position-dependent lexer actions\n\t * efficiently, ensuring that actions appearing only at the end of the rule do\n\t * not cause bloating of the {@link DFA} created for the lexer.</p>\n\t */\n\tconstructor(lexerActions) {\n\t\tthis.lexerActions = lexerActions === null ? [] : lexerActions;\n\t\t/**\n\t\t * Caches the result of {@link //hashCode} since the hash code is an element\n\t\t * of the performance-critical {@link LexerATNConfig//hashCode} operation\n\t\t */\n\t\tthis.cachedHashCode = hashStuff(lexerActions); // \"\".join([str(la) for la in\n\t\t// lexerActions]))\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which encodes the current offset\n\t * for position-dependent lexer actions.\n\t *\n\t * <p>Normally, when the executor encounters lexer actions where\n\t * {@link LexerAction//isPositionDependent} returns {@code true}, it calls\n\t * {@link IntStream//seek} on the input {@link CharStream} to set the input\n\t * position to the <em>end</em> of the current token. This behavior provides\n\t * for efficient DFA representation of lexer actions which appear at the end\n\t * of a lexer rule, even when the lexer rule matches a variable number of\n\t * characters.</p>\n\t *\n\t * <p>Prior to traversing a match transition in the ATN, the current offset\n\t * from the token start index is assigned to all position-dependent lexer\n\t * actions which have not already been assigned a fixed offset. By storing\n\t * the offsets relative to the token start index, the DFA representation of\n\t * lexer actions which appear in the middle of tokens remains efficient due\n\t * to sharing among tokens of the same length, regardless of their absolute\n\t * position in the input stream.</p>\n\t *\n\t * <p>If the current executor already has offsets assigned to all\n\t * position-dependent lexer actions, the method returns {@code this}.</p>\n\t *\n\t * @param offset The current offset to assign to all position-dependent\n\t * lexer actions which do not already have offsets assigned.\n\t *\n\t * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets\n\t * for all position-dependent lexer actions.\n\t */\n\tfixOffsetBeforeMatch(offset) {\n\t\tlet updatedLexerActions = null;\n\t\tfor (let i = 0; i < this.lexerActions.length; i++) {\n\t\t\tif (this.lexerActions[i].isPositionDependent &&\n\t\t\t\t\t!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {\n\t\t\t\tif (updatedLexerActions === null) {\n\t\t\t\t\tupdatedLexerActions = this.lexerActions.concat([]);\n\t\t\t\t}\n\t\t\t\tupdatedLexerActions[i] = new LexerIndexedCustomAction(offset,\n\t\t\t\t\t\tthis.lexerActions[i]);\n\t\t\t}\n\t\t}\n\t\tif (updatedLexerActions === null) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new LexerActionExecutor(updatedLexerActions);\n\t\t}\n\t}\n\n\t/**\n\t * Execute the actions encapsulated by this executor within the context of a\n\t * particular {@link Lexer}.\n\t *\n\t * <p>This method calls {@link IntStream//seek} to set the position of the\n\t * {@code input} {@link CharStream} prior to calling\n\t * {@link LexerAction//execute} on a position-dependent action. Before the\n\t * method returns, the input position will be restored to the same position\n\t * it was in when the method was invoked.</p>\n\t *\n\t * @param lexer The lexer instance.\n\t * @param input The input stream which is the source for the current token.\n\t * When this method is called, the current {@link IntStream//index} for\n\t * {@code input} should be the start of the following token, i.e. 1\n\t * character past the end of the current token.\n\t * @param startIndex The token start index. This value may be passed to\n\t * {@link IntStream//seek} to set the {@code input} position to the beginning\n\t * of the token.\n\t */\n\texecute(lexer, input, startIndex) {\n\t\tlet requiresSeek = false;\n\t\tconst stopIndex = input.index;\n\t\ttry {\n\t\t\tfor (let i = 0; i < this.lexerActions.length; i++) {\n\t\t\t\tlet lexerAction = this.lexerActions[i];\n\t\t\t\tif (lexerAction instanceof LexerIndexedCustomAction) {\n\t\t\t\t\tconst offset = lexerAction.offset;\n\t\t\t\t\tinput.seek(startIndex + offset);\n\t\t\t\t\tlexerAction = lexerAction.action;\n\t\t\t\t\trequiresSeek = (startIndex + offset) !== stopIndex;\n\t\t\t\t} else if (lexerAction.isPositionDependent) {\n\t\t\t\t\tinput.seek(stopIndex);\n\t\t\t\t\trequiresSeek = false;\n\t\t\t\t}\n\t\t\t\tlexerAction.execute(lexer);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (requiresSeek) {\n\t\t\t\tinput.seek(stopIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\thashCode() {\n\t\treturn this.cachedHashCode;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.cachedHashCode);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof LexerActionExecutor)) {\n\t\t\treturn false;\n\t\t} else if (this.cachedHashCode != other.cachedHashCode) {\n\t\t\treturn false;\n\t\t} else if (this.lexerActions.length != other.lexerActions.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tconst numActions = this.lexerActions.length\n\t\t\tfor (let idx = 0; idx < numActions; ++idx) {\n\t\t\t\tif (!this.lexerActions[idx].equals(other.lexerActions[idx])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which executes the actions for\n\t * the input {@code lexerActionExecutor} followed by a specified\n\t * {@code lexerAction}.\n\t *\n\t * @param lexerActionExecutor The executor for actions already traversed by\n\t * the lexer while matching a token within a particular\n\t * {@link LexerATNConfig}. If this is {@code null}, the method behaves as\n\t * though it were an empty executor.\n\t * @param lexerAction The lexer action to execute after the actions\n\t * specified in {@code lexerActionExecutor}.\n\t *\n\t * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions\n\t * of {@code lexerActionExecutor} and {@code lexerAction}.\n\t */\n\tstatic append(lexerActionExecutor, lexerAction) {\n\t\tif (lexerActionExecutor === null) {\n\t\t\treturn new LexerActionExecutor([ lexerAction ]);\n\t\t}\n\t\tconst lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);\n\t\treturn new LexerActionExecutor(lexerActions);\n\t}\n}\n\n\nmodule.exports = LexerActionExecutor;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Utils = require('./../Utils');\nconst {Set, BitSet, DoubleDict} = Utils;\n\nconst ATN = require('./ATN');\nconst {ATNState, RuleStopState} = require('./ATNState');\n\nconst {ATNConfig} = require('./ATNConfig');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {Token} = require('./../Token');\nconst {DFAState, PredPrediction} = require('./../dfa/DFAState');\nconst ATNSimulator = require('./ATNSimulator');\nconst PredictionMode = require('./PredictionMode');\nconst RuleContext = require('./../RuleContext');\nconst ParserRuleContext = require('./../ParserRuleContext');\nconst {SemanticContext} = require('./SemanticContext');\nconst {PredictionContext} = require('./../PredictionContext');\nconst {Interval} = require('./../IntervalSet');\nconst {Transition, SetTransition, NotSetTransition, RuleTransition, ActionTransition} = require('./Transition');\nconst {NoViableAltException} = require('./../error/Errors');\nconst {SingletonPredictionContext, predictionContextFromRuleContext} = require('./../PredictionContext');\n\n\n/**\n * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\n *\n * <p>\n * The basic complexity of the adaptive strategy makes it harder to understand.\n * We begin with ATN simulation to build paths in a DFA. Subsequent prediction\n * requests go through the DFA first. If they reach a state without an edge for\n * the current symbol, the algorithm fails over to the ATN simulation to\n * complete the DFA path for the current input (until it finds a conflict state\n * or uniquely predicting state).</p>\n *\n * <p>\n * All of that is done without using the outer context because we want to create\n * a DFA that is not dependent upon the rule invocation stack when we do a\n * prediction. One DFA works in all contexts. We avoid using context not\n * necessarily because it's slower, although it can be, but because of the DFA\n * caching problem. The closure routine only considers the rule invocation stack\n * created during prediction beginning in the decision rule. For example, if\n * prediction occurs without invoking another rule's ATN, there are no context\n * stacks in the configurations. When lack of context leads to a conflict, we\n * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\n * strategy (versus full LL(*)).</p>\n *\n * <p>\n * When SLL yields a configuration set with conflict, we rewind the input and\n * retry the ATN simulation, this time using full outer context without adding\n * to the DFA. Configuration context stacks will be the full invocation stacks\n * from the start rule. If we get a conflict using full context, then we can\n * definitively say we have a true ambiguity for that input sequence. If we\n * don't get a conflict, it implies that the decision is sensitive to the outer\n * context. (It is not context-sensitive in the sense of context-sensitive\n * grammars.)</p>\n *\n * <p>\n * The next time we reach this DFA state with an SLL conflict, through DFA\n * simulation, we will again retry the ATN simulation using full context mode.\n * This is slow because we can't save the results and have to \"interpret\" the\n * ATN each time we get that input.</p>\n *\n * <p>\n * <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>\n *\n * <p>\n * We could cache results from full context to predicted alternative easily and\n * that saves a lot of time but doesn't work in presence of predicates. The set\n * of visible predicates from the ATN start state changes depending on the\n * context, because closure can fall off the end of a rule. I tried to cache\n * tuples (stack context, semantic context, predicted alt) but it was slower\n * than interpreting and much more complicated. Also required a huge amount of\n * memory. The goal is not to create the world's fastest parser anyway. I'd like\n * to keep this algorithm simple. By launching multiple threads, we can improve\n * the speed of parsing across a large number of files.</p>\n *\n * <p>\n * There is no strict ordering between the amount of input used by SLL vs LL,\n * which makes it really hard to build a cache for full context. Let's say that\n * we have input A B C that leads to an SLL conflict with full context X. That\n * implies that using X we might only use A B but we could also use A B C D to\n * resolve conflict. Input A B C D could predict alternative 1 in one position\n * in the input and A B C E could predict alternative 2 in another position in\n * input. The conflicting SLL configurations could still be non-unique in the\n * full context prediction, which would lead us to requiring more input than the\n * original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\n * input\tused during the previous prediction. That amounts to a cache that maps\n * X to a specific DFA for that context.</p>\n *\n * <p>\n * Something should be done for left-recursive expression predictions. They are\n * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\n * with full LL thing Sam does.</p>\n *\n * <p>\n * <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>\n *\n * <p>\n * We avoid doing full context retry when the outer context is empty, we did not\n * dip into the outer context by falling off the end of the decision state rule,\n * or when we force SLL mode.</p>\n *\n * <p>\n * As an example of the not dip into outer context case, consider as super\n * constructor calls versus function calls. One grammar might look like\n * this:</p>\n *\n * <pre>\n * ctorBody\n *   : '{' superCall? stat* '}'\n *   ;\n * </pre>\n *\n * <p>\n * Or, you might see something like</p>\n *\n * <pre>\n * stat\n *   : superCall ';'\n *   | expression ';'\n *   | ...\n *   ;\n * </pre>\n *\n * <p>\n * In both cases I believe that no closure operations will dip into the outer\n * context. In the first case ctorBody in the worst case will stop at the '}'.\n * In the 2nd case it should stop at the ';'. Both cases should stay within the\n * entry rule and not dip into the outer context.</p>\n *\n * <p>\n * <strong>PREDICATES</strong></p>\n *\n * <p>\n * Predicates are always evaluated if present in either SLL or LL both. SLL and\n * LL simulation deals with predicates differently. SLL collects predicates as\n * it performs closure operations like ANTLR v3 did. It delays predicate\n * evaluation until it reaches and accept state. This allows us to cache the SLL\n * ATN simulation whereas, if we had evaluated predicates on-the-fly during\n * closure, the DFA state configuration sets would be different and we couldn't\n * build up a suitable DFA.</p>\n *\n * <p>\n * When building a DFA accept state during ATN simulation, we evaluate any\n * predicates and return the sole semantically valid alternative. If there is\n * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\n * we throw an exception. Alternatives without predicates act like they have\n * true predicates. The simple way to think about it is to strip away all\n * alternatives with false predicates and choose the minimum alternative that\n * remains.</p>\n *\n * <p>\n * When we start in the DFA and reach an accept state that's predicated, we test\n * those and return the minimum semantically viable alternative. If no\n * alternatives are viable, we throw an exception.</p>\n *\n * <p>\n * During full LL ATN simulation, closure always evaluates predicates and\n * on-the-fly. This is crucial to reducing the configuration set size during\n * closure. It hits a landmine when parsing with the Java grammar, for example,\n * without this on-the-fly evaluation.</p>\n *\n * <p>\n * <strong>SHARING DFA</strong></p>\n *\n * <p>\n * All instances of the same parser share the same decision DFAs through a\n * static field. Each instance gets its own ATN simulator but they share the\n * same {@link //decisionToDFA} field. They also share a\n * {@link PredictionContextCache} object that makes sure that all\n * {@link PredictionContext} objects are shared among the DFA states. This makes\n * a big size difference.</p>\n *\n * <p>\n * <strong>THREAD SAFETY</strong></p>\n *\n * <p>\n * The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when\n * it adds a new DFA object to that array. {@link //addDFAEdge}\n * locks on the DFA for the current decision when setting the\n * {@link DFAState//edges} field. {@link //addDFAState} locks on\n * the DFA for the current decision when looking up a DFA state to see if it\n * already exists. We must make sure that all requests to add DFA states that\n * are equivalent result in the same shared DFA object. This is because lots of\n * threads will be trying to update the DFA at once. The\n * {@link //addDFAState} method also locks inside the DFA lock\n * but this time on the shared context cache when it rebuilds the\n * configurations' {@link PredictionContext} objects using cached\n * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\n * safe as long as we can guarantee that all threads referencing\n * {@code s.edge[t]} get the same physical target {@link DFAState}, or\n * {@code null}. Once into the DFA, the DFA simulation does not reference the\n * {@link DFA//states} map. It follows the {@link DFAState//edges} field to new\n * targets. The DFA simulator will either find {@link DFAState//edges} to be\n * {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or\n * {@code dfa.edges[t]} to be non-null. The\n * {@link //addDFAEdge} method could be racing to set the field\n * but in either case the DFA simulator works; if {@code null}, and requests ATN\n * simulation. It could also race trying to get {@code dfa.edges[t]}, but either\n * way it will work because it's not doing a test and set operation.</p>\n *\n * <p>\n * <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage\n * Parsing)</strong></p>\n *\n * <p>\n * Sam pointed out that if SLL does not give a syntax error, then there is no\n * point in doing full LL, which is slower. We only have to try LL if we get a\n * syntax error. For maximum speed, Sam starts the parser set to pure SLL\n * mode with the {@link BailErrorStrategy}:</p>\n *\n * <pre>\n * parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};\n * parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\n * </pre>\n *\n * <p>\n * If it does not get a syntax error, then we're done. If it does get a syntax\n * error, we need to retry with the combined SLL/LL strategy.</p>\n *\n * <p>\n * The reason this works is as follows. If there are no SLL conflicts, then the\n * grammar is SLL (at least for that input set). If there is an SLL conflict,\n * the full LL analysis must yield a set of viable alternatives which is a\n * subset of the alternatives reported by SLL. If the LL set is a singleton,\n * then the grammar is LL but not SLL. If the LL set is the same size as the SLL\n * set, the decision is SLL. If the LL set has size &gt; 1, then that decision\n * is truly ambiguous on the current input. If the LL set is smaller, then the\n * SLL conflict resolution might choose an alternative that the full LL would\n * rule out as a possibility based upon better context information. If that's\n * the case, then the SLL parse will definitely get an error because the full LL\n * analysis says it's not viable. If SLL conflict resolution chooses an\n * alternative within the LL set, them both SLL and LL would choose the same\n * alternative because they both choose the minimum of multiple conflicting\n * alternatives.</p>\n *\n * <p>\n * Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and\n * a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL\n * parsing will get an error because SLL will pursue alternative 1. If\n * <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will\n * choose the same alternative because alternative one is the minimum of either\n * set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax\n * error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>\n *\n * <p>\n * Of course, if the input is invalid, then we will get an error for sure in\n * both SLL and LL parsing. Erroneous input will therefore require 2 passes over\n * the input.</p>\n */\nclass ParserATNSimulator extends ATNSimulator {\n    constructor(parser, atn, decisionToDFA, sharedContextCache) {\n        super(atn, sharedContextCache);\n        this.parser = parser;\n        this.decisionToDFA = decisionToDFA;\n        // SLL, LL, or LL + exact ambig detection?//\n        this.predictionMode = PredictionMode.LL;\n        // LAME globals to avoid parameters!!!!! I need these down deep in predTransition\n        this._input = null;\n        this._startIndex = 0;\n        this._outerContext = null;\n        this._dfa = null;\n        /**\n         * Each prediction operation uses a cache for merge of prediction contexts.\n         *  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap\n         *  isn't synchronized but we're ok since two threads shouldn't reuse same\n         *  parser/atnsim object because it can only handle one input at a time.\n         *  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid\n         *  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should\n         *  also be examined during cache lookup.\n         */\n        this.mergeCache = null;\n        this.debug = false;\n        this.debug_closure = false;\n        this.debug_add = false;\n        this.debug_list_atn_decisions = false;\n        this.dfa_debug = false;\n        this.retry_debug = false;\n    }\n\n    reset() {}\n\n    adaptivePredict(input, decision, outerContext) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"adaptivePredict decision \" + decision +\n                                   \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                   \" line \" + input.LT(1).line + \":\" +\n                                   input.LT(1).column);\n        }\n        this._input = input;\n        this._startIndex = input.index;\n        this._outerContext = outerContext;\n\n        const dfa = this.decisionToDFA[decision];\n        this._dfa = dfa;\n        const m = input.mark();\n        const index = input.index;\n\n        // Now we are certain to have a specific decision's DFA\n        // But, do we still need an initial state?\n        try {\n            let s0;\n            if (dfa.precedenceDfa) {\n                // the start state for a precedence DFA depends on the current\n                // parser precedence, and is provided by a DFA method.\n                s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n            } else {\n                // the start state for a \"regular\" DFA is just s0\n                s0 = dfa.s0;\n            }\n            if (s0===null) {\n                if (outerContext===null) {\n                    outerContext = RuleContext.EMPTY;\n                }\n                if (this.debug || this.debug_list_atn_decisions) {\n                    console.log(\"predictATN decision \" + dfa.decision +\n                                       \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                       \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n                }\n\n                const fullCtx = false;\n                let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);\n\n                if( dfa.precedenceDfa) {\n                    // If this is a precedence DFA, we use applyPrecedenceFilter\n                    // to convert the computed start state to a precedence start\n                    // state. We then use DFA.setPrecedenceStartState to set the\n                    // appropriate start state for the precedence level rather\n                    // than simply setting DFA.s0.\n                    //\n                    dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway\n                    s0_closure = this.applyPrecedenceFilter(s0_closure);\n                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                    dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n                } else {\n                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                    dfa.s0 = s0;\n                }\n            }\n            const alt = this.execATN(dfa, s0, input, index, outerContext);\n            if (this.debug) {\n                console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));\n            }\n            return alt;\n        } finally {\n            this._dfa = null;\n            this.mergeCache = null; // wack cache after each prediction\n            input.seek(index);\n            input.release(m);\n        }\n    }\n\n    /**\n     * Performs ATN simulation to compute a predicted alternative based\n     *  upon the remaining input, but also updates the DFA cache to avoid\n     *  having to traverse the ATN again for the same input sequence.\n     *\n     * There are some key conditions we're looking for after computing a new\n     * set of ATN configs (proposed DFA state):\n     *       if the set is empty, there is no viable alternative for current symbol\n     *       does the state uniquely predict an alternative?\n     *       does the state have a conflict that would prevent us from\n     *         putting it on the work list?\n     *\n     * We also have some key operations to do:\n     *       add an edge from previous DFA state to potentially new DFA state, D,\n     *         upon current symbol but only if adding to work list, which means in all\n     *         cases except no viable alternative (and possibly non-greedy decisions?)\n     *       collecting predicates and adding semantic context to DFA accept states\n     *       adding rule context to context-sensitive DFA accept states\n     *       consuming an input symbol\n     *       reporting a conflict\n     *       reporting an ambiguity\n     *       reporting a context sensitivity\n     *       reporting insufficient predicates\n     *\n     * cover these cases:\n     *    dead end\n     *    single alt\n     *    single alt + preds\n     *    conflict\n     *    conflict + preds\n     *\n     */\n    execATN(dfa, s0, input, startIndex, outerContext ) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"execATN decision \" + dfa.decision +\n                    \" exec LA(1)==\" + this.getLookaheadName(input) +\n                    \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n        }\n        let alt;\n        let previousD = s0;\n\n        if (this.debug) {\n            console.log(\"s0 = \" + s0);\n        }\n        let t = input.LA(1);\n        while(true) { // while more work\n            let D = this.getExistingTargetState(previousD, t);\n            if(D===null) {\n                D = this.computeTargetState(dfa, previousD, t);\n            }\n            if(D===ATNSimulator.ERROR) {\n                // if any configs in previous dipped into outer context, that\n                // means that input up to t actually finished entry rule\n                // at least for SLL decision. Full LL doesn't dip into outer\n                // so don't need special case.\n                // We will get an error no matter what so delay until after\n                // decision; better error message. Also, no reachable target\n                // ATN states in SLL implies LL will also get nowhere.\n                // If conflict in states that dip out, choose min since we\n                // will get error no matter what.\n                const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);\n                input.seek(startIndex);\n                alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);\n                if(alt!==ATN.INVALID_ALT_NUMBER) {\n                    return alt;\n                } else {\n                    throw e;\n                }\n            }\n            if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {\n                // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)\n                let conflictingAlts = null;\n                if (D.predicates!==null) {\n                    if (this.debug) {\n                        console.log(\"DFA state has preds in DFA sim LL failover\");\n                    }\n                    const conflictIndex = input.index;\n                    if(conflictIndex !== startIndex) {\n                        input.seek(startIndex);\n                    }\n                    conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);\n                    if (conflictingAlts.length===1) {\n                        if(this.debug) {\n                            console.log(\"Full LL avoided\");\n                        }\n                        return conflictingAlts.minValue();\n                    }\n                    if (conflictIndex !== startIndex) {\n                        // restore the index so reporting the fallback to full\n                        // context occurs with the index at the correct spot\n                        input.seek(conflictIndex);\n                    }\n                }\n                if (this.dfa_debug) {\n                    console.log(\"ctx sensitive state \" + outerContext +\" in \" + D);\n                }\n                const fullCtx = true;\n                const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n                this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);\n                alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);\n                return alt;\n            }\n            if (D.isAcceptState) {\n                if (D.predicates===null) {\n                    return D.prediction;\n                }\n                const stopIndex = input.index;\n                input.seek(startIndex);\n                const alts = this.evalSemanticContext(D.predicates, outerContext, true);\n                if (alts.length===0) {\n                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n                } else if (alts.length===1) {\n                    return alts.minValue();\n                } else {\n                    // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.\n                    this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);\n                    return alts.minValue();\n                }\n            }\n            previousD = D;\n\n            if (t !== Token.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n    }\n\n    /**\n     * Get an existing target state for an edge in the DFA. If the target state\n     * for the edge has not yet been computed or is otherwise not available,\n     * this method returns {@code null}.\n     *\n     * @param previousD The current DFA state\n     * @param t The next input symbol\n     * @return The existing target DFA state for the given input symbol\n     * {@code t}, or {@code null} if the target state for this edge is not\n     * already cached\n     */\n    getExistingTargetState(previousD, t) {\n        const edges = previousD.edges;\n        if (edges===null) {\n            return null;\n        } else {\n            return edges[t + 1] || null;\n        }\n    }\n\n    /**\n     * Compute a target state for an edge in the DFA, and attempt to add the\n     * computed state and corresponding edge to the DFA.\n     *\n     * @param dfa The DFA\n     * @param previousD The current DFA state\n     * @param t The next input symbol\n     *\n     * @return The computed target DFA state for the given input symbol\n     * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n     * returns {@link //ERROR\n     */\n    computeTargetState(dfa, previousD, t) {\n       const reach = this.computeReachSet(previousD.configs, t, false);\n        if(reach===null) {\n            this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n            return ATNSimulator.ERROR;\n        }\n        // create new target state; we'll add to DFA after it's complete\n        let D = new DFAState(null, reach);\n\n        const predictedAlt = this.getUniqueAlt(reach);\n\n        if (this.debug) {\n            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n            console.log(\"SLL altSubSets=\" + Utils.arrayToString(altSubSets) +\n                        /*\", previous=\" + previousD.configs + */\n                        \", configs=\" + reach +\n                        \", predict=\" + predictedAlt +\n                        \", allSubsetsConflict=\" +\n                        PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" +\n                        this.getConflictingAlts(reach));\n        }\n        if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {\n            // NO CONFLICT, UNIQUELY PREDICTED ALT\n            D.isAcceptState = true;\n            D.configs.uniqueAlt = predictedAlt;\n            D.prediction = predictedAlt;\n        } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n            // MORE THAN ONE VIABLE ALTERNATIVE\n            D.configs.conflictingAlts = this.getConflictingAlts(reach);\n            D.requiresFullContext = true;\n            // in SLL-only mode, we will stop at this state and return the minimum alt\n            D.isAcceptState = true;\n            D.prediction = D.configs.conflictingAlts.minValue();\n        }\n        if (D.isAcceptState && D.configs.hasSemanticContext) {\n            this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n            if( D.predicates!==null) {\n                D.prediction = ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        // all adds to dfa are done after we've created full D state\n        D = this.addDFAEdge(dfa, previousD, t, D);\n        return D;\n    }\n\n    predicateDFAState(dfaState, decisionState) {\n        // We need to test all predicates, even in DFA states that\n        // uniquely predict alternative.\n        const nalts = decisionState.transitions.length;\n        // Update DFA so reach becomes accept state with (predicate,alt)\n        // pairs if preds found for conflicting alts\n        const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n        const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);\n        if (altToPred!==null) {\n            dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n            dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds\n        } else {\n            // There are preds in configs but they might go away\n            // when OR'd together like {p}? || NONE == NONE. If neither\n            // alt has preds, resolve to min alt\n            dfaState.prediction = altsToCollectPredsFrom.minValue();\n        }\n    }\n\n// comes back with reach.uniqueAlt set to a valid alt\n    execATNWithFullContext(dfa, D, // how far we got before failing over\n                                         s0,\n                                         input,\n                                         startIndex,\n                                         outerContext) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"execATNWithFullContext \"+s0);\n        }\n        const fullCtx = true;\n        let foundExactAmbig = false;\n        let reach;\n        let previous = s0;\n        input.seek(startIndex);\n        let t = input.LA(1);\n        let predictedAlt = -1;\n        while (true) { // while more work\n            reach = this.computeReachSet(previous, t, fullCtx);\n            if (reach===null) {\n                // if any configs in previous dipped into outer context, that\n                // means that input up to t actually finished entry rule\n                // at least for LL decision. Full LL doesn't dip into outer\n                // so don't need special case.\n                // We will get an error no matter what so delay until after\n                // decision; better error message. Also, no reachable target\n                // ATN states in SLL implies LL will also get nowhere.\n                // If conflict in states that dip out, choose min since we\n                // will get error no matter what.\n                const e = this.noViableAlt(input, outerContext, previous, startIndex);\n                input.seek(startIndex);\n                const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n                if(alt!==ATN.INVALID_ALT_NUMBER) {\n                    return alt;\n                } else {\n                    throw e;\n                }\n            }\n            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n            if(this.debug) {\n                console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" +\n                      PredictionMode.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" +\n                      PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n            }\n            reach.uniqueAlt = this.getUniqueAlt(reach);\n            // unique prediction?\n            if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {\n                predictedAlt = reach.uniqueAlt;\n                break;\n            } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n                predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n                if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n                    break;\n                }\n            } else {\n                // In exact ambiguity mode, we never try to terminate early.\n                // Just keeps scarfing until we know what the conflict is\n                if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {\n                    foundExactAmbig = true;\n                    predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                    break;\n                }\n                // else there are multiple non-conflicting subsets or\n                // we're not sure what the ambiguity is yet.\n                // So, keep going.\n            }\n            previous = reach;\n            if( t !== Token.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n        // If the configuration set uniquely predicts an alternative,\n        // without conflict, then we know that it's a full LL decision\n        // not SLL.\n        if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {\n            this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n            return predictedAlt;\n        }\n        // We do not check predicates here because we have checked them\n        // on-the-fly when doing full context prediction.\n\n        //\n        // In non-exact ambiguity detection mode, we might\tactually be able to\n        // detect an exact ambiguity, but I'm not going to spend the cycles\n        // needed to check. We only emit ambiguity warnings in exact ambiguity\n        // mode.\n        //\n        // For example, we might know that we have conflicting configurations.\n        // But, that does not mean that there is no way forward without a\n        // conflict. It's possible to have nonconflicting alt subsets as in:\n\n        // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n        // from\n        //\n        //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n        //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n        //\n        // In this case, (17,1,[5 $]) indicates there is some next sequence that\n        // would resolve this without conflict to alternative 1. Any other viable\n        // next sequence, however, is associated with a conflict.  We stop\n        // looking for input because no amount of further lookahead will alter\n        // the fact that we should predict alternative 1.  We just can't say for\n        // sure that there is an ambiguity without looking further.\n\n        this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);\n\n        return predictedAlt;\n    }\n\n    computeReachSet(closure, t, fullCtx) {\n        if (this.debug) {\n            console.log(\"in computeReachSet, starting closure: \" + closure);\n        }\n        if( this.mergeCache===null) {\n            this.mergeCache = new DoubleDict();\n        }\n        const intermediate = new ATNConfigSet(fullCtx);\n\n        // Configurations already in a rule stop state indicate reaching the end\n        // of the decision rule (local context) or end of the start rule (full\n        // context). Once reached, these configurations are never updated by a\n        // closure operation, so they are handled separately for the performance\n        // advantage of having a smaller intermediate set when calling closure.\n        //\n        // For full-context reach operations, separate handling is required to\n        // ensure that the alternative matching the longest overall sequence is\n        // chosen when multiple such configurations can match the input.\n\n        let skippedStopStates = null;\n\n        // First figure out where we can reach on input t\n        for (let i=0; i<closure.items.length;i++) {\n            const c = closure.items[i];\n            if(this.debug) {\n                console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n            }\n            if (c.state instanceof RuleStopState) {\n                if (fullCtx || t === Token.EOF) {\n                    if (skippedStopStates===null) {\n                        skippedStopStates = [];\n                    }\n                    skippedStopStates.push(c);\n                    if(this.debug_add) {\n                        console.log(\"added \" + c + \" to skippedStopStates\");\n                    }\n                }\n                continue;\n            }\n            for(let j=0;j<c.state.transitions.length;j++) {\n                const trans = c.state.transitions[j];\n                const target = this.getReachableTarget(trans, t);\n                if (target!==null) {\n                    const cfg = new ATNConfig({state:target}, c);\n                    intermediate.add(cfg, this.mergeCache);\n                    if(this.debug_add) {\n                        console.log(\"added \" + cfg + \" to intermediate\");\n                    }\n                }\n            }\n        }\n        // Now figure out where the reach operation can take us...\n        let reach = null;\n\n        // This block optimizes the reach operation for intermediate sets which\n        // trivially indicate a termination state for the overall\n        // adaptivePredict operation.\n        //\n        // The conditions assume that intermediate\n        // contains all configurations relevant to the reach set, but this\n        // condition is not true when one or more configurations have been\n        // withheld in skippedStopStates, or when the current symbol is EOF.\n        //\n        if (skippedStopStates===null && t!==Token.EOF) {\n            if (intermediate.items.length===1) {\n                // Don't pursue the closure if there is just one state.\n                // It can only have one alternative; just add to result\n                // Also don't pursue the closure if there is unique alternative\n                // among the configurations.\n                reach = intermediate;\n            } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {\n                // Also don't pursue the closure if there is unique alternative\n                // among the configurations.\n                reach = intermediate;\n            }\n        }\n        // If the reach set could not be trivially determined, perform a closure\n        // operation on the intermediate set to compute its initial value.\n        //\n        if (reach===null) {\n            reach = new ATNConfigSet(fullCtx);\n            const closureBusy = new Set();\n            const treatEofAsEpsilon = t === Token.EOF;\n            for (let k=0; k<intermediate.items.length;k++) {\n                this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n            }\n        }\n        if (t === Token.EOF) {\n            // After consuming EOF no additional input is possible, so we are\n            // only interested in configurations which reached the end of the\n            // decision rule (local context) or end of the start rule (full\n            // context). Update reach to contain only these configurations. This\n            // handles both explicit EOF transitions in the grammar and implicit\n            // EOF transitions following the end of the decision or start rule.\n            //\n            // When reach==intermediate, no closure operation was performed. In\n            // this case, removeAllConfigsNotInRuleStopState needs to check for\n            // reachable rule stop states as well as configurations already in\n            // a rule stop state.\n            //\n            // This is handled before the configurations in skippedStopStates,\n            // because any configurations potentially added from that list are\n            // already guaranteed to meet this condition whether or not it's\n            // required.\n            //\n            reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n        }\n        // If skippedStopStates!==null, then it contains at least one\n        // configuration. For full-context reach operations, these\n        // configurations reached the end of the start rule, in which case we\n        // only add them back to reach if no configuration during the current\n        // closure operation reached such a state. This ensures adaptivePredict\n        // chooses an alternative matching the longest overall sequence when\n        // multiple alternatives are viable.\n        //\n        if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {\n            for (let l=0; l<skippedStopStates.length;l++) {\n                reach.add(skippedStopStates[l], this.mergeCache);\n            }\n        }\n        if (reach.items.length===0) {\n            return null;\n        } else {\n            return reach;\n        }\n    }\n\n    /**\n     * Return a configuration set containing only the configurations from\n     * {@code configs} which are in a {@link RuleStopState}. If all\n     * configurations in {@code configs} are already in a rule stop state, this\n     * method simply returns {@code configs}.\n     *\n     * <p>When {@code lookToEndOfRule} is true, this method uses\n     * {@link ATN//nextTokens} for each configuration in {@code configs} which is\n     * not already in a rule stop state to see if a rule stop state is reachable\n     * from the configuration via epsilon-only transitions.</p>\n     *\n     * @param configs the configuration set to update\n     * @param lookToEndOfRule when true, this method checks for rule stop states\n     * reachable by epsilon-only transitions from each configuration in\n     * {@code configs}.\n     *\n     * @return {@code configs} if all configurations in {@code configs} are in a\n     * rule stop state, otherwise return a new configuration set containing only\n     * the configurations from {@code configs} which are in a rule stop state\n     */\n    removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {\n        if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return configs;\n        }\n        const result = new ATNConfigSet(configs.fullCtx);\n        for(let i=0; i<configs.items.length;i++) {\n            const config = configs.items[i];\n            if (config.state instanceof RuleStopState) {\n                result.add(config, this.mergeCache);\n                continue;\n            }\n            if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n                const nextTokens = this.atn.nextTokens(config.state);\n                if (nextTokens.contains(Token.EPSILON)) {\n                    const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n                    result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);\n                }\n            }\n        }\n        return result;\n    }\n\n    computeStartState(p, ctx, fullCtx) {\n        // always at least the implicit call to start rule\n        const initialContext = predictionContextFromRuleContext(this.atn, ctx);\n        const configs = new ATNConfigSet(fullCtx);\n        for(let i=0;i<p.transitions.length;i++) {\n            const target = p.transitions[i].target;\n            const c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);\n            const closureBusy = new Set();\n            this.closure(c, configs, closureBusy, true, fullCtx, false);\n        }\n        return configs;\n    }\n\n    /**\n     * This method transforms the start state computed by\n     * {@link //computeStartState} to the special start state used by a\n     * precedence DFA for a particular precedence value. The transformation\n     * process applies the following changes to the start state's configuration\n     * set.\n     *\n     * <ol>\n     * <li>Evaluate the precedence predicates for each configuration using\n     * {@link SemanticContext//evalPrecedence}.</li>\n     * <li>Remove all configurations which predict an alternative greater than\n     * 1, for which another configuration that predicts alternative 1 is in the\n     * same ATN state with the same prediction context. This transformation is\n     * valid for the following reasons:\n     * <ul>\n     * <li>The closure block cannot contain any epsilon transitions which bypass\n     * the body of the closure, so all states reachable via alternative 1 are\n     * part of the precedence alternatives of the transformed left-recursive\n     * rule.</li>\n     * <li>The \"primary\" portion of a left recursive rule cannot contain an\n     * epsilon transition, so the only way an alternative other than 1 can exist\n     * in a state that is also reachable via alternative 1 is by nesting calls\n     * to the left-recursive rule, with the outer calls not being at the\n     * preferred precedence level.</li>\n     * </ul>\n     * </li>\n     * </ol>\n     *\n     * <p>\n     * The prediction context must be considered by this filter to address\n     * situations like the following.\n     * </p>\n     * <code>\n     * <pre>\n     * grammar TA;\n     * prog: statement* EOF;\n     * statement: letterA | statement letterA 'b' ;\n     * letterA: 'a';\n     * </pre>\n     * </code>\n     * <p>\n     * If the above grammar, the ATN state immediately before the token\n     * reference {@code 'a'} in {@code letterA} is reachable from the left edge\n     * of both the primary and closure blocks of the left-recursive rule\n     * {@code statement}. The prediction context associated with each of these\n     * configurations distinguishes between them, and prevents the alternative\n     * which stepped out to {@code prog} (and then back in to {@code statement}\n     * from being eliminated by the filter.\n     * </p>\n     *\n     * @param configs The configuration set computed by\n     * {@link //computeStartState} as the start state for the DFA.\n     * @return The transformed configuration set representing the start state\n     * for a precedence DFA at a particular precedence level (determined by\n     * calling {@link Parser//getPrecedence})\n     */\n    applyPrecedenceFilter(configs) {\n        let config;\n        const statesFromAlt1 = [];\n        const configSet = new ATNConfigSet(configs.fullCtx);\n        for(let i=0; i<configs.items.length; i++) {\n            config = configs.items[i];\n            // handle alt 1 first\n            if (config.alt !== 1) {\n                continue;\n            }\n            const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);\n            if (updatedContext===null) {\n                // the configuration was eliminated\n                continue;\n            }\n            statesFromAlt1[config.state.stateNumber] = config.context;\n            if (updatedContext !== config.semanticContext) {\n                configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);\n            } else {\n                configSet.add(config, this.mergeCache);\n            }\n        }\n        for(let i=0; i<configs.items.length; i++) {\n            config = configs.items[i];\n            if (config.alt === 1) {\n                // already handled\n                continue;\n            }\n            // In the future, this elimination step could be updated to also\n            // filter the prediction context for alternatives predicting alt>1\n            // (basically a graph subtraction algorithm).\n            if (!config.precedenceFilterSuppressed) {\n                const context = statesFromAlt1[config.state.stateNumber] || null;\n                if (context!==null && context.equals(config.context)) {\n                    // eliminated\n                    continue;\n                }\n            }\n            configSet.add(config, this.mergeCache);\n        }\n        return configSet;\n    }\n\n    getReachableTarget(trans, ttype) {\n        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n            return trans.target;\n        } else {\n            return null;\n        }\n    }\n\n    getPredsForAmbigAlts(ambigAlts, configs, nalts) {\n        // REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n        // altToPred starts as an array of all null contexts. The entry at index i\n        // corresponds to alternative i. altToPred[i] may have one of three values:\n        //   1. null: no ATNConfig c is found such that c.alt==i\n        //   2. SemanticContext.NONE: At least one ATNConfig c exists such that\n        //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,\n        //      alt i has at least one unpredicated config.\n        //   3. Non-NONE Semantic Context: There exists at least one, and for all\n        //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.\n        //\n        // From this, it is clear that NONE||anything==NONE.\n        //\n        let altToPred = [];\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if(ambigAlts.contains( c.alt )) {\n                altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);\n            }\n        }\n        let nPredAlts = 0;\n        for (let i =1;i< nalts+1;i++) {\n            const pred = altToPred[i] || null;\n            if (pred===null) {\n                altToPred[i] = SemanticContext.NONE;\n            } else if (pred !== SemanticContext.NONE) {\n                nPredAlts += 1;\n            }\n        }\n        // nonambig alts are null in altToPred\n        if (nPredAlts===0) {\n            altToPred = null;\n        }\n        if (this.debug) {\n            console.log(\"getPredsForAmbigAlts result \" + Utils.arrayToString(altToPred));\n        }\n        return altToPred;\n    }\n\n    getPredicatePredictions(ambigAlts, altToPred) {\n        const pairs = [];\n        let containsPredicate = false;\n        for (let i=1; i<altToPred.length;i++) {\n            const pred = altToPred[i];\n            // unpredicated is indicated by SemanticContext.NONE\n            if( ambigAlts!==null && ambigAlts.contains( i )) {\n                pairs.push(new PredPrediction(pred, i));\n            }\n            if (pred !== SemanticContext.NONE) {\n                containsPredicate = true;\n            }\n        }\n        if (! containsPredicate) {\n            return null;\n        }\n        return pairs;\n    }\n\n    /**\n     * This method is used to improve the localization of error messages by\n     * choosing an alternative rather than throwing a\n     * {@link NoViableAltException} in particular prediction scenarios where the\n     * {@link //ERROR} state was reached during ATN simulation.\n     *\n     * <p>\n     * The default implementation of this method uses the following\n     * algorithm to identify an ATN configuration which successfully parsed the\n     * decision entry rule. Choosing such an alternative ensures that the\n     * {@link ParserRuleContext} returned by the calling rule will be complete\n     * and valid, and the syntax error will be reported later at a more\n     * localized location.</p>\n     *\n     * <ul>\n     * <li>If a syntactically valid path or paths reach the end of the decision rule and\n     * they are semantically valid if predicated, return the min associated alt.</li>\n     * <li>Else, if a semantically invalid but syntactically valid path exist\n     * or paths exist, return the minimum associated alt.\n     * </li>\n     * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>\n     * </ul>\n     *\n     * <p>\n     * In some scenarios, the algorithm described above could predict an\n     * alternative which will result in a {@link FailedPredicateException} in\n     * the parser. Specifically, this could occur if the <em>only</em> configuration\n     * capable of successfully parsing to the end of the decision rule is\n     * blocked by a semantic predicate. By choosing this alternative within\n     * {@link //adaptivePredict} instead of throwing a\n     * {@link NoViableAltException}, the resulting\n     * {@link FailedPredicateException} in the parser will identify the specific\n     * predicate which is preventing the parser from successfully parsing the\n     * decision rule, which helps developers identify and correct logic errors\n     * in semantic predicates.\n     * </p>\n     *\n     * @param configs The ATN configurations which were valid immediately before\n     * the {@link //ERROR} state was reached\n     * @param outerContext The is the \\gamma_0 initial parser context from the paper\n     * or the parser stack at the instant before prediction commences.\n     *\n     * @return The value to return from {@link //adaptivePredict}, or\n     * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not\n     * identified and {@link //adaptivePredict} should report an error instead\n     */\n    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {\n        const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);\n        const semValidConfigs = cfgs[0];\n        const semInvalidConfigs = cfgs[1];\n        let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n        if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists\n            return alt;\n        }\n        // Is there a syntactically valid path with a failed pred?\n        if (semInvalidConfigs.items.length>0) {\n            alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n            if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists\n                return alt;\n            }\n        }\n        return ATN.INVALID_ALT_NUMBER;\n    }\n\n    getAltThatFinishedDecisionEntryRule(configs) {\n        const alts = [];\n        for(let i=0;i<configs.items.length; i++) {\n            const c = configs.items[i];\n            if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {\n                if(alts.indexOf(c.alt)<0) {\n                    alts.push(c.alt);\n                }\n            }\n        }\n        if (alts.length===0) {\n            return ATN.INVALID_ALT_NUMBER;\n        } else {\n            return Math.min.apply(null, alts);\n        }\n    }\n\n    /**\n     * Walk the list of configurations and split them according to\n     * those that have preds evaluating to true/false.  If no pred, assume\n     * true pred and include in succeeded set.  Returns Pair of sets.\n     *\n     * Create a new set so as not to alter the incoming parameter.\n     *\n     * Assumption: the input stream has been restored to the starting point\n     * prediction, which is where predicates need to evaluate.*/\n    splitAccordingToSemanticValidity( configs, outerContext) {\n        const succeeded = new ATNConfigSet(configs.fullCtx);\n        const failed = new ATNConfigSet(configs.fullCtx);\n        for(let i=0;i<configs.items.length; i++) {\n            const c = configs.items[i];\n            if (c.semanticContext !== SemanticContext.NONE) {\n                const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n                if (predicateEvaluationResult) {\n                    succeeded.add(c);\n                } else {\n                    failed.add(c);\n                }\n            } else {\n                succeeded.add(c);\n            }\n        }\n        return [succeeded, failed];\n    }\n\n    /**\n     * Look through a list of predicate/alt pairs, returning alts for the\n     * pairs that win. A {@code NONE} predicate indicates an alt containing an\n     * unpredicated config which behaves as \"always true.\" If !complete\n     * then we stop at the first predicate that evaluates to true. This\n     * includes pairs with null predicates.\n     */\n    evalSemanticContext(predPredictions, outerContext, complete) {\n        const predictions = new BitSet();\n        for(let i=0;i<predPredictions.length;i++) {\n            const pair = predPredictions[i];\n            if (pair.pred === SemanticContext.NONE) {\n                predictions.add(pair.alt);\n                if (! complete) {\n                    break;\n                }\n                continue;\n            }\n            const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n            if (this.debug || this.dfa_debug) {\n                console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n            }\n            if (predicateEvaluationResult) {\n                if (this.debug || this.dfa_debug) {\n                    console.log(\"PREDICT \" + pair.alt);\n                }\n                predictions.add(pair.alt);\n                if (! complete) {\n                    break;\n                }\n            }\n        }\n        return predictions;\n    }\n\n// TODO: If we are doing predicates, there is no point in pursuing\n//     closure operations if we reach a DFA state that uniquely predicts\n//     alternative. We will not be caching that DFA state and it is a\n//     waste to pursue the closure. Might have to advance when we do\n//     ambig detection thought :(\n//\n    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n        const initialDepth = 0;\n        this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,\n                                 fullCtx, initialDepth, treatEofAsEpsilon);\n    }\n\n    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        if (this.debug || this.debug_closure) {\n            console.log(\"closure(\" + config.toString(this.parser,true) + \")\");\n            // console.log(\"configs(\" + configs.toString() + \")\");\n            if(config.reachesIntoOuterContext>50) {\n                throw \"problem\";\n            }\n        }\n        if (config.state instanceof RuleStopState) {\n            // We hit rule end. If we have context info, use it\n            // run thru all possible stack tops in ctx\n            if (! config.context.isEmpty()) {\n                for (let i =0; i<config.context.length; i++) {\n                    if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {\n                        if (fullCtx) {\n                            configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);\n                            continue;\n                        } else {\n                            // we have no context info, just chase follow links (if greedy)\n                            if (this.debug) {\n                                console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                            }\n                            this.closure_(config, configs, closureBusy, collectPredicates,\n                                     fullCtx, depth, treatEofAsEpsilon);\n                        }\n                        continue;\n                    }\n                    const returnState = this.atn.states[config.context.getReturnState(i)];\n                    const newContext = config.context.getParent(i); // \"pop\" return state\n                    const parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};\n                    const c = new ATNConfig(parms, null);\n                    // While we have context to pop back from, we may have\n                    // gotten that context AFTER having falling off a rule.\n                    // Make sure we track that we are now out of context.\n                    c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n                    this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);\n                }\n                return;\n            } else if( fullCtx) {\n                // reached end of start rule\n                configs.add(config, this.mergeCache);\n                return;\n            } else {\n                // else if we have no context info, just chase follow links (if greedy)\n                if (this.debug) {\n                    console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                }\n            }\n        }\n        this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n    }\n\n    // Do the actual work of walking epsilon edges//\n    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        const p = config.state;\n        // optimization\n        if (! p.epsilonOnlyTransitions) {\n            configs.add(config, this.mergeCache);\n            // make sure to not return here, because EOF transitions can act as\n            // both epsilon transitions and non-epsilon transitions.\n        }\n        for(let i = 0;i<p.transitions.length; i++) {\n            if(i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))\n                continue;\n\n            const t = p.transitions[i];\n            const continueCollecting = collectPredicates && !(t instanceof ActionTransition);\n            const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n            if (c!==null) {\n                let newDepth = depth;\n                if ( config.state instanceof RuleStopState) {\n                    // target fell off end of rule; mark resulting c as having dipped into outer context\n                    // We can't get here if incoming config was rule stop and we had context\n                    // track how far we dip into outer context.  Might\n                    // come in handy and we avoid evaluating context dependent\n                    // preds if this is > 0.\n                    if (this._dfa !== null && this._dfa.precedenceDfa) {\n                        if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {\n                            c.precedenceFilterSuppressed = true;\n                        }\n                    }\n\n                    c.reachesIntoOuterContext += 1;\n                    if (closureBusy.add(c)!==c) {\n                        // avoid infinite recursion for right-recursive rules\n                        continue;\n                    }\n                    configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n                    newDepth -= 1;\n                    if (this.debug) {\n                        console.log(\"dips into outer ctx: \" + c);\n                    }\n                } else {\n                    if (!t.isEpsilon && closureBusy.add(c)!==c){\n                        // avoid infinite recursion for EOF* and EOF+\n                        continue;\n                    }\n                    if (t instanceof RuleTransition) {\n                        // latch when newDepth goes negative - once we step out of the entry context we can't return\n                        if (newDepth >= 0) {\n                            newDepth += 1;\n                        }\n                    }\n                }\n                this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n            }\n        }\n    }\n\n    canDropLoopEntryEdgeInLeftRecursiveRule(config) {\n        // return False\n        const p = config.state;\n        // First check to see if we are in StarLoopEntryState generated during\n        // left-recursion elimination. For efficiency, also check if\n        // the context has an empty stack case. If so, it would mean\n        // global FOLLOW so we can't perform optimization\n        // Are we the special loop entry/exit state? or SLL wildcard\n        if(p.stateType !== ATNState.STAR_LOOP_ENTRY)\n            return false;\n        if(p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||\n               config.context.isEmpty() || config.context.hasEmptyPath())\n            return false;\n\n        // Require all return states to return back to the same rule that p is in.\n        const numCtxs = config.context.length;\n        for(let i=0; i<numCtxs; i++) { // for each stack context\n            const returnState = this.atn.states[config.context.getReturnState(i)];\n            if (returnState.ruleIndex !== p.ruleIndex)\n                return false;\n        }\n\n        const decisionStartState = p.transitions[0].target;\n        const blockEndStateNum = decisionStartState.endState.stateNumber;\n        const blockEndState = this.atn.states[blockEndStateNum];\n\n        // Verify that the top of each stack context leads to loop entry/exit\n        // state through epsilon edges and w/o leaving rule.\n        for(let i=0; i<numCtxs; i++) { // for each stack context\n            const returnStateNumber = config.context.getReturnState(i);\n            const returnState = this.atn.states[returnStateNumber];\n            // all states must have single outgoing epsilon edge\n            if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)\n                return false;\n\n            // Look for prefix op case like 'not expr', (' type ')' expr\n            const returnStateTarget = returnState.transitions[0].target;\n            if ( returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p )\n                continue;\n\n            // Look for 'expr op expr' or case where expr's return state is block end\n            // of (...)* internal block; the block end points to loop back\n            // which points to p but we don't need to check that\n            if ( returnState === blockEndState )\n                continue;\n\n            // Look for ternary expr ? expr : expr. The return state points at block end,\n            // which points at loop entry state\n            if ( returnStateTarget === blockEndState )\n                continue;\n\n            // Look for complex prefix 'between expr and expr' case where 2nd expr's\n            // return state points at block end state of (...)* internal block\n            if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1\n                    && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)\n                continue;\n\n            // anything else ain't conforming\n            return false;\n        }\n        return true;\n    }\n\n    getRuleName(index) {\n        if (this.parser!==null && index>=0) {\n            return this.parser.ruleNames[index];\n        } else {\n            return \"<rule \" + index + \">\";\n        }\n    }\n\n    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n        switch(t.serializationType) {\n        case Transition.RULE:\n            return this.ruleTransition(config, t);\n        case Transition.PRECEDENCE:\n            return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.PREDICATE:\n            return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.ACTION:\n            return this.actionTransition(config, t);\n        case Transition.EPSILON:\n            return new ATNConfig({state:t.target}, config);\n        case Transition.ATOM:\n        case Transition.RANGE:\n        case Transition.SET:\n            // EOF transitions act like epsilon transitions after the first EOF\n            // transition is traversed\n            if (treatEofAsEpsilon) {\n                if (t.matches(Token.EOF, 0, 1)) {\n                    return new ATNConfig({state: t.target}, config);\n                }\n            }\n            return null;\n        default:\n            return null;\n        }\n    }\n\n    actionTransition(config, t) {\n        if (this.debug) {\n            const index = t.actionIndex === -1 ? 65535 : t.actionIndex;\n            console.log(\"ACTION edge \" + t.ruleIndex + \":\" + index);\n        }\n        return new ATNConfig({state:t.target}, config);\n    }\n\n    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (this.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n                    pt.precedence + \">=_p, ctx dependent=true\");\n            if (this.parser!==null) {\n                console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n            }\n        }\n        let c = null;\n        if (collectPredicates && inContext) {\n            if (fullCtx) {\n                // In full context mode, we can evaluate predicates on-the-fly\n                // during closure, which dramatically reduces the size of\n                // the config sets. It also obviates the need to test predicates\n                // later during conflict resolution.\n                const currentPosition = this._input.index;\n                this._input.seek(this._startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n                this._input.seek(currentPosition);\n                if (predSucceeds) {\n                    c = new ATNConfig({state:pt.target}, config); // no pred context\n                }\n            } else {\n                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n            }\n        } else {\n            c = new ATNConfig({state:pt.target}, config);\n        }\n        if (this.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n\n    predTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (this.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex +\n                    \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n            if (this.parser!==null) {\n                console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n            }\n        }\n        let c = null;\n        if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {\n            if (fullCtx) {\n                // In full context mode, we can evaluate predicates on-the-fly\n                // during closure, which dramatically reduces the size of\n                // the config sets. It also obviates the need to test predicates\n                // later during conflict resolution.\n                const currentPosition = this._input.index;\n                this._input.seek(this._startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n                this._input.seek(currentPosition);\n                if (predSucceeds) {\n                    c = new ATNConfig({state:pt.target}, config); // no pred context\n                }\n            } else {\n                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n            }\n        } else {\n            c = new ATNConfig({state:pt.target}, config);\n        }\n        if (this.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n\n    ruleTransition(config, t) {\n        if (this.debug) {\n            console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n        }\n        const returnState = t.followState;\n        const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);\n        return new ATNConfig({state:t.target, context:newContext}, config );\n    }\n\n    getConflictingAlts(configs) {\n        const altsets = PredictionMode.getConflictingAltSubsets(configs);\n        return PredictionMode.getAlts(altsets);\n    }\n\n    /**\n     * Sam pointed out a problem with the previous definition, v3, of\n     * ambiguous states. If we have another state associated with conflicting\n     * alternatives, we should keep going. For example, the following grammar\n     *\n     * s : (ID | ID ID?) ';' ;\n     *\n     * When the ATN simulation reaches the state before ';', it has a DFA\n     * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally\n     * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node\n     * because alternative to has another way to continue, via [6|2|[]].\n     * The key is that we have a single state that has config's only associated\n     * with a single alternative, 2, and crucially the state transitions\n     * among the configurations are all non-epsilon transitions. That means\n     * we don't consider any conflicts that include alternative 2. So, we\n     * ignore the conflict between alts 1 and 2. We ignore a set of\n     * conflicting alts when there is an intersection with an alternative\n     * associated with a single alt state in the state&rarr;config-list map.\n     *\n     * It's also the case that we might have two conflicting configurations but\n     * also a 3rd nonconflicting configuration for a different alternative:\n     * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:\n     *\n     * a : A | A | A B ;\n     *\n     * After matching input A, we reach the stop state for rule A, state 1.\n     * State 8 is the state right before B. Clearly alternatives 1 and 2\n     * conflict and no amount of further lookahead will separate the two.\n     * However, alternative 3 will be able to continue and so we do not\n     * stop working on this state. In the previous example, we're concerned\n     * with states associated with the conflicting alternatives. Here alt\n     * 3 is not associated with the conflicting configs, but since we can continue\n     * looking for input reasonably, I don't declare the state done. We\n     * ignore a set of conflicting alts when we have an alternative\n     * that we still need to pursue\n     */\n    getConflictingAltsOrUniqueAlt(configs) {\n        let conflictingAlts = null;\n        if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {\n            conflictingAlts = new BitSet();\n            conflictingAlts.add(configs.uniqueAlt);\n        } else {\n            conflictingAlts = configs.conflictingAlts;\n        }\n        return conflictingAlts;\n    }\n\n    getTokenName(t) {\n        if (t===Token.EOF) {\n            return \"EOF\";\n        }\n        if( this.parser!==null && this.parser.literalNames!==null) {\n            if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {\n                console.log(\"\" + t + \" ttype out of range: \" + this.parser.literalNames);\n                console.log(\"\" + this.parser.getInputStream().getTokens());\n            } else {\n                const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];\n                return name + \"<\" + t + \">\";\n            }\n        }\n        return \"\" + t;\n    }\n\n    getLookaheadName(input) {\n        return this.getTokenName(input.LA(1));\n    }\n\n    /**\n     * Used for debugging in adaptivePredict around execATN but I cut\n     * it out for clarity now that alg. works well. We can leave this\n     * \"dead\" code for a bit\n     */\n    dumpDeadEndConfigs(nvae) {\n        console.log(\"dead end configs: \");\n        const decs = nvae.getDeadEndConfigs();\n        for(let i=0; i<decs.length; i++) {\n            const c = decs[i];\n            let trans = \"no edges\";\n            if (c.state.transitions.length>0) {\n                const t = c.state.transitions[0];\n                if (t instanceof AtomTransition) {\n                    trans = \"Atom \"+ this.getTokenName(t.label);\n                } else if (t instanceof SetTransition) {\n                    const neg = (t instanceof NotSetTransition);\n                    trans = (neg ? \"~\" : \"\") + \"Set \" + t.set;\n                }\n            }\n            console.error(c.toString(this.parser, true) + \":\" + trans);\n        }\n    }\n\n    noViableAlt(input, outerContext, configs, startIndex) {\n        return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n    }\n\n    getUniqueAlt(configs) {\n        let alt = ATN.INVALID_ALT_NUMBER;\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (alt === ATN.INVALID_ALT_NUMBER) {\n                alt = c.alt // found first alt\n            } else if( c.alt!==alt) {\n                return ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return alt;\n    }\n\n    /**\n     * Add an edge to the DFA, if possible. This method calls\n     * {@link //addDFAState} to ensure the {@code to} state is present in the\n     * DFA. If {@code from} is {@code null}, or if {@code t} is outside the\n     * range of edges that can be represented in the DFA tables, this method\n     * returns without adding the edge to the DFA.\n     *\n     * <p>If {@code to} is {@code null}, this method returns {@code null}.\n     * Otherwise, this method returns the {@link DFAState} returned by calling\n     * {@link //addDFAState} for the {@code to} state.</p>\n     *\n     * @param dfa The DFA\n     * @param from_ The source state for the edge\n     * @param t The input symbol\n     * @param to The target state for the edge\n     *\n     * @return If {@code to} is {@code null}, this method returns {@code null};\n     * otherwise this method returns the result of calling {@link //addDFAState}\n     * on {@code to}\n     */\n    addDFAEdge(dfa, from_, t, to) {\n        if( this.debug) {\n            console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + this.getTokenName(t));\n        }\n        if (to===null) {\n            return null;\n        }\n        to = this.addDFAState(dfa, to); // used existing if possible not incoming\n        if (from_===null || t < -1 || t > this.atn.maxTokenType) {\n            return to;\n        }\n        if (from_.edges===null) {\n            from_.edges = [];\n        }\n        from_.edges[t+1] = to; // connect\n\n        if (this.debug) {\n            const literalNames = this.parser===null ? null : this.parser.literalNames;\n            const symbolicNames = this.parser===null ? null : this.parser.symbolicNames;\n            console.log(\"DFA=\\n\" + dfa.toString(literalNames, symbolicNames));\n        }\n        return to;\n    }\n\n    /**\n     * Add state {@code D} to the DFA if it is not already present, and return\n     * the actual instance stored in the DFA. If a state equivalent to {@code D}\n     * is already in the DFA, the existing state is returned. Otherwise this\n     * method returns {@code D} after adding it to the DFA.\n     *\n     * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and\n     * does not change the DFA.</p>\n     *\n     * @param dfa The dfa\n     * @param D The DFA state to add\n     * @return The state stored in the DFA. This will be either the existing\n     * state if {@code D} is already in the DFA, or {@code D} itself if the\n     * state was not already present\n     */\n    addDFAState(dfa, D) {\n        if (D === ATNSimulator.ERROR) {\n            return D;\n        }\n        const existing = dfa.states.get(D);\n        if(existing!==null) {\n            return existing;\n        }\n        D.stateNumber = dfa.states.length;\n        if (! D.configs.readOnly) {\n            D.configs.optimizeConfigs(this);\n            D.configs.setReadonly(true);\n        }\n        dfa.states.add(D);\n        if (this.debug) {\n            console.log(\"adding new DFA state: \" + D);\n        }\n        return D;\n    }\n\n    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n        }\n    }\n\n    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);\n        }\n    }\n\n    // If context sensitive parsing, we know it's ambiguity not conflict//\n    reportAmbiguity(dfa, D, startIndex, stopIndex,\n                                   exact, ambigAlts, configs ) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n        }\n    }\n}\n\nmodule.exports = ParserATNSimulator;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Map, BitSet, AltDict, hashStuff} = require('./../Utils');\nconst ATN = require('./ATN');\nconst {RuleStopState} = require('./ATNState');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {ATNConfig} = require('./ATNConfig');\nconst {SemanticContext} = require('./SemanticContext');\n\n/**\n * This enumeration defines the prediction modes available in ANTLR 4 along with\n * utility methods for analyzing configuration sets for conflicts and/or\n * ambiguities.\n */\nconst PredictionMode = {\n    /**\n     * The SLL(*) prediction mode. This prediction mode ignores the current\n     * parser context when making predictions. This is the fastest prediction\n     * mode, and provides correct results for many grammars. This prediction\n     * mode is more powerful than the prediction mode provided by ANTLR 3, but\n     * may result in syntax errors for grammar and input combinations which are\n     * not SLL.\n     *\n     * <p>\n     * When using this prediction mode, the parser will either return a correct\n     * parse tree (i.e. the same parse tree that would be returned with the\n     * {@link //LL} prediction mode), or it will report a syntax error. If a\n     * syntax error is encountered when using the {@link //SLL} prediction mode,\n     * it may be due to either an actual syntax error in the input or indicate\n     * that the particular combination of grammar and input requires the more\n     * powerful {@link //LL} prediction abilities to complete successfully.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    SLL: 0,\n\n    /**\n     * The LL(*) prediction mode. This prediction mode allows the current parser\n     * context to be used for resolving SLL conflicts that occur during\n     * prediction. This is the fastest prediction mode that guarantees correct\n     * parse results for all combinations of grammars with syntactically correct\n     * inputs.\n     *\n     * <p>\n     * When using this prediction mode, the parser will make correct decisions\n     * for all syntactically-correct grammar and input combinations. However, in\n     * cases where the grammar is truly ambiguous this prediction mode might not\n     * report a precise answer for <em>exactly which</em> alternatives are\n     * ambiguous.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    LL: 1,\n\n    /**\n     *\n     * The LL(*) prediction mode with exact ambiguity detection. In addition to\n     * the correctness guarantees provided by the {@link //LL} prediction mode,\n     * this prediction mode instructs the prediction algorithm to determine the\n     * complete and exact set of ambiguous alternatives for every ambiguous\n     * decision encountered while parsing.\n     *\n     * <p>\n     * This prediction mode may be used for diagnosing ambiguities during\n     * grammar development. Due to the performance overhead of calculating sets\n     * of ambiguous alternatives, this prediction mode should be avoided when\n     * the exact results are not necessary.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    LL_EXACT_AMBIG_DETECTION: 2,\n\n    /**\n     *\n     * Computes the SLL prediction termination condition.\n     *\n     * <p>\n     * This method computes the SLL prediction termination condition for both of\n     * the following cases.</p>\n     *\n     * <ul>\n     * <li>The usual SLL+LL fallback upon SLL conflict</li>\n     * <li>Pure SLL without LL fallback</li>\n     * </ul>\n     *\n     * <p><strong>COMBINED SLL+LL PARSING</strong></p>\n     *\n     * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are\n     * ensured regardless of how the termination condition is computed by this\n     * method. Due to the substantially higher cost of LL prediction, the\n     * prediction should only fall back to LL when the additional lookahead\n     * cannot lead to a unique SLL prediction.</p>\n     *\n     * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only\n     * conflicting subsets should fall back to full LL, even if the\n     * configuration sets don't resolve to the same alternative (e.g.\n     * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting\n     * configuration, SLL could continue with the hopes that more lookahead will\n     * resolve via one of those non-conflicting configurations.</p>\n     *\n     * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)\n     * stops when it sees only conflicting configuration subsets. In contrast,\n     * full LL keeps going when there is uncertainty.</p>\n     *\n     * <p><strong>HEURISTIC</strong></p>\n     *\n     * <p>As a heuristic, we stop prediction when we see any conflicting subset\n     * unless we see a state that only has one alternative associated with it.\n     * The single-alt-state thing lets prediction continue upon rules like\n     * (otherwise, it would admit defeat too soon):</p>\n     *\n     * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>\n     *\n     * <p>When the ATN simulation reaches the state before {@code ';'}, it has a\n     * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally\n     * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop\n     * processing this node because alternative to has another way to continue,\n     * via {@code [6|2|[]]}.</p>\n     *\n     * <p>It also let's us continue for this rule:</p>\n     *\n     * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>\n     *\n     * <p>After matching input A, we reach the stop state for rule A, state 1.\n     * State 8 is the state right before B. Clearly alternatives 1 and 2\n     * conflict and no amount of further lookahead will separate the two.\n     * However, alternative 3 will be able to continue and so we do not stop\n     * working on this state. In the previous example, we're concerned with\n     * states associated with the conflicting alternatives. Here alt 3 is not\n     * associated with the conflicting configs, but since we can continue\n     * looking for input reasonably, don't declare the state done.</p>\n     *\n     * <p><strong>PURE SLL PARSING</strong></p>\n     *\n     * <p>To handle pure SLL parsing, all we have to do is make sure that we\n     * combine stack contexts for configurations that differ only by semantic\n     * predicate. From there, we can do the usual SLL termination heuristic.</p>\n     *\n     * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>\n     *\n     * <p>SLL decisions don't evaluate predicates until after they reach DFA stop\n     * states because they need to create the DFA cache that works in all\n     * semantic situations. In contrast, full LL evaluates predicates collected\n     * during start state computation so it can ignore predicates thereafter.\n     * This means that SLL termination detection can totally ignore semantic\n     * predicates.</p>\n     *\n     * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not\n     * semantic predicate contexts so we might see two configurations like the\n     * following.</p>\n     *\n     * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>\n     *\n     * <p>Before testing these configurations against others, we have to merge\n     * {@code x} and {@code x'} (without modifying the existing configurations).\n     * For example, we test {@code (x+x')==x''} when looking for conflicts in\n     * the following configurations.</p>\n     *\n     * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>\n     *\n     * <p>If the configuration set has predicates (as indicated by\n     * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of\n     * the configurations to strip out all of the predicates so that a standard\n     * {@link ATNConfigSet} will merge everything ignoring predicates.</p>\n     */\n    hasSLLConflictTerminatingPrediction: function( mode, configs) {\n        // Configs in rule stop states indicate reaching the end of the decision\n        // rule (local context) or end of start rule (full context). If all\n        // configs meet this condition, then none of the configurations is able\n        // to match additional input so we terminate prediction.\n        //\n        if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return true;\n        }\n        // pure SLL mode parsing\n        if (mode === PredictionMode.SLL) {\n            // Don't bother with combining configs from different semantic\n            // contexts if we can fail over to full LL; costs more time\n            // since we'll often fail over anyway.\n            if (configs.hasSemanticContext) {\n                // dup configs, tossing out semantic predicates\n                const dup = new ATNConfigSet();\n                for(let i=0;i<configs.items.length;i++) {\n                    let c = configs.items[i];\n                    c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);\n                    dup.add(c);\n                }\n                configs = dup;\n            }\n            // now we have combined contexts for configs with dissimilar preds\n        }\n        // pure SLL or combined SLL+LL mode parsing\n        const altsets = PredictionMode.getConflictingAltSubsets(configs);\n        return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);\n    },\n\n    /**\n     * Checks if any configuration in {@code configs} is in a\n     * {@link RuleStopState}. Configurations meeting this condition have reached\n     * the end of the decision rule (local context) or end of start rule (full\n     * context).\n     *\n     * @param configs the configuration set to test\n     * @return {@code true} if any configuration in {@code configs} is in a\n     * {@link RuleStopState}, otherwise {@code false}\n     */\n    hasConfigInRuleStopState: function(configs) {\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (c.state instanceof RuleStopState) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Checks if all configurations in {@code configs} are in a\n     * {@link RuleStopState}. Configurations meeting this condition have reached\n     * the end of the decision rule (local context) or end of start rule (full\n     * context).\n     *\n     * @param configs the configuration set to test\n     * @return {@code true} if all configurations in {@code configs} are in a\n     * {@link RuleStopState}, otherwise {@code false}\n     */\n    allConfigsInRuleStopStates: function(configs) {\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (!(c.state instanceof RuleStopState)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    /**\n     *\n     * Full LL prediction termination.\n     *\n     * <p>Can we stop looking ahead during ATN simulation or is there some\n     * uncertainty as to which alternative we will ultimately pick, after\n     * consuming more input? Even if there are partial conflicts, we might know\n     * that everything is going to resolve to the same minimum alternative. That\n     * means we can stop since no more lookahead will change that fact. On the\n     * other hand, there might be multiple conflicts that resolve to different\n     * minimums. That means we need more look ahead to decide which of those\n     * alternatives we should predict.</p>\n     *\n     * <p>The basic idea is to split the set of configurations {@code C}, into\n     * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with\n     * non-conflicting configurations. Two configurations conflict if they have\n     * identical {@link ATNConfig//state} and {@link ATNConfig//context} values\n     * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}\n     * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>\n     *\n     * <p>Reduce these configuration subsets to the set of possible alternatives.\n     * You can compute the alternative subsets in one pass as follows:</p>\n     *\n     * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in\n     * {@code C} holding {@code s} and {@code ctx} fixed.</p>\n     *\n     * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>\n     *\n     * <pre>\n     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n     * alt and not pred\n     * </pre>\n     *\n     * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>\n     *\n     * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with\n     * {@code s} and {@code ctx}.</p>\n     *\n     * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If\n     * the union of these alternative subsets is a singleton, then no amount of\n     * more lookahead will help us. We will always pick that alternative. If,\n     * however, there is more than one alternative, then we are uncertain which\n     * alternative to predict and must continue looking for resolution. We may\n     * or may not discover an ambiguity in the future, even if there are no\n     * conflicting subsets this round.</p>\n     *\n     * <p>The biggest sin is to terminate early because it means we've made a\n     * decision but were uncertain as to the eventual outcome. We haven't used\n     * enough lookahead. On the other hand, announcing a conflict too late is no\n     * big deal; you will still have the conflict. It's just inefficient. It\n     * might even look until the end of file.</p>\n     *\n     * <p>No special consideration for semantic predicates is required because\n     * predicates are evaluated on-the-fly for full LL prediction, ensuring that\n     * no configuration contains a semantic context during the termination\n     * check.</p>\n     *\n     * <p><strong>CONFLICTING CONFIGS</strong></p>\n     *\n     * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict\n     * when {@code i!=j} but {@code x=x'}. Because we merge all\n     * {@code (s, i, _)} configurations together, that means that there are at\n     * most {@code n} configurations associated with state {@code s} for\n     * {@code n} possible alternatives in the decision. The merged stacks\n     * complicate the comparison of configuration contexts {@code x} and\n     * {@code x'}. Sam checks to see if one is a subset of the other by calling\n     * merge and checking to see if the merged result is either {@code x} or\n     * {@code x'}. If the {@code x} associated with lowest alternative {@code i}\n     * is the superset, then {@code i} is the only possible prediction since the\n     * others resolve to {@code min(i)} as well. However, if {@code x} is\n     * associated with {@code j>i} then at least one stack configuration for\n     * {@code j} is not in conflict with alternative {@code i}. The algorithm\n     * should keep going, looking for more lookahead due to the uncertainty.</p>\n     *\n     * <p>For simplicity, I'm doing a equality check between {@code x} and\n     * {@code x'} that lets the algorithm continue to consume lookahead longer\n     * than necessary. The reason I like the equality is of course the\n     * simplicity but also because that is the test you need to detect the\n     * alternatives that are actually in conflict.</p>\n     *\n     * <p><strong>CONTINUE/STOP RULE</strong></p>\n     *\n     * <p>Continue if union of resolved alternative sets from non-conflicting and\n     * conflicting alternative subsets has more than one alternative. We are\n     * uncertain about which alternative to predict.</p>\n     *\n     * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which\n     * alternatives are still in the running for the amount of input we've\n     * consumed at this point. The conflicting sets let us to strip away\n     * configurations that won't lead to more states because we resolve\n     * conflicts to the configuration with a minimum alternate for the\n     * conflicting set.</p>\n     *\n     * <p><strong>CASES</strong></p>\n     *\n     * <ul>\n     *\n     * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>\n     *\n     * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},\n     * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set\n     * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n     * {@code {1,3}} =&gt; continue\n     * </li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n     * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set\n     * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n     * {@code {1}} =&gt; stop and predict 1</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n     * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce\n     * ambiguity {@code {1,2}}</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},\n     * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {2}} = {@code {1,2}} =&gt; continue</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},\n     * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {3}} = {@code {1,3}} =&gt; continue</li>\n     *\n     * </ul>\n     *\n     * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>\n     *\n     * <p>If all states report the same conflicting set of alternatives, then we\n     * know we have the exact ambiguity set.</p>\n     *\n     * <p><code>|A_<em>i</em>|&gt;1</code> and\n     * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>\n     *\n     * <p>In other words, we continue examining lookahead until all {@code A_i}\n     * have more than one alternative and all {@code A_i} are the same. If\n     * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate\n     * because the resolved set is {@code {1}}. To determine what the real\n     * ambiguity is, we have to know whether the ambiguity is between one and\n     * two or one and three so we keep going. We can only stop prediction when\n     * we need exact ambiguity detection when the sets look like\n     * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>\n     */\n    resolvesToJustOneViableAlt: function(altsets) {\n        return PredictionMode.getSingleViableAlt(altsets);\n    },\n\n    /**\n     * Determines if every alternative subset in {@code altsets} contains more\n     * than one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if every {@link BitSet} in {@code altsets} has\n     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n     */\n    allSubsetsConflict: function(altsets) {\n        return ! PredictionMode.hasNonConflictingAltSet(altsets);\n    },\n    /**\n     * Determines if any single alternative subset in {@code altsets} contains\n     * exactly one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n     * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}\n     */\n    hasNonConflictingAltSet: function(altsets) {\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (alts.length===1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    /**\n     * Determines if any single alternative subset in {@code altsets} contains\n     * more than one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n     */\n    hasConflictingAltSet: function(altsets) {\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (alts.length>1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    /**\n     * Determines if every alternative subset in {@code altsets} is equivalent.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if every member of {@code altsets} is equal to the\n     * others, otherwise {@code false}\n     */\n    allSubsetsEqual: function(altsets) {\n        let first = null;\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (first === null) {\n                first = alts;\n            } else if (alts!==first) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n\n    /**\n     * Returns the unique alternative predicted by all alternative subsets in\n     * {@code altsets}. If no such alternative exists, this method returns\n     * {@link ATN//INVALID_ALT_NUMBER}.\n     *\n     * @param altsets a collection of alternative subsets\n     */\n    getUniqueAlt: function(altsets) {\n        const all = PredictionMode.getAlts(altsets);\n        if (all.length===1) {\n            return all.minValue();\n        } else {\n            return ATN.INVALID_ALT_NUMBER;\n        }\n    },\n\n    /**\n     * Gets the complete set of represented alternatives for a collection of\n     * alternative subsets. This method returns the union of each {@link BitSet}\n     * in {@code altsets}.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return the set of represented alternatives in {@code altsets}\n     */\n    getAlts: function(altsets) {\n        const all = new BitSet();\n        altsets.map( function(alts) { all.or(alts); });\n        return all;\n    },\n\n    /**\n     * This function gets the conflicting alt subsets from a configuration set.\n     * For each configuration {@code c} in {@code configs}:\n     *\n     * <pre>\n     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n     * alt and not pred\n     * </pre>\n     */\n    getConflictingAltSubsets: function(configs) {\n        const configToAlts = new Map();\n        configToAlts.hashFunction = function(cfg) { hashStuff(cfg.state.stateNumber, cfg.context); };\n        configToAlts.equalsFunction = function(c1, c2) { return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);};\n        configs.items.map(function(cfg) {\n            let alts = configToAlts.get(cfg);\n            if (alts === null) {\n                alts = new BitSet();\n                configToAlts.put(cfg, alts);\n            }\n            alts.add(cfg.alt);\n        });\n        return configToAlts.getValues();\n    },\n\n    /**\n     * Get a map from state to alt subset from a configuration set. For each\n     * configuration {@code c} in {@code configs}:\n     *\n     * <pre>\n     * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}\n     * </pre>\n     */\n    getStateToAltMap: function(configs) {\n        const m = new AltDict();\n        configs.items.map(function(c) {\n            let alts = m.get(c.state);\n            if (alts === null) {\n                alts = new BitSet();\n                m.put(c.state, alts);\n            }\n            alts.add(c.alt);\n        });\n        return m;\n    },\n\n    hasStateAssociatedWithOneAlt: function(configs) {\n        const values = PredictionMode.getStateToAltMap(configs).values();\n        for(let i=0;i<values.length;i++) {\n            if (values[i].length===1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    getSingleViableAlt: function(altsets) {\n        let result = null;\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            const minAlt = alts.minValue();\n            if(result===null) {\n                result = minAlt;\n            } else if(result!==minAlt) { // more than 1 viable alt\n                return ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return result;\n    }\n};\n\nmodule.exports = PredictionMode;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst { Set, Hash, equalArrays } = require('./../Utils');\n\n/**\n * A tree structure used to record the semantic context in which\n * an ATN configuration is valid.  It's either a single predicate,\n * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.\n *\n * <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of\n * {@link SemanticContext} within the scope of this outer class.</p>\n */\nclass SemanticContext {\n\n\thashCode() {\n\t\tconst hash = new Hash();\n\t\tthis.updateHashCode(hash);\n\t\treturn hash.finish();\n\t}\n\n\t/**\n\t * For context independent predicates, we evaluate them without a local\n\t * context (i.e., null context). That way, we can evaluate them without\n\t * having to create proper rule-specific context during prediction (as\n\t * opposed to the parser, which creates them naturally). In a practical\n\t * sense, this avoids a cast exception from RuleContext to myruleContext.\n\t *\n\t * <p>For context dependent predicates, we must pass in a local context so that\n\t * references such as $arg evaluate properly as _localctx.arg. We only\n\t * capture context dependent predicates in the context in which we begin\n\t * prediction, so we passed in the outer context here in case of context\n\t * dependent predicate evaluation.</p>\n\t */\n\tevaluate(parser, outerContext) {}\n\n\t/**\n\t * Evaluate the precedence predicates for the context and reduce the result.\n\t *\n\t * @param parser The parser instance.\n\t * @param outerContext The current parser context object.\n\t * @return The simplified semantic context after precedence predicates are\n\t * evaluated, which will be one of the following values.\n\t * <ul>\n\t * <li>{@link //NONE}: if the predicate simplifies to {@code true} after\n\t * precedence predicates are evaluated.</li>\n\t * <li>{@code null}: if the predicate simplifies to {@code false} after\n\t * precedence predicates are evaluated.</li>\n\t * <li>{@code this}: if the semantic context is not changed as a result of\n\t * precedence predicate evaluation.</li>\n\t * <li>A non-{@code null} {@link SemanticContext}: the new simplified\n\t * semantic context after precedence predicates are evaluated.</li>\n\t * </ul>\n\t */\n\tevalPrecedence(parser, outerContext) {\n\t\treturn this;\n\t}\n\n\tstatic andContext(a, b) {\n\t\tif (a === null || a === SemanticContext.NONE) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === null || b === SemanticContext.NONE) {\n\t\t\treturn a;\n\t\t}\n\t\tconst result = new AND(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic orContext(a, b) {\n\t\tif (a === null) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === null) {\n\t\t\treturn a;\n\t\t}\n\t\tif (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tconst result = new OR(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\n\nclass Predicate extends SemanticContext {\n\n\tconstructor(ruleIndex, predIndex, isCtxDependent) {\n\t\tsuper();\n\t\tthis.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;\n\t\tthis.predIndex = predIndex === undefined ? -1 : predIndex;\n\t\tthis.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred\n\t}\n\n\tevaluate(parser, outerContext) {\n\t\tconst localctx = this.isCtxDependent ? outerContext : null;\n\t\treturn parser.sempred(localctx, this.ruleIndex, this.predIndex);\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof Predicate)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.ruleIndex === other.ruleIndex &&\n\t\t\t\t\tthis.predIndex === other.predIndex &&\n\t\t\t\t\tthis.isCtxDependent === other.isCtxDependent;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n\t}\n}\n\n/**\n * The default {@link SemanticContext}, which is semantically equivalent to\n * a predicate of the form {@code {true}?}\n */\nSemanticContext.NONE = new Predicate();\n\n\nclass PrecedencePredicate extends SemanticContext {\n\n\tconstructor(precedence) {\n\t\tsuper();\n\t\tthis.precedence = precedence === undefined ? 0 : precedence;\n\t}\n\n\tevaluate(parser, outerContext) {\n\t\treturn parser.precpred(outerContext, this.precedence);\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tif (parser.precpred(outerContext, this.precedence)) {\n\t\t\treturn SemanticContext.NONE;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tcompareTo(other) {\n\t\treturn this.precedence - other.precedence;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.precedence);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof PrecedencePredicate)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.precedence === other.precedence;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"{\" + this.precedence + \">=prec}?\";\n\t}\n\n\tstatic filterPrecedencePredicates(set) {\n\t\tconst result = [];\n\t\tset.values().map( function(context) {\n\t\t\tif (context instanceof PrecedencePredicate) {\n\t\t\t\tresult.push(context);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n}\n\nclass AND extends SemanticContext {\n\t/**\n\t * A semantic context which is true whenever none of the contained contexts\n\t * is false\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tconst operands = new Set();\n\t\tif (a instanceof AND) {\n\t\t\ta.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(a);\n\t\t}\n\t\tif (b instanceof AND) {\n\t\t\tb.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(b);\n\t\t}\n\t\tconst precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\t\tif (precedencePredicates.length > 0) {\n\t\t\t// interested in the transition with the lowest precedence\n\t\t\tlet reduced = null;\n\t\t\tprecedencePredicates.map( function(p) {\n\t\t\t\tif(reduced===null || p.precedence<reduced.precedence) {\n\t\t\t\t\treduced = p;\n\t\t\t\t}\n\t\t\t});\n\t\t\toperands.add(reduced);\n\t\t}\n\t\tthis.opnds = Array.from(operands.values());\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof AND)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn equalArrays(this.opnds, other.opnds);\n\t\t}\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.opnds, \"AND\");\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * <p>\n\t * The evaluation of predicates by this context is short-circuiting, but\n\t * unordered.</p>\n\t */\n\tevaluate(parser, outerContext) {\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tif (!this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tlet differs = false;\n\t\tconst operands = [];\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tconst context = this.opnds[i];\n\t\t\tconst evaluated = context.evalPrecedence(parser, outerContext);\n\t\t\tdiffers |= (evaluated !== context);\n\t\t\tif (evaluated === null) {\n\t\t\t\t// The AND context is false if any element is false\n\t\t\t\treturn null;\n\t\t\t} else if (evaluated !== SemanticContext.NONE) {\n\t\t\t\t// Reduce the result by skipping true elements\n\t\t\t\toperands.push(evaluated);\n\t\t\t}\n\t\t}\n\t\tif (!differs) {\n\t\t\treturn this;\n\t\t}\n\t\tif (operands.length === 0) {\n\t\t\t// all elements were true, so the AND context is true\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tlet result = null;\n\t\toperands.map(function(o) {\n\t\t\tresult = result === null ? o : SemanticContext.andContext(result, o);\n\t\t});\n\t\treturn result;\n\t}\n\n\ttoString() {\n\t\tconst s = this.opnds.map(o => o.toString());\n\t\treturn (s.length > 3 ? s.slice(3) : s).join(\"&&\");\n\t}\n}\n\n\nclass OR extends SemanticContext {\n\t/**\n\t * A semantic context which is true whenever at least one of the contained\n\t * contexts is true\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tconst operands = new Set();\n\t\tif (a instanceof OR) {\n\t\t\ta.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(a);\n\t\t}\n\t\tif (b instanceof OR) {\n\t\t\tb.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(b);\n\t\t}\n\n\t\tconst precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\t\tif (precedencePredicates.length > 0) {\n\t\t\t// interested in the transition with the highest precedence\n\t\t\tconst s = precedencePredicates.sort(function(a, b) {\n\t\t\t\treturn a.compareTo(b);\n\t\t\t});\n\t\t\tconst reduced = s[s.length-1];\n\t\t\toperands.add(reduced);\n\t\t}\n\t\tthis.opnds = Array.from(operands.values());\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof OR)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn equalArrays(this.opnds, other.opnds);\n\t\t}\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.opnds, \"OR\");\n\t}\n\n\t/**\n\t * <p>\n\t * The evaluation of predicates by this context is short-circuiting, but\n\t * unordered.</p>\n\t */\n\tevaluate(parser, outerContext) {\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tif (this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tlet differs = false;\n\t\tconst operands = [];\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tconst context = this.opnds[i];\n\t\t\tconst evaluated = context.evalPrecedence(parser, outerContext);\n\t\t\tdiffers |= (evaluated !== context);\n\t\t\tif (evaluated === SemanticContext.NONE) {\n\t\t\t\t// The OR context is true if any element is true\n\t\t\t\treturn SemanticContext.NONE;\n\t\t\t} else if (evaluated !== null) {\n\t\t\t\t// Reduce the result by skipping false elements\n\t\t\t\toperands.push(evaluated);\n\t\t\t}\n\t\t}\n\t\tif (!differs) {\n\t\t\treturn this;\n\t\t}\n\t\tif (operands.length === 0) {\n\t\t\t// all elements were false, so the OR context is false\n\t\t\treturn null;\n\t\t}\n\t\tconst result = null;\n\t\toperands.map(function(o) {\n\t\t\treturn result === null ? o : SemanticContext.orContext(result, o);\n\t\t});\n\t\treturn result;\n\t}\n\n\ttoString() {\n\t\tconst s = this.opnds.map(o => o.toString());\n\t\treturn (s.length > 3 ? s.slice(3) : s).join(\"||\");\n\t}\n}\n\nmodule.exports = {\n\tSemanticContext,\n\tPrecedencePredicate,\n\tPredicate\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst {IntervalSet} = require('./../IntervalSet');\nconst {Predicate, PrecedencePredicate} = require('./SemanticContext');\n\n/**\n * An ATN transition between any two ATN states.  Subclasses define\n * atom, set, epsilon, action, predicate, rule transitions.\n *\n * <p>This is a one way link.  It emanates from a state (usually via a list of\n * transitions) and has a target state.</p>\n *\n * <p>Since we never have to change the ATN transitions once we construct it,\n * we can fix these transitions as specific classes. The DFA transitions\n * on the other hand need to update the labels as it adds transitions to\n * the states. We'll use the term Edge for the DFA to distinguish them from\n * ATN transitions.</p>\n */\nclass Transition {\n    constructor(target) {\n        // The target of this transition.\n        if (target===undefined || target===null) {\n            throw \"target cannot be null.\";\n        }\n        this.target = target;\n        // Are we epsilon, action, sempred?\n        this.isEpsilon = false;\n        this.label = null;\n    }\n}\n\n// constants for serialization\n\nTransition.EPSILON = 1;\nTransition.RANGE = 2;\nTransition.RULE = 3;\n// e.g., {isType(input.LT(1))}?\nTransition.PREDICATE = 4;\nTransition.ATOM = 5;\nTransition.ACTION = 6;\n// ~(A|B) or ~atom, wildcard, which convert to next 2\nTransition.SET = 7;\nTransition.NOT_SET = 8;\nTransition.WILDCARD = 9;\nTransition.PRECEDENCE = 10;\n\nTransition.serializationNames = [\n            \"INVALID\",\n            \"EPSILON\",\n            \"RANGE\",\n            \"RULE\",\n            \"PREDICATE\",\n            \"ATOM\",\n            \"ACTION\",\n            \"SET\",\n            \"NOT_SET\",\n            \"WILDCARD\",\n            \"PRECEDENCE\"\n        ];\n\nTransition.serializationTypes = {\n        EpsilonTransition: Transition.EPSILON,\n        RangeTransition: Transition.RANGE,\n        RuleTransition: Transition.RULE,\n        PredicateTransition: Transition.PREDICATE,\n        AtomTransition: Transition.ATOM,\n        ActionTransition: Transition.ACTION,\n        SetTransition: Transition.SET,\n        NotSetTransition: Transition.NOT_SET,\n        WildcardTransition: Transition.WILDCARD,\n        PrecedencePredicateTransition: Transition.PRECEDENCE\n    };\n\n\n// TODO: make all transitions sets? no, should remove set edges\n\nclass AtomTransition extends Transition {\n    constructor(target, label) {\n        super(target);\n        // The token type or character value; or, signifies special label.\n        this.label_ = label;\n        this.label = this.makeLabel();\n        this.serializationType = Transition.ATOM;\n    }\n\n    makeLabel() {\n        const s = new IntervalSet();\n        s.addOne(this.label_);\n        return s;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return this.label_ === symbol;\n    }\n\n    toString() {\n        return this.label_;\n    }\n}\n\n\nclass RuleTransition extends Transition {\n    constructor(ruleStart, ruleIndex, precedence, followState) {\n        super(ruleStart);\n        // ptr to the rule definition object for this rule ref\n        this.ruleIndex = ruleIndex;\n        this.precedence = precedence;\n        // what node to begin computations following ref to rule\n        this.followState = followState;\n        this.serializationType = Transition.RULE;\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n}\n\nclass EpsilonTransition extends Transition {\n    constructor(target, outermostPrecedenceReturn) {\n        super(target);\n        this.serializationType = Transition.EPSILON;\n        this.isEpsilon = true;\n        this.outermostPrecedenceReturn = outermostPrecedenceReturn;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    toString() {\n        return \"epsilon\";\n    }\n}\n\n\nclass RangeTransition extends Transition {\n    constructor(target, start, stop) {\n        super(target);\n        this.serializationType = Transition.RANGE;\n        this.start = start;\n        this.stop = stop;\n        this.label = this.makeLabel();\n    }\n\n    makeLabel() {\n        const s = new IntervalSet();\n        s.addRange(this.start, this.stop);\n        return s;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= this.start && symbol <= this.stop;\n    }\n\n    toString() {\n        return \"'\" + String.fromCharCode(this.start) + \"'..'\" + String.fromCharCode(this.stop) + \"'\";\n    }\n}\n\n\nclass AbstractPredicateTransition extends Transition {\n    constructor(target) {\n        super(target);\n    }\n}\n\nclass PredicateTransition extends AbstractPredicateTransition {\n    constructor(target, ruleIndex, predIndex, isCtxDependent) {\n        super(target);\n        this.serializationType = Transition.PREDICATE;\n        this.ruleIndex = ruleIndex;\n        this.predIndex = predIndex;\n        this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    getPredicate() {\n        return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n    }\n\n    toString() {\n        return \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n    }\n}\n\n\nclass ActionTransition extends Transition {\n    constructor(target, ruleIndex, actionIndex, isCtxDependent) {\n        super(target);\n        this.serializationType = Transition.ACTION;\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex===undefined ? -1 : actionIndex;\n        this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    toString() {\n        return \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n    }\n}\n\n\n// A transition containing a set of values.\nclass SetTransition extends Transition {\n    constructor(target, set) {\n        super(target);\n        this.serializationType = Transition.SET;\n        if (set !==undefined && set !==null) {\n            this.label = set;\n        } else {\n            this.label = new IntervalSet();\n            this.label.addOne(Token.INVALID_TYPE);\n        }\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return this.label.contains(symbol);\n    }\n\n    toString() {\n        return this.label.toString();\n    }\n}\n\nclass NotSetTransition extends SetTransition {\n    constructor(target, set) {\n        super(target, set);\n        this.serializationType = Transition.NOT_SET;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&\n                !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\n    }\n\n    toString() {\n        return '~' + super.toString();\n    }\n}\n\nclass WildcardTransition extends Transition {\n    constructor(target) {\n        super(target);\n        this.serializationType = Transition.WILDCARD;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n    }\n\n    toString() {\n        return \".\";\n    }\n}\n\nclass PrecedencePredicateTransition extends AbstractPredicateTransition {\n    constructor(target, precedence) {\n        super(target);\n        this.serializationType = Transition.PRECEDENCE;\n        this.precedence = precedence;\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    getPredicate() {\n        return new PrecedencePredicate(this.precedence);\n    }\n\n    toString() {\n        return this.precedence + \" >= _p\";\n    }\n}\n\nmodule.exports = {\n    Transition,\n    AtomTransition,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    ActionTransition,\n    EpsilonTransition,\n    RangeTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition,\n    AbstractPredicateTransition\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.ATN = require('./ATN');\nexports.ATNDeserializer = require('./ATNDeserializer');\nexports.LexerATNSimulator = require('./LexerATNSimulator');\nexports.ParserATNSimulator = require('./ParserATNSimulator');\nexports.PredictionMode = require('./PredictionMode');\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Set} = require(\"../Utils\");\nconst {DFAState} = require('./DFAState');\nconst {StarLoopEntryState} = require('../atn/ATNState');\nconst {ATNConfigSet} = require('./../atn/ATNConfigSet');\nconst {DFASerializer} = require('./DFASerializer');\nconst {LexerDFASerializer} = require('./DFASerializer');\n\nclass DFA {\n\tconstructor(atnStartState, decision) {\n\t\tif (decision === undefined) {\n\t\t\tdecision = 0;\n\t\t}\n\t\t/**\n\t\t * From which ATN state did we create this DFA?\n\t\t */\n\t\tthis.atnStartState = atnStartState;\n\t\tthis.decision = decision;\n\t\t/**\n\t\t * A set of all DFA states. Use {@link Map} so we can get old state back\n\t\t * ({@link Set} only allows you to see if it's there).\n\t\t */\n\t\tthis._states = new Set();\n\t\tthis.s0 = null;\n\t\t/**\n\t\t * {@code true} if this DFA is for a precedence decision; otherwise,\n\t\t * {@code false}. This is the backing field for {@link //isPrecedenceDfa},\n\t\t * {@link //setPrecedenceDfa}\n\t\t */\n\t\tthis.precedenceDfa = false;\n\t\tif (atnStartState instanceof StarLoopEntryState)\n\t\t{\n\t\t\tif (atnStartState.isPrecedenceDecision) {\n\t\t\t\tthis.precedenceDfa = true;\n\t\t\t\tconst precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\t\tprecedenceState.edges = [];\n\t\t\t\tprecedenceState.isAcceptState = false;\n\t\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\t\tthis.s0 = precedenceState;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @return The start state corresponding to the specified precedence, or\n\t * {@code null} if no start state exists for the specified precedence.\n\t *\n\t * @throws IllegalStateException if this is not a precedence DFA.\n\t * @see //isPrecedenceDfa()\n\t */\n\tgetPrecedenceStartState(precedence) {\n\t\tif (!(this.precedenceDfa)) {\n\t\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\t\t// s0.edges is never null for a precedence DFA\n\t\tif (precedence < 0 || precedence >= this.s0.edges.length) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.s0.edges[precedence] || null;\n\t}\n\n\t/**\n\t * Set the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @param startState The start state corresponding to the specified\n\t * precedence.\n\t *\n\t * @throws IllegalStateException if this is not a precedence DFA.\n\t * @see //isPrecedenceDfa()\n\t */\n\tsetPrecedenceStartState(precedence, startState) {\n\t\tif (!(this.precedenceDfa)) {\n\t\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\t\tif (precedence < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * synchronization on s0 here is ok. when the DFA is turned into a\n\t\t * precedence DFA, s0 will be initialized once and not updated again\n\t\t * s0.edges is never null for a precedence DFA\n\t\t */\n\t\tthis.s0.edges[precedence] = startState;\n\t}\n\n\t/**\n\t * Sets whether this is a precedence DFA. If the specified value differs\n\t * from the current DFA configuration, the following actions are taken;\n\t * otherwise no changes are made to the current DFA.\n\t *\n\t * <ul>\n\t * <li>The {@link //states} map is cleared</li>\n\t * <li>If {@code precedenceDfa} is {@code false}, the initial state\n\t * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new\n\t * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to\n\t * store the start states for individual precedence values.</li>\n\t * <li>The {@link //precedenceDfa} field is updated</li>\n\t * </ul>\n\t *\n\t * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,\n\t * {@code false}\n\t */\n\tsetPrecedenceDfa(precedenceDfa) {\n\t\tif (this.precedenceDfa!==precedenceDfa) {\n\t\t\tthis._states = new Set();\n\t\t\tif (precedenceDfa) {\n\t\t\t\tconst precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\t\tprecedenceState.edges = [];\n\t\t\t\tprecedenceState.isAcceptState = false;\n\t\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\t\tthis.s0 = precedenceState;\n\t\t\t} else {\n\t\t\t\tthis.s0 = null;\n\t\t\t}\n\t\t\tthis.precedenceDfa = precedenceDfa;\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of all states in this DFA, ordered by state number.\n\t */\n\tsortedStates() {\n\t\tconst list = this._states.values();\n\t\treturn list.sort(function(a, b) {\n\t\t\treturn a.stateNumber - b.stateNumber;\n\t\t});\n\t}\n\n\ttoString(literalNames, symbolicNames) {\n\t\tliteralNames = literalNames || null;\n\t\tsymbolicNames = symbolicNames || null;\n\t\tif (this.s0 === null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst serializer = new DFASerializer(this, literalNames, symbolicNames);\n\t\treturn serializer.toString();\n\t}\n\n\ttoLexerString() {\n\t\tif (this.s0 === null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst serializer = new LexerDFASerializer(this);\n\t\treturn serializer.toString();\n\t}\n\n\tget states(){\n\t\treturn this._states;\n\t}\n}\n\n\nmodule.exports = DFA;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst Utils = require('./../Utils');\n\n/**\n * A DFA walker that knows how to dump them to serialized strings.\n */\nclass DFASerializer {\n    constructor(dfa, literalNames, symbolicNames) {\n        this.dfa = dfa;\n        this.literalNames = literalNames || [];\n        this.symbolicNames = symbolicNames || [];\n    }\n\n    toString() {\n       if(this.dfa.s0 === null) {\n           return null;\n       }\n       let buf = \"\";\n       const states = this.dfa.sortedStates();\n       for(let i=0; i<states.length; i++) {\n           const s = states[i];\n           if(s.edges!==null) {\n                const n = s.edges.length;\n                for(let j=0;j<n;j++) {\n                    const t = s.edges[j] || null;\n                    if(t!==null && t.stateNumber !== 0x7FFFFFFF) {\n                        buf = buf.concat(this.getStateString(s));\n                        buf = buf.concat(\"-\");\n                        buf = buf.concat(this.getEdgeLabel(j));\n                        buf = buf.concat(\"->\");\n                        buf = buf.concat(this.getStateString(t));\n                        buf = buf.concat('\\n');\n                    }\n                }\n           }\n       }\n       return buf.length===0 ? null : buf;\n    }\n\n    getEdgeLabel(i) {\n        if (i===0) {\n            return \"EOF\";\n        } else if(this.literalNames !==null || this.symbolicNames!==null) {\n            return this.literalNames[i-1] || this.symbolicNames[i-1];\n        } else {\n            return String.fromCharCode(i-1);\n        }\n    }\n\n    getStateString(s) {\n        const baseStateStr = ( s.isAcceptState ? \":\" : \"\") + \"s\" + s.stateNumber + ( s.requiresFullContext ? \"^\" : \"\");\n        if(s.isAcceptState) {\n            if (s.predicates !== null) {\n                return baseStateStr + \"=>\" + Utils.arrayToString(s.predicates);\n            } else {\n                return baseStateStr + \"=>\" + s.prediction.toString();\n            }\n        } else {\n            return baseStateStr;\n        }\n    }\n}\n\nclass LexerDFASerializer extends DFASerializer {\n    constructor(dfa) {\n        super(dfa, null);\n    }\n\n    getEdgeLabel(i) {\n        return \"'\" + String.fromCharCode(i) + \"'\";\n    }\n}\n\nmodule.exports = { DFASerializer , LexerDFASerializer };\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {ATNConfigSet} = require('./../atn/ATNConfigSet');\nconst {Hash, Set} = require('./../Utils');\n\n/**\n * Map a predicate to a predicted alternative.\n */\nclass PredPrediction {\n\tconstructor(pred, alt) {\n\t\tthis.alt = alt;\n\t\tthis.pred = pred;\n\t}\n\n\ttoString() {\n\t\treturn \"(\" + this.pred + \", \" + this.alt + \")\";\n\t}\n}\n\n/**\n * A DFA state represents a set of possible ATN configurations.\n * As Aho, Sethi, Ullman p. 117 says \"The DFA uses its state\n * to keep track of all possible states the ATN can be in after\n * reading each input symbol. That is to say, after reading\n * input a1a2..an, the DFA is in a state that represents the\n * subset T of the states of the ATN that are reachable from the\n * ATN's start state along some path labeled a1a2..an.\"\n * In conventional NFA&rarr;DFA conversion, therefore, the subset T\n * would be a bitset representing the set of states the\n * ATN could be in. We need to track the alt predicted by each\n * state as well, however. More importantly, we need to maintain\n * a stack of states, tracking the closure operations as they\n * jump from rule to rule, emulating rule invocations (method calls).\n * I have to add a stack to simulate the proper lookahead sequences for\n * the underlying LL grammar from which the ATN was derived.\n *\n * <p>I use a set of ATNConfig objects not simple states. An ATNConfig\n * is both a state (ala normal conversion) and a RuleContext describing\n * the chain of rules (if any) followed to arrive at that state.</p>\n *\n * <p>A DFA state may have multiple references to a particular state,\n * but with different ATN contexts (with same or different alts)\n * meaning that state was reached via a different set of rule invocations.</p>\n */\nclass DFAState {\n\tconstructor(stateNumber, configs) {\n\t\tif (stateNumber === null) {\n\t\t\tstateNumber = -1;\n\t\t}\n\t\tif (configs === null) {\n\t\t\tconfigs = new ATNConfigSet();\n\t\t}\n\t\tthis.stateNumber = stateNumber;\n\t\tthis.configs = configs;\n\t\t/**\n\t\t * {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)\n\t\t * {@link Token//EOF} maps to {@code edges[0]}.\n\t\t */\n\t\tthis.edges = null;\n\t\tthis.isAcceptState = false;\n\t\t/**\n\t\t * if accept state, what ttype do we match or alt do we predict?\n\t\t * This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link//predicates}\n\t\t * {@code !=null} or {@link //requiresFullContext}.\n\t\t */\n\t\tthis.prediction = 0;\n\t\tthis.lexerActionExecutor = null;\n\t\t/**\n\t\t * Indicates that this state was created during SLL prediction that\n\t\t * discovered a conflict between the configurations in the state. Future\n\t\t * {@link ParserATNSimulator//execATN} invocations immediately jumped doing\n\t\t * full context prediction if this field is true.\n\t\t */\n\t\tthis.requiresFullContext = false;\n\t\t/**\n\t\t * During SLL parsing, this is a list of predicates associated with the\n\t\t * ATN configurations of the DFA state. When we have predicates,\n\t\t * {@link //requiresFullContext} is {@code false} since full context\n\t\t * prediction evaluates predicates\n\t\t * on-the-fly. If this is not null, then {@link //prediction} is\n\t\t * {@link ATN//INVALID_ALT_NUMBER}.\n\t\t *\n\t\t * <p>We only use these for non-{@link //requiresFullContext} but\n\t\t * conflicting states. That\n\t\t * means we know from the context (it's $ or we don't dip into outer\n\t\t * context) that it's an ambiguity not a conflict.</p>\n\t\t *\n\t\t * <p>This list is computed by {@link\n\t\t * ParserATNSimulator//predicateDFAState}.</p>\n\t\t */\n\t\tthis.predicates = null;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the set of all alts mentioned by all ATN configurations in this\n\t * DFA state.\n\t */\n\tgetAltSet() {\n\t\tconst alts = new Set();\n\t\tif (this.configs !== null) {\n\t\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\t\tconst c = this.configs[i];\n\t\t\t\talts.add(c.alt);\n\t\t\t}\n\t\t}\n\t\tif (alts.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn alts;\n\t\t}\n\t}\n\n\t/**\n\t * Two {@link DFAState} instances are equal if their ATN configuration sets\n\t * are the same. This method is used to see if a state already exists.\n\t *\n\t * <p>Because the number of alternatives and number of ATN configurations are\n\t * finite, there is a finite number of DFA states that can be processed.\n\t * This is necessary to show that the algorithm terminates.</p>\n\t *\n\t * <p>Cannot test the DFA state numbers here because in\n\t * {@link ParserATNSimulator//addDFAState} we need to know if any other state\n\t * exists that has this exact set of ATN configurations. The\n\t * {@link //stateNumber} is irrelevant.</p>\n\t */\n\tequals(other) {\n\t\t// compare set of ATN configurations in this set with other\n\t\treturn this === other ||\n\t\t\t\t(other instanceof DFAState &&\n\t\t\t\t\tthis.configs.equals(other.configs));\n\t}\n\n\ttoString() {\n\t\tlet s = \"\" + this.stateNumber + \":\" + this.configs;\n\t\tif(this.isAcceptState) {\n\t\t\ts = s + \"=>\";\n\t\t\tif (this.predicates !== null)\n\t\t\t\ts = s + this.predicates;\n\t\t\telse\n\t\t\t\ts = s + this.prediction;\n\t\t}\n\t\treturn s;\n\t}\n\n\thashCode() {\n\t\tconst hash = new Hash();\n\t\thash.update(this.configs);\n\t\treturn hash.finish();\n\t}\n}\n\nmodule.exports = { DFAState, PredPrediction };\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.DFA = require('./DFA');\nexports.DFASerializer = require('./DFASerializer').DFASerializer;\nexports.LexerDFASerializer = require('./DFASerializer').LexerDFASerializer;\nexports.PredPrediction = require('./DFAState').PredPrediction;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {BitSet} = require('./../Utils');\nconst {ErrorListener} = require('./ErrorListener')\nconst {Interval} = require('./../IntervalSet')\n\n\n/**\n * This implementation of {@link ANTLRErrorListener} can be used to identify\n *  certain potential correctness and performance problems in grammars. \"Reports\"\n *  are made by calling {@link Parser//notifyErrorListeners} with the appropriate\n *  message.\n *\n *  <ul>\n *  <li><b>Ambiguities</b>: These are cases where more than one path through the\n *  grammar can match the input.</li>\n *  <li><b>Weak context sensitivity</b>: These are cases where full-context\n *  prediction resolved an SLL conflict to a unique alternative which equaled the\n *  minimum alternative of the SLL conflict.</li>\n *  <li><b>Strong (forced) context sensitivity</b>: These are cases where the\n *  full-context prediction resolved an SLL conflict to a unique alternative,\n *  <em>and</em> the minimum alternative of the SLL conflict was found to not be\n *  a truly viable alternative. Two-stage parsing cannot be used for inputs where\n *  this situation occurs.</li>\n *  </ul>\n */\nclass DiagnosticErrorListener extends ErrorListener {\n\tconstructor(exactOnly) {\n\t\tsuper();\n\t\texactOnly = exactOnly || true;\n\t\t// whether all ambiguities or only exact ambiguities are reported.\n\t\tthis.exactOnly = exactOnly;\n\t}\n\n\treportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n\t\tif (this.exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\t\tconst msg = \"reportAmbiguity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\": ambigAlts=\" +\n\t\t\tthis.getConflictingAlts(ambigAlts, configs) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\treportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n\t\tconst msg = \"reportAttemptingFullContext d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\treportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n\t\tconst msg = \"reportContextSensitivity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\tgetDecisionDescription(recognizer, dfa) {\n\t\tconst decision = dfa.decision\n\t\tconst ruleIndex = dfa.atnStartState.ruleIndex\n\n\t\tconst ruleNames = recognizer.ruleNames\n\t\tif (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n\t\t\treturn \"\" + decision;\n\t\t}\n\t\tconst ruleName = ruleNames[ruleIndex] || null\n\t\tif (ruleName === null || ruleName.length === 0) {\n\t\t\treturn \"\" + decision;\n\t\t}\n\t\treturn `${decision} (${ruleName})`;\n\t}\n\n\t/**\n\t * Computes the set of conflicting or ambiguous alternatives from a\n\t * configuration set, if that information was not already provided by the\n\t * parser.\n\t *\n\t * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n\t * reported by the parser.\n\t * @param configs The conflicting or ambiguous configuration set.\n\t * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise\n\t * returns the set of alternatives represented in {@code configs}.\n     */\n\tgetConflictingAlts(reportedAlts, configs) {\n\t\tif (reportedAlts !== null) {\n\t\t\treturn reportedAlts;\n\t\t}\n\t\tconst result = new BitSet()\n\t\tfor (let i = 0; i < configs.items.length; i++) {\n\t\t\tresult.add(configs.items[i].alt);\n\t\t}\n\t\treturn `{${result.values().join(\", \")}}`;\n\t}\n}\n\nmodule.exports = DiagnosticErrorListener\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * Provides an empty default implementation of {@link ANTLRErrorListener}. The\n * default implementation of each method does nothing, but can be overridden as\n * necessary.\n */\nclass ErrorListener {\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n    }\n\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n    }\n\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n    }\n\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n    }\n}\n\n/**\n * {@inheritDoc}\n *\n * <p>\n * This implementation prints messages to {@link System//err} containing the\n * values of {@code line}, {@code charPositionInLine}, and {@code msg} using\n * the following format.</p>\n *\n * <pre>\n * line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>\n * </pre>\n *\n */\nclass ConsoleErrorListener extends ErrorListener {\n    constructor() {\n        super();\n    }\n\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n        console.error(\"line \" + line + \":\" + column + \" \" + msg);\n    }\n}\n\n\n/**\n * Provides a default instance of {@link ConsoleErrorListener}.\n */\nConsoleErrorListener.INSTANCE = new ConsoleErrorListener();\n\nclass ProxyErrorListener extends ErrorListener {\n    constructor(delegates) {\n        super();\n        if (delegates===null) {\n            throw \"delegates\";\n        }\n        this.delegates = delegates;\n        return this;\n    }\n\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n        this.delegates.map(d => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));\n    }\n\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n        this.delegates.map(d => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));\n    }\n\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n        this.delegates.map(d => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));\n    }\n\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n        this.delegates.map(d => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));\n    }\n}\n\nmodule.exports = {ErrorListener, ConsoleErrorListener, ProxyErrorListener}\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token')\nconst {NoViableAltException, InputMismatchException, FailedPredicateException, ParseCancellationException} = require('./Errors')\nconst {ATNState} = require('./../atn/ATNState')\nconst {Interval, IntervalSet} = require('./../IntervalSet')\n\nclass ErrorStrategy {\n\n    reset(recognizer) {\n    }\n\n    recoverInline(recognizer) {\n    }\n\n    recover(recognizer, e) {\n    }\n\n    sync(recognizer) {\n    }\n\n    inErrorRecoveryMode(recognizer) {\n    }\n\n    reportError(recognizer) {\n    }\n}\n\n\n/**\n * This is the default implementation of {@link ANTLRErrorStrategy} used for\n * error reporting and recovery in ANTLR parsers.\n*/\nclass DefaultErrorStrategy extends ErrorStrategy {\n    constructor() {\n        super();\n        /**\n         * Indicates whether the error strategy is currently \"recovering from an\n         * error\". This is used to suppress reporting multiple error messages while\n         * attempting to recover from a detected syntax error.\n         *\n         * @see //inErrorRecoveryMode\n         */\n        this.errorRecoveryMode = false;\n\n        /**\n         * The index into the input stream where the last error occurred.\n         * This is used to prevent infinite loops where an error is found\n         * but no token is consumed during recovery...another error is found,\n         * ad nauseum. This is a failsafe mechanism to guarantee that at least\n         * one token/tree node is consumed for two errors.\n         */\n        this.lastErrorIndex = -1;\n        this.lastErrorStates = null;\n        this.nextTokensContext = null;\n        this.nextTokenState = 0;\n    }\n\n    /**\n     * <p>The default implementation simply calls {@link //endErrorCondition} to\n     * ensure that the handler is not in error recovery mode.</p>\n    */\n    reset(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n\n    /**\n     * This method is called to enter error recovery mode when a recognition\n     * exception is reported.\n     *\n     * @param recognizer the parser instance\n    */\n    beginErrorCondition(recognizer) {\n        this.errorRecoveryMode = true;\n    }\n\n    inErrorRecoveryMode(recognizer) {\n        return this.errorRecoveryMode;\n    }\n\n    /**\n     * This method is called to leave error recovery mode after recovering from\n     * a recognition exception.\n     * @param recognizer\n     */\n    endErrorCondition(recognizer) {\n        this.errorRecoveryMode = false;\n        this.lastErrorStates = null;\n        this.lastErrorIndex = -1;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>The default implementation simply calls {@link //endErrorCondition}.</p>\n     */\n    reportMatch(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The default implementation returns immediately if the handler is already\n     * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}\n     * and dispatches the reporting task based on the runtime type of {@code e}\n     * according to the following table.</p>\n     *\n     * <ul>\n     * <li>{@link NoViableAltException}: Dispatches the call to\n     * {@link //reportNoViableAlternative}</li>\n     * <li>{@link InputMismatchException}: Dispatches the call to\n     * {@link //reportInputMismatch}</li>\n     * <li>{@link FailedPredicateException}: Dispatches the call to\n     * {@link //reportFailedPredicate}</li>\n     * <li>All other types: calls {@link Parser//notifyErrorListeners} to report\n     * the exception</li>\n     * </ul>\n     */\n    reportError(recognizer, e) {\n       // if we've already reported an error and have not matched a token\n       // yet successfully, don't report any errors.\n        if(this.inErrorRecoveryMode(recognizer)) {\n            return; // don't report spurious errors\n        }\n        this.beginErrorCondition(recognizer);\n        if ( e instanceof NoViableAltException ) {\n            this.reportNoViableAlternative(recognizer, e);\n        } else if ( e instanceof InputMismatchException ) {\n            this.reportInputMismatch(recognizer, e);\n        } else if ( e instanceof FailedPredicateException ) {\n            this.reportFailedPredicate(recognizer, e);\n        } else {\n            console.log(\"unknown recognition error type: \" + e.constructor.name);\n            console.log(e.stack);\n            recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);\n        }\n    }\n\n    /**\n     *\n     * {@inheritDoc}\n     *\n     * <p>The default implementation resynchronizes the parser by consuming tokens\n     * until we find one in the resynchronization set--loosely the set of tokens\n     * that can follow the current rule.</p>\n     *\n     */\n    recover(recognizer, e) {\n        if (this.lastErrorIndex===recognizer.getInputStream().index &&\n            this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {\n            // uh oh, another error at same token index and previously-visited\n            // state in ATN; must be a case where LT(1) is in the recovery\n            // token set so nothing got consumed. Consume a single token\n            // at least to prevent an infinite loop; this is a failsafe.\n            recognizer.consume();\n        }\n        this.lastErrorIndex = recognizer._input.index;\n        if (this.lastErrorStates === null) {\n            this.lastErrorStates = [];\n        }\n        this.lastErrorStates.push(recognizer.state);\n        const followSet = this.getErrorRecoverySet(recognizer)\n        this.consumeUntil(recognizer, followSet);\n    }\n\n    /**\n     * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure\n     * that the current lookahead symbol is consistent with what were expecting\n     * at this point in the ATN. You can call this anytime but ANTLR only\n     * generates code to check before subrules/loops and each iteration.\n     *\n     * <p>Implements Jim Idle's magic sync mechanism in closures and optional\n     * subrules. E.g.,</p>\n     *\n     * <pre>\n     * a : sync ( stuff sync )* ;\n     * sync : {consume to what can follow sync} ;\n     * </pre>\n     *\n     * At the start of a sub rule upon error, {@link //sync} performs single\n     * token deletion, if possible. If it can't do that, it bails on the current\n     * rule and uses the default error recovery, which consumes until the\n     * resynchronization set of the current rule.\n     *\n     * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block\n     * with an empty alternative), then the expected set includes what follows\n     * the subrule.</p>\n     *\n     * <p>During loop iteration, it consumes until it sees a token that can start a\n     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n     * stay in the loop as long as possible.</p>\n     *\n     * <p><strong>ORIGINS</strong></p>\n     *\n     * <p>Previous versions of ANTLR did a poor job of their recovery within loops.\n     * A single mismatch token or missing token would force the parser to bail\n     * out of the entire rules surrounding the loop. So, for rule</p>\n     *\n     * <pre>\n     * classDef : 'class' ID '{' member* '}'\n     * </pre>\n     *\n     * input with an extra token between members would force the parser to\n     * consume until it found the next class definition rather than the next\n     * member definition of the current class.\n     *\n     * <p>This functionality cost a little bit of effort because the parser has to\n     * compare token set at the start of the loop and at each iteration. If for\n     * some reason speed is suffering for you, you can turn off this\n     * functionality by simply overriding this method as a blank { }.</p>\n     *\n     */\n    sync(recognizer) {\n        // If already recovering, don't try to sync\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        const s = recognizer._interp.atn.states[recognizer.state];\n        const la = recognizer.getTokenStream().LA(1);\n        // try cheaper subset first; might get lucky. seems to shave a wee bit off\n        const nextTokens = recognizer.atn.nextTokens(s);\n        if(nextTokens.contains(la)) {\n            this.nextTokensContext = null;\n            this.nextTokenState = ATNState.INVALID_STATE_NUMBER;\n            return;\n        } else if (nextTokens.contains(Token.EPSILON)) {\n            if(this.nextTokensContext === null) {\n                // It's possible the next token won't match information tracked\n                // by sync is restricted for performance.\n                this.nextTokensContext = recognizer._ctx;\n                this.nextTokensState = recognizer._stateNumber;\n            }\n            return;\n        }\n        switch (s.stateType) {\n        case ATNState.BLOCK_START:\n        case ATNState.STAR_BLOCK_START:\n        case ATNState.PLUS_BLOCK_START:\n        case ATNState.STAR_LOOP_ENTRY:\n           // report error and recover if possible\n            if( this.singleTokenDeletion(recognizer) !== null) {\n                return;\n            } else {\n                throw new InputMismatchException(recognizer);\n            }\n        case ATNState.PLUS_LOOP_BACK:\n        case ATNState.STAR_LOOP_BACK:\n            this.reportUnwantedToken(recognizer);\n            const expecting = new IntervalSet()\n            expecting.addSet(recognizer.getExpectedTokens());\n            const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer))\n            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n            break;\n        default:\n            // do nothing if we can't identify the exact kind of ATN state\n        }\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is a\n     * {@link NoViableAltException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportNoViableAlternative(recognizer, e) {\n        const tokens = recognizer.getTokenStream()\n        let input\n        if(tokens !== null) {\n            if (e.startToken.type===Token.EOF) {\n                input = \"<EOF>\";\n            } else {\n                input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));\n            }\n        } else {\n            input = \"<unknown input>\";\n        }\n        const msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is an\n     * {@link InputMismatchException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportInputMismatch(recognizer, e) {\n        const msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) +\n            \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is a\n     * {@link FailedPredicateException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportFailedPredicate(recognizer, e) {\n        const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex]\n        const msg = \"rule \" + ruleName + \" \" + e.message\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This method is called to report a syntax error which requires the removal\n     * of a token from the input stream. At the time this method is called, the\n     * erroneous symbol is current {@code LT(1)} symbol and has not yet been\n     * removed from the input stream. When this method returns,\n     * {@code recognizer} is in error recovery mode.\n     *\n     * <p>This method is called when {@link //singleTokenDeletion} identifies\n     * single-token deletion as a viable recovery strategy for a mismatched\n     * input error.</p>\n     *\n     * <p>The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser//notifyErrorListeners}.</p>\n     *\n     * @param recognizer the parser instance\n     *\n     */\n    reportUnwantedToken(recognizer) {\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken()\n        const tokenName = this.getTokenErrorDisplay(t)\n        const expecting = this.getExpectedTokens(recognizer)\n        const msg = \"extraneous input \" + tokenName + \" expecting \" +\n            expecting.toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n\n    /**\n     * This method is called to report a syntax error which requires the\n     * insertion of a missing token into the input stream. At the time this\n     * method is called, the missing token has not yet been inserted. When this\n     * method returns, {@code recognizer} is in error recovery mode.\n     *\n     * <p>This method is called when {@link //singleTokenInsertion} identifies\n     * single-token insertion as a viable recovery strategy for a mismatched\n     * input error.</p>\n     *\n     * <p>The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser//notifyErrorListeners}.</p>\n     *\n     * @param recognizer the parser instance\n     */\n    reportMissingToken(recognizer) {\n        if ( this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken()\n        const expecting = this.getExpectedTokens(recognizer)\n        const msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +\n            \" at \" + this.getTokenErrorDisplay(t)\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n\n    /**\n     * <p>The default implementation attempts to recover from the mismatched input\n     * by using single token insertion and deletion as described below. If the\n     * recovery attempt fails, this method throws an\n     * {@link InputMismatchException}.</p>\n     *\n     * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>\n     *\n     * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the\n     * right token, however, then assume {@code LA(1)} is some extra spurious\n     * token and delete it. Then consume and return the next token (which was\n     * the {@code LA(2)} token) as the successful result of the match operation.</p>\n     *\n     * <p>This recovery strategy is implemented by {@link\n     * //singleTokenDeletion}.</p>\n     *\n     * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>\n     *\n     * <p>If current token (at {@code LA(1)}) is consistent with what could come\n     * after the expected {@code LA(1)} token, then assume the token is missing\n     * and use the parser's {@link TokenFactory} to create it on the fly. The\n     * \"insertion\" is performed by returning the created token as the successful\n     * result of the match operation.</p>\n     *\n     * <p>This recovery strategy is implemented by {@link\n     * //singleTokenInsertion}.</p>\n     *\n     * <p><strong>EXAMPLE</strong></p>\n     *\n     * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When\n     * the parser returns from the nested call to {@code expr}, it will have\n     * call chain:</p>\n     *\n     * <pre>\n     * stat &rarr; expr &rarr; atom\n     * </pre>\n     *\n     * and it will be trying to match the {@code ')'} at this point in the\n     * derivation:\n     *\n     * <pre>\n     * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'\n     * ^\n     * </pre>\n     *\n     * The attempt to match {@code ')'} will fail when it sees {@code ';'} and\n     * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}\n     * is in the set of tokens that can follow the {@code ')'} token reference\n     * in rule {@code atom}. It can assume that you forgot the {@code ')'}.\n     */\n    recoverInline(recognizer) {\n        // SINGLE TOKEN DELETION\n        const matchedSymbol = this.singleTokenDeletion(recognizer)\n        if (matchedSymbol !== null) {\n            // we have deleted the extra token.\n            // now, move past ttype token as if all were ok\n            recognizer.consume();\n            return matchedSymbol;\n        }\n        // SINGLE TOKEN INSERTION\n        if (this.singleTokenInsertion(recognizer)) {\n            return this.getMissingSymbol(recognizer);\n        }\n        // even that didn't work; must throw the exception\n        throw new InputMismatchException(recognizer);\n    }\n\n    /**\n     * This method implements the single-token insertion inline error recovery\n     * strategy. It is called by {@link //recoverInline} if the single-token\n     * deletion strategy fails to recover from the mismatched input. If this\n     * method returns {@code true}, {@code recognizer} will be in error recovery\n     * mode.\n     *\n     * <p>This method determines whether or not single-token insertion is viable by\n     * checking if the {@code LA(1)} input symbol could be successfully matched\n     * if it were instead the {@code LA(2)} symbol. If this method returns\n     * {@code true}, the caller is responsible for creating and inserting a\n     * token with the correct type to produce this behavior.</p>\n     *\n     * @param recognizer the parser instance\n     * @return {@code true} if single-token insertion is a viable recovery\n     * strategy for the current mismatched input, otherwise {@code false}\n     */\n    singleTokenInsertion(recognizer) {\n        const currentSymbolType = recognizer.getTokenStream().LA(1)\n        // if current token is consistent with what could come after current\n        // ATN state, then we know we're missing a token; error recovery\n        // is free to conjure up and insert the missing token\n        const atn = recognizer._interp.atn\n        const currentState = atn.states[recognizer.state]\n        const next = currentState.transitions[0].target\n        const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx)\n        if (expectingAtLL2.contains(currentSymbolType) ){\n            this.reportMissingToken(recognizer);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * This method implements the single-token deletion inline error recovery\n     * strategy. It is called by {@link //recoverInline} to attempt to recover\n     * from mismatched input. If this method returns null, the parser and error\n     * handler state will not have changed. If this method returns non-null,\n     * {@code recognizer} will <em>not</em> be in error recovery mode since the\n     * returned token was a successful match.\n     *\n     * <p>If the single-token deletion is successful, this method calls\n     * {@link //reportUnwantedToken} to report the error, followed by\n     * {@link Parser//consume} to actually \"delete\" the extraneous token. Then,\n     * before returning {@link //reportMatch} is called to signal a successful\n     * match.</p>\n     *\n     * @param recognizer the parser instance\n     * @return the successfully matched {@link Token} instance if single-token\n     * deletion successfully recovers from the mismatched input, otherwise\n     * {@code null}\n     */\n    singleTokenDeletion(recognizer) {\n        const nextTokenType = recognizer.getTokenStream().LA(2)\n        const expecting = this.getExpectedTokens(recognizer)\n        if (expecting.contains(nextTokenType)) {\n            this.reportUnwantedToken(recognizer);\n            // print(\"recoverFromMismatchedToken deleting \" \\\n            // + str(recognizer.getTokenStream().LT(1)) \\\n            // + \" since \" + str(recognizer.getTokenStream().LT(2)) \\\n            // + \" is what we want\", file=sys.stderr)\n            recognizer.consume(); // simply delete extra token\n            // we want to return the token we're actually matching\n            const matchedSymbol = recognizer.getCurrentToken()\n            this.reportMatch(recognizer); // we know current token is correct\n            return matchedSymbol;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Conjure up a missing token during error recovery.\n     *\n     * The recognizer attempts to recover from single missing\n     * symbols. But, actions might refer to that missing symbol.\n     * For example, x=ID {f($x);}. The action clearly assumes\n     * that there has been an identifier matched previously and that\n     * $x points at that token. If that token is missing, but\n     * the next token in the stream is what we want we assume that\n     * this token is missing and we keep going. Because we\n     * have to return some token to replace the missing token,\n     * we have to conjure one up. This method gives the user control\n     * over the tokens returned for missing tokens. Mostly,\n     * you will want to create something special for identifier\n     * tokens. For literals such as '{' and ',', the default\n     * action in the parser or tree parser works. It simply creates\n     * a CommonToken of the appropriate type. The text will be the token.\n     * If you change what tokens must be created by the lexer,\n     * override this method to create the appropriate tokens.\n     *\n     */\n    getMissingSymbol(recognizer) {\n        const currentSymbol = recognizer.getCurrentToken()\n        const expecting = this.getExpectedTokens(recognizer)\n        const expectedTokenType = expecting.first() // get any element\n        let tokenText\n        if (expectedTokenType===Token.EOF) {\n            tokenText = \"<missing EOF>\";\n        } else {\n            tokenText = \"<missing \" + recognizer.literalNames[expectedTokenType] + \">\";\n        }\n        let current = currentSymbol\n        const lookback = recognizer.getTokenStream().LT(-1)\n        if (current.type===Token.EOF && lookback !== null) {\n            current = lookback;\n        }\n        return recognizer.getTokenFactory().create(current.source,\n            expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,\n            -1, -1, current.line, current.column);\n    }\n\n    getExpectedTokens(recognizer) {\n        return recognizer.getExpectedTokens();\n    }\n\n    /**\n     * How should a token be displayed in an error message? The default\n     * is to display just the text, but during development you might\n     * want to have a lot of information spit out. Override in that case\n     * to use t.toString() (which, for CommonToken, dumps everything about\n     * the token). This is better than forcing you to override a method in\n     * your token objects because you don't have to go modify your lexer\n     * so that it creates a new Java type.\n     */\n    getTokenErrorDisplay(t) {\n        if (t === null) {\n            return \"<no token>\";\n        }\n        let s = t.text\n        if (s === null) {\n            if (t.type===Token.EOF) {\n                s = \"<EOF>\";\n            } else {\n                s = \"<\" + t.type + \">\";\n            }\n        }\n        return this.escapeWSAndQuote(s);\n    }\n\n    escapeWSAndQuote(s) {\n        s = s.replace(/\\n/g,\"\\\\n\");\n        s = s.replace(/\\r/g,\"\\\\r\");\n        s = s.replace(/\\t/g,\"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n\n    /**\n     * Compute the error recovery set for the current rule. During\n     * rule invocation, the parser pushes the set of tokens that can\n     * follow that rule reference on the stack; this amounts to\n     * computing FIRST of what follows the rule reference in the\n     * enclosing rule. See LinearApproximator.FIRST().\n     * This local follow set only includes tokens\n     * from within the rule; i.e., the FIRST computation done by\n     * ANTLR stops at the end of a rule.\n     *\n     * EXAMPLE\n     *\n     * When you find a \"no viable alt exception\", the input is not\n     * consistent with any of the alternatives for rule r. The best\n     * thing to do is to consume tokens until you see something that\n     * can legally follow a call to r//or* any rule that called r.\n     * You don't want the exact set of viable next tokens because the\n     * input might just be missing a token--you might consume the\n     * rest of the input looking for one of the missing tokens.\n     *\n     * Consider grammar:\n     *\n     * a : '[' b ']'\n     * | '(' b ')'\n     * ;\n     * b : c '^' INT ;\n     * c : ID\n     * | INT\n     * ;\n     *\n     * At each rule invocation, the set of tokens that could follow\n     * that rule is pushed on a stack. Here are the various\n     * context-sensitive follow sets:\n     *\n     * FOLLOW(b1_in_a) = FIRST(']') = ']'\n     * FOLLOW(b2_in_a) = FIRST(')') = ')'\n     * FOLLOW(c_in_b) = FIRST('^') = '^'\n     *\n     * Upon erroneous input \"[]\", the call chain is\n     *\n     * a -> b -> c\n     *\n     * and, hence, the follow context stack is:\n     *\n     * depth follow set start of rule execution\n     * 0 <EOF> a (from main())\n     * 1 ']' b\n     * 2 '^' c\n     *\n     * Notice that ')' is not included, because b would have to have\n     * been called from a different context in rule a for ')' to be\n     * included.\n     *\n     * For error recovery, we cannot consider FOLLOW(c)\n     * (context-sensitive or otherwise). We need the combined set of\n     * all context-sensitive FOLLOW sets--the set of all tokens that\n     * could follow any reference in the call chain. We need to\n     * resync to one of those tokens. Note that FOLLOW(c)='^' and if\n     * we resync'd to that token, we'd consume until EOF. We need to\n     * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n     * In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n     * not consume anything. After printing an error, rule c would\n     * return normally. Rule b would not find the required '^' though.\n     * At this point, it gets a mismatched token error and throws an\n     * exception (since LA(1) is not in the viable following token\n     * set). The rule exception handler tries to recover, but finds\n     * the same recovery set and doesn't consume anything. Rule b\n     * exits normally returning to rule a. Now it finds the ']' (and\n     * with the successful match exits errorRecovery mode).\n     *\n     * So, you can see that the parser walks up the call chain looking\n     * for the token that was a member of the recovery set.\n     *\n     * Errors are not generated in errorRecovery mode.\n     *\n     * ANTLR's error recovery mechanism is based upon original ideas:\n     *\n     * \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n     *\n     * and\n     *\n     * \"A note on error recovery in recursive descent parsers\":\n     * http://portal.acm.org/citation.cfm?id=947902.947905\n     *\n     * Later, Josef Grosch had some good ideas:\n     *\n     * \"Efficient and Comfortable Error Recovery in Recursive Descent\n     * Parsers\":\n     * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n     *\n     * Like Grosch I implement context-sensitive FOLLOW sets that are combined\n     * at run-time upon error to avoid overhead during parsing.\n     */\n    getErrorRecoverySet(recognizer) {\n        const atn = recognizer._interp.atn\n        let ctx = recognizer._ctx\n        const recoverSet = new IntervalSet()\n        while (ctx !== null && ctx.invokingState>=0) {\n            // compute what follows who invoked us\n            const invokingState = atn.states[ctx.invokingState]\n            const rt = invokingState.transitions[0]\n            const follow = atn.nextTokens(rt.followState)\n            recoverSet.addSet(follow);\n            ctx = ctx.parentCtx;\n        }\n        recoverSet.removeOne(Token.EPSILON);\n        return recoverSet;\n    }\n\n// Consume tokens until one matches the given token set.//\n    consumeUntil(recognizer, set) {\n        let ttype = recognizer.getTokenStream().LA(1)\n        while( ttype !== Token.EOF && !set.contains(ttype)) {\n            recognizer.consume();\n            ttype = recognizer.getTokenStream().LA(1);\n        }\n    }\n}\n\n\n/**\n * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\n * by immediately canceling the parse operation with a\n * {@link ParseCancellationException}. The implementation ensures that the\n * {@link ParserRuleContext//exception} field is set for all parse tree nodes\n * that were not completed prior to encountering the error.\n *\n * <p>\n * This error strategy is useful in the following scenarios.</p>\n *\n * <ul>\n * <li><strong>Two-stage parsing:</strong> This error strategy allows the first\n * stage of two-stage parsing to immediately terminate if an error is\n * encountered, and immediately fall back to the second stage. In addition to\n * avoiding wasted work by attempting to recover from errors here, the empty\n * implementation of {@link BailErrorStrategy//sync} improves the performance of\n * the first stage.</li>\n * <li><strong>Silent validation:</strong> When syntax errors are not being\n * reported or logged, and the parse result is simply ignored if errors occur,\n * the {@link BailErrorStrategy} avoids wasting work on recovering from errors\n * when the result will be ignored either way.</li>\n * </ul>\n *\n * <p>\n * {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>\n *\n * @see Parser//setErrorHandler(ANTLRErrorStrategy)\n * */\nclass BailErrorStrategy extends DefaultErrorStrategy {\n    constructor() {\n        super();\n    }\n\n    /**\n     * Instead of recovering from exception {@code e}, re-throw it wrapped\n     * in a {@link ParseCancellationException} so it is not caught by the\n     * rule function catches. Use {@link Exception//getCause()} to get the\n     * original {@link RecognitionException}.\n     */\n    recover(recognizer, e) {\n        let context = recognizer._ctx\n        while (context !== null) {\n            context.exception = e;\n            context = context.parentCtx;\n        }\n        throw new ParseCancellationException(e);\n    }\n\n    /**\n     * Make sure we don't attempt to recover inline; if the parser\n     * successfully recovers, it won't throw an exception.\n     */\n    recoverInline(recognizer) {\n        this.recover(recognizer, new InputMismatchException(recognizer));\n    }\n\n// Make sure we don't attempt to recover from problems in subrules.//\n    sync(recognizer) {\n        // pass\n    }\n}\n\n\nmodule.exports = {BailErrorStrategy, DefaultErrorStrategy};\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n *  3 kinds of errors: prediction errors, failed predicate errors, and\n *  mismatched input errors. In each case, the parser knows where it is\n *  in the input, where it is in the ATN, the rule invocation stack,\n *  and what kind of problem occurred.\n */\n\nconst {PredicateTransition} = require('./../atn/Transition');\nconst {Interval} = require('../IntervalSet').Interval;\n\nclass RecognitionException extends Error {\n    constructor(params) {\n        super(params.message);\n        if (!!Error.captureStackTrace) {\n            Error.captureStackTrace(this, RecognitionException);\n        } else {\n            var stack = new Error().stack;\n        }\n        this.message = params.message;\n        this.recognizer = params.recognizer;\n        this.input = params.input;\n        this.ctx = params.ctx;\n        /**\n         * The current {@link Token} when an error occurred. Since not all streams\n         * support accessing symbols by index, we have to track the {@link Token}\n         * instance itself\n        */\n        this.offendingToken = null;\n        /**\n         * Get the ATN state number the parser was in at the time the error\n         * occurred. For {@link NoViableAltException} and\n         * {@link LexerNoViableAltException} exceptions, this is the\n         * {@link DecisionState} number. For others, it is the state whose outgoing\n         * edge we couldn't match.\n         */\n        this.offendingState = -1;\n        if (this.recognizer!==null) {\n            this.offendingState = this.recognizer.state;\n        }\n    }\n\n    /**\n     * Gets the set of input symbols which could potentially follow the\n     * previously matched symbol at the time this exception was thrown.\n     *\n     * <p>If the set of expected tokens is not known and could not be computed,\n     * this method returns {@code null}.</p>\n     *\n     * @return The set of token types that could potentially follow the current\n     * state in the ATN, or {@code null} if the information is not available.\n     */\n    getExpectedTokens() {\n        if (this.recognizer!==null) {\n            return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n        } else {\n            return null;\n        }\n    }\n\n    // <p>If the state number is not known, this method returns -1.</p>\n    toString() {\n        return this.message;\n    }\n}\n\nclass LexerNoViableAltException extends RecognitionException {\n    constructor(lexer, input, startIndex, deadEndConfigs) {\n        super({message: \"\", recognizer: lexer, input: input, ctx: null});\n        this.startIndex = startIndex;\n        this.deadEndConfigs = deadEndConfigs;\n    }\n\n    toString() {\n        let symbol = \"\";\n        if (this.startIndex >= 0 && this.startIndex < this.input.size) {\n            symbol = this.input.getText(new Interval(this.startIndex,this.startIndex));\n        }\n        return \"LexerNoViableAltException\" + symbol;\n    }\n}\n\n\n/**\n * Indicates that the parser could not decide which of two or more paths\n * to take based upon the remaining input. It tracks the starting token\n * of the offending input and also knows where the parser was\n * in the various paths when the error. Reported by reportNoViableAlternative()\n */\nclass NoViableAltException extends RecognitionException {\n    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {\n        ctx = ctx || recognizer._ctx;\n        offendingToken = offendingToken || recognizer.getCurrentToken();\n        startToken = startToken || recognizer.getCurrentToken();\n        input = input || recognizer.getInputStream();\n        super({message: \"\", recognizer: recognizer, input: input, ctx: ctx});\n        // Which configurations did we try at input.index() that couldn't match\n        // input.LT(1)?//\n        this.deadEndConfigs = deadEndConfigs;\n        // The token object at the start index; the input stream might\n        // not be buffering tokens so get a reference to it. (At the\n        // time the error occurred, of course the stream needs to keep a\n        // buffer all of the tokens but later we might not have access to those.)\n        this.startToken = startToken;\n        this.offendingToken = offendingToken;\n    }\n}\n\n/**\n * This signifies any kind of mismatched input exceptions such as\n * when the current input does not match the expected token.\n*/\nclass InputMismatchException extends RecognitionException {\n    constructor(recognizer) {\n        super({message: \"\", recognizer: recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx});\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n}\n\nfunction formatMessage(predicate, message) {\n    if (message !==null) {\n        return message;\n    } else {\n        return \"failed predicate: {\" + predicate + \"}?\";\n    }\n}\n\n/**\n * A semantic predicate failed during validation. Validation of predicates\n * occurs when normally parsing the alternative just like matching a token.\n * Disambiguating predicate evaluation occurs when we test a predicate during\n * prediction.\n*/\nclass FailedPredicateException extends RecognitionException {\n    constructor(recognizer, predicate, message) {\n        super({\n            message: formatMessage(predicate, message || null), recognizer: recognizer,\n            input: recognizer.getInputStream(), ctx: recognizer._ctx\n        });\n        const s = recognizer._interp.atn.states[recognizer.state]\n        const trans = s.transitions[0]\n        if (trans instanceof PredicateTransition) {\n            this.ruleIndex = trans.ruleIndex;\n            this.predicateIndex = trans.predIndex;\n        } else {\n            this.ruleIndex = 0;\n            this.predicateIndex = 0;\n        }\n        this.predicate = predicate;\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n}\n\n\nclass ParseCancellationException extends Error{\n    constructor() {\n        super()\n        Error.captureStackTrace(this, ParseCancellationException);\n    }\n}\n\nmodule.exports = {\n    RecognitionException,\n    NoViableAltException,\n    LexerNoViableAltException,\n    InputMismatchException,\n    FailedPredicateException,\n    ParseCancellationException\n};\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nmodule.exports.RecognitionException = require('./Errors').RecognitionException;\nmodule.exports.NoViableAltException = require('./Errors').NoViableAltException;\nmodule.exports.LexerNoViableAltException = require('./Errors').LexerNoViableAltException;\nmodule.exports.InputMismatchException = require('./Errors').InputMismatchException;\nmodule.exports.FailedPredicateException = require('./Errors').FailedPredicateException;\nmodule.exports.DiagnosticErrorListener = require('./DiagnosticErrorListener');\nmodule.exports.BailErrorStrategy = require('./ErrorStrategy').BailErrorStrategy;\nmodule.exports.DefaultErrorStrategy = require('./ErrorStrategy').DefaultErrorStrategy;\nmodule.exports.ErrorListener = require('./ErrorListener').ErrorListener;\n","/*! https://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\t'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tconst object = {};\n\t\t\t\tconst $defineProperty = Object.defineProperty;\n\t\t\t\tresult = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {\n\t\t\t}\n\t\t\treturn result;\n\t\t}());\n\t\tconst codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tconst string = String(this);\n\t\t\tconst size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tlet index = position ? Number(position) : 0;\n\t\t\tif (index !== index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tconst first = string.charCodeAt(index);\n\t\t\tlet second;\n\t\t\tif ( // check if it’s the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n","/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tconst defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tconst object = {};\n\t\t\t\tconst $defineProperty = Object.defineProperty;\n\t\t\t\tresult = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tconst stringFromCharCode = String.fromCharCode;\n\t\tconst floor = Math.floor;\n\t\tconst fromCodePoint = function(_) {\n\t\t\tconst MAX_SIZE = 0x4000;\n\t\t\tconst codeUnits = [];\n\t\t\tlet highSurrogate;\n\t\t\tlet lowSurrogate;\n\t\t\tlet index = -1;\n\t\t\tconst length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tlet codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) !== codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst {Interval} = require('./../IntervalSet');\nconst INVALID_INTERVAL = new Interval(-1, -2);\n\n/**\n * The basic notion of a tree has a parent, a payload, and a list of children.\n * It is the most abstract interface for all the trees used by ANTLR.\n */\nclass Tree {}\n\nclass SyntaxTree extends Tree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ParseTree extends SyntaxTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass RuleNode extends ParseTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tgetRuleContext(){\n\t\tthrow new Error(\"missing interface implementation\")\n\t}\n}\n\nclass TerminalNode extends ParseTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ErrorNode extends TerminalNode {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ParseTreeVisitor {\n\tvisit(ctx) {\n\t\t if (Array.isArray(ctx)) {\n\t\t\treturn ctx.map(function(child) {\n\t\t\t\treturn child.accept(this);\n\t\t\t}, this);\n\t\t} else {\n\t\t\treturn ctx.accept(this);\n\t\t}\n\t}\n\n\tvisitChildren(ctx) {\n\t\tif (ctx.children) {\n\t\t\treturn this.visit(ctx.children);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tvisitTerminal(node) {\n\t}\n\n\tvisitErrorNode(node) {\n\t}\n}\n\nclass ParseTreeListener {\n\tvisitTerminal(node) {\n\t}\n\n\tvisitErrorNode(node) {\n\t}\n\n\tenterEveryRule(node) {\n\t}\n\n\texitEveryRule(node) {\n\t}\n}\n\nclass TerminalNodeImpl extends TerminalNode {\n\tconstructor(symbol) {\n\t\tsuper();\n\t\tthis.parentCtx = null;\n\t\tthis.symbol = symbol;\n\t}\n\n\tgetChild(i) {\n\t\treturn null;\n\t}\n\n\tgetSymbol() {\n\t\treturn this.symbol;\n\t}\n\n\tgetParent() {\n\t\treturn this.parentCtx;\n\t}\n\n\tgetPayload() {\n\t\treturn this.symbol;\n\t}\n\n\tgetSourceInterval() {\n\t\tif (this.symbol === null) {\n\t\t\treturn INVALID_INTERVAL;\n\t\t}\n\t\tconst tokenIndex = this.symbol.tokenIndex;\n\t\treturn new Interval(tokenIndex, tokenIndex);\n\t}\n\n\tgetChildCount() {\n\t\treturn 0;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitTerminal(this);\n\t}\n\n\tgetText() {\n\t\treturn this.symbol.text;\n\t}\n\n\ttoString() {\n\t\tif (this.symbol.type === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else {\n\t\t\treturn this.symbol.text;\n\t\t}\n\t}\n}\n\n\n/**\n * Represents a token that was consumed during resynchronization\n * rather than during a valid match operation. For example,\n * we will create this kind of a node during single token insertion\n * and deletion as well as during \"consume until error recovery set\"\n * upon no viable alternative exceptions.\n */\nclass ErrorNodeImpl extends TerminalNodeImpl {\n\tconstructor(token) {\n\t\tsuper(token);\n\t}\n\n\tisErrorNode() {\n\t\treturn true;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitErrorNode(this);\n\t}\n}\n\nclass ParseTreeWalker {\n\n\t/**\n\t * Performs a walk on the given parse tree starting at the root and going down recursively\n\t * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before\n\t * recursively walking down into child nodes, then\n\t * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.\n\t * @param listener The listener used by the walker to process grammar rules\n\t * @param t The parse tree to be walked on\n\t */\n\twalk(listener, t) {\n\t\tconst errorNode = t instanceof ErrorNode ||\n\t\t\t\t(t.isErrorNode !== undefined && t.isErrorNode());\n\t\tif (errorNode) {\n\t\t\tlistener.visitErrorNode(t);\n\t\t} else if (t instanceof TerminalNode) {\n\t\t\tlistener.visitTerminal(t);\n\t\t} else {\n\t\t\tthis.enterRule(listener, t);\n\t\t\tfor (let i = 0; i < t.getChildCount(); i++) {\n\t\t\t\tconst child = t.getChild(i);\n\t\t\t\tthis.walk(listener, child);\n\t\t\t}\n\t\t\tthis.exitRule(listener, t);\n\t\t}\n\t}\n\n\t/**\n\t * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}\n\t * then by triggering the event specific to the given parse tree node\n\t * @param listener The listener responding to the trigger events\n\t * @param r The grammar rule containing the rule context\n\t */\n\tenterRule(listener, r) {\n\t\tconst ctx = r.getRuleContext();\n\t\tlistener.enterEveryRule(ctx);\n\t\tctx.enterRule(listener);\n\t}\n\n\t/**\n\t * Exits a grammar rule by first triggering the event specific to the given parse tree node\n\t * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}\n\t * @param listener The listener responding to the trigger events\n\t * @param r The grammar rule containing the rule context\n\t */\n\texitRule(listener, r) {\n\t\tconst ctx = r.getRuleContext();\n\t\tctx.exitRule(listener);\n\t\tlistener.exitEveryRule(ctx);\n\t}\n}\n\nParseTreeWalker.DEFAULT = new ParseTreeWalker();\n\nmodule.exports = {\n\tRuleNode,\n\tErrorNode,\n\tTerminalNode,\n\tErrorNodeImpl,\n\tTerminalNodeImpl,\n\tParseTreeListener,\n\tParseTreeVisitor,\n\tParseTreeWalker,\n\tINVALID_INTERVAL\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Utils = require('./../Utils');\nconst {Token} = require('./../Token');\nconst {ErrorNode, TerminalNode, RuleNode} = require('./Tree');\n\n/** A set of utility routines useful for all kinds of ANTLR trees. */\nconst Trees = {\n    /**\n     * Print out a whole tree in LISP form. {@link //getNodeText} is used on the\n     *  node payloads to get the text for the nodes.  Detect\n     *  parse trees and extract data appropriately.\n     */\n    toStringTree: function(tree, ruleNames, recog) {\n        ruleNames = ruleNames || null;\n        recog = recog || null;\n        if(recog!==null) {\n            ruleNames = recog.ruleNames;\n        }\n        let s = Trees.getNodeText(tree, ruleNames);\n        s = Utils.escapeWhitespace(s, false);\n        const c = tree.getChildCount();\n        if(c===0) {\n            return s;\n        }\n        let res = \"(\" + s + ' ';\n        if(c>0) {\n            s = Trees.toStringTree(tree.getChild(0), ruleNames);\n            res = res.concat(s);\n        }\n        for(let i=1;i<c;i++) {\n            s = Trees.toStringTree(tree.getChild(i), ruleNames);\n            res = res.concat(' ' + s);\n        }\n        res = res.concat(\")\");\n        return res;\n    },\n\n    getNodeText: function(t, ruleNames, recog) {\n        ruleNames = ruleNames || null;\n        recog = recog || null;\n        if(recog!==null) {\n            ruleNames = recog.ruleNames;\n        }\n        if(ruleNames!==null) {\n            if (t instanceof RuleNode) {\n                const context = t.getRuleContext()\n                const altNumber = context.getAltNumber();\n                // use const value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n                if ( altNumber != 0 ) {\n                    return ruleNames[t.ruleIndex]+\":\"+altNumber;\n                }\n                return ruleNames[t.ruleIndex];\n            } else if ( t instanceof ErrorNode) {\n                return t.toString();\n            } else if(t instanceof TerminalNode) {\n                if(t.symbol!==null) {\n                    return t.symbol.text;\n                }\n            }\n        }\n        // no recog for rule names\n        const payload = t.getPayload();\n        if (payload instanceof Token ) {\n            return payload.text;\n        }\n        return t.getPayload().toString();\n    },\n\n    /**\n     * Return ordered list of all children of this node\n     */\n    getChildren: function(t) {\n        const list = [];\n        for(let i=0;i<t.getChildCount();i++) {\n            list.push(t.getChild(i));\n        }\n        return list;\n    },\n\n    /**\n     * Return a list of all ancestors of this node.  The first node of\n     * list is the root and the last is the parent of this node.\n     */\n    getAncestors: function(t) {\n        let ancestors = [];\n        t = t.getParent();\n        while(t!==null) {\n            ancestors = [t].concat(ancestors);\n            t = t.getParent();\n        }\n        return ancestors;\n    },\n\n    findAllTokenNodes: function(t, ttype) {\n        return Trees.findAllNodes(t, ttype, true);\n    },\n\n    findAllRuleNodes: function(t, ruleIndex) {\n        return Trees.findAllNodes(t, ruleIndex, false);\n    },\n\n    findAllNodes: function(t, index, findTokens) {\n        const nodes = [];\n        Trees._findAllNodes(t, index, findTokens, nodes);\n        return nodes;\n    },\n\n    _findAllNodes: function(t, index, findTokens, nodes) {\n        // check this node (the root) first\n        if(findTokens && (t instanceof TerminalNode)) {\n            if(t.symbol.type===index) {\n                nodes.push(t);\n            }\n        } else if(!findTokens && (t instanceof RuleNode)) {\n            if(t.ruleIndex===index) {\n                nodes.push(t);\n            }\n        }\n        // check children\n        for(let i=0;i<t.getChildCount();i++) {\n            Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n        }\n    },\n\n    descendants: function(t) {\n        let nodes = [t];\n        for(let i=0;i<t.getChildCount();i++) {\n            nodes = nodes.concat(Trees.descendants(t.getChild(i)));\n        }\n        return nodes;\n    }\n}\n\nmodule.exports = Trees;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Tree = require('./Tree');\nconst Trees = require('./Trees');\nmodule.exports = {...Tree, Trees}\n","// Contains the additional FHIRPath functions.\n// See https://build.fhir.org/fhirpath.html#functions for details.\nconst util = require(\"./utilities\");\nconst Terminologies = require('./terminologies');\n\nlet engine = {};\n\n/**\n * Returns true if the code is a member of the given valueset.\n * @param {(string|Object)[]} coll - input collection with a single Coding,\n *  CodeableConcept, or code element.\n * @param {string} valueset - value set URL\n * @return {Promise<boolean>|[]} - promise of a boolean value indicating that\n *  there is one element in the input collection whose code is a member of the\n *  specified value set.\n */\nengine.memberOf = function (coll, valueset ) {\n  if (!this.async) {\n    throw new Error('The asynchronous function \"memberOf\" is not allowed. ' +\n      'To enable asynchronous functions, use the async=true or async=\"always\"' +\n      ' option.');\n  }\n  // If the input is empty or has more than one value, the return value is empty\n  if (coll.length !== 1 || coll[0] == null) {\n    return [];\n  }\n\n  if (typeof valueset === 'string' && /^https?:\\/\\/.*/.test(valueset)) {\n    const terminologies = this.processedVars.terminologies;\n    if (!terminologies) {\n      throw new Error('Option \"terminologyUrl\" is not specified.');\n    }\n    return Terminologies.validateVS(\n      [terminologies], valueset, util.valData(coll[0]), ''\n    ).then(params => {\n      return params.parameter.find((p) => p.name === \"result\").valueBoolean;\n    }, () => []);\n  }\n\n  // If the valueset cannot be resolved as an uri to a value set,\n  // the return value is empty.\n  return [];\n};\n\nmodule.exports = engine;\n","// Contains the FHIRPath Aggregate functions.\n// (Section 7 of the FHIRPath 2.0.0 (N1) specification).\n\nlet engine = {};\nconst math = require(\"./math\");\nconst equality  = require(\"./equality\");\nconst util = require('./utilities');\n\nengine.aggregateMacro = function(data, expr, initialValue) {\n  return data.reduce((total, x, i) => {\n    if (total instanceof Promise) {\n      return total.then((t) => {\n        this.$index = i;\n        this.$total = t;\n        return this.$total = expr(x);\n      });\n    } else {\n      this.$index = i;\n      return this.$total = expr(x);\n    }\n  }, this.$total = initialValue);\n};\n\nengine.countFn = function(x) {\n  if (x && x.length) {\n    return x.length;\n  } else {\n    return 0;\n  }\n};\n\n// Shortcut for \"value.tail().aggregate($this+$total, value.first())\" `\nengine.sumFn = function(data) {\n  return engine.aggregateMacro.apply(this, [data.slice(1), ($this) => {\n    let x = util.arraify($this).filter(i => util.valData(i) != null);\n    let y = util.arraify(this.$total).filter(i => util.valData(i) != null);\n    if (x.length === 0 || y.length === 0) {\n      return [];\n    }\n    return math.plus(x, y);\n  }, data[0]]);\n};\n\n/**\n * Shortcut for \"[source collection].aggregate(iif($total.empty(), $this, iif($this [operator] $total, $this, $total)))\"\n * Used for functions min() and max().\n * @param {Array} data - source collection\n * @param {Function} fn - operator function\n * @return {Array}\n */\nfunction minMaxShortcutTemplate(data, fn) {\n  let $total;\n  if (data.length === 0 || util.valData(data[0]) == null) {\n    $total = [];\n  } else {\n    $total = [data[0]];\n    for (let i = 1; i < data.length; i++) {\n      if (util.valData(data[i]) == null) {\n        $total = [];\n        break;\n      }\n      const $this = [data[i]];\n      $total = util.isTrue(fn($this, $total)) ? $this : $total;\n    }\n  }\n  return $total;\n}\n\n// Shortcut for \"value.aggregate(iif($total.empty(), $this, iif($this < $total, $this, $total)))\"\nengine.minFn = function (data) {\n  return minMaxShortcutTemplate(data, equality.lt);\n};\n\n// Shortcut for \"value.aggregate(iif($total.empty(), $this, iif($this > $total, $this, $total)))\"\nengine.maxFn = function (data) {\n  return minMaxShortcutTemplate(data, equality.gt);\n};\n\n// Shortcut for \"value.sum()/value.count()\"\nengine.avgFn = function (data) {\n  const x = util.arraify(engine.sumFn(data));\n  const y = util.arraify(engine.countFn(data));\n  if (x.length === 0 || y.length === 0) {\n    return [];\n  }\n  return math.div(x, y);\n};\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Math functions.\n\nconst { deepEqual } = require('./deep-equal');\n\nconst engine = {};\n\n\n// \"b\" is assumed to have one element and it tests whether \"b[0]\" is in \"a\"\nfunction containsImpl(a,b){\n  for(var i = 0; i < a.length; i++){\n    if(deepEqual(a[i], b[0])) { return true; }\n  }\n  return false;\n}\n\nengine.contains = function(a, b){\n  if(b.length == 0) { return []; }\n  if(a.length == 0) { return false; }\n  if(b.length > 1) {\n    throw new Error(\"Expected singleton on right side of contains, got \" + JSON.stringify(b));\n  }\n  return containsImpl(a,b);\n};\n\nengine.in = function(a, b){\n  if(a.length == 0) { return []; }\n  if(b.length == 0) { return false; }\n  if(a.length > 1) {\n    throw new Error(\"Expected singleton on right side of in, got \" + JSON.stringify(b));\n  }\n  return containsImpl(b,a);\n};\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Combining functions.\n\nconst combineFns = {};\nconst { distinctFn } = require('./filtering');\nconst hashObject = require('./hash-object');\nconst { deepEqual, maxCollSizeForDeepEqual } = require('./deep-equal');\n\ncombineFns.union = function(coll1, coll2){\n  return distinctFn(coll1.concat(coll2));\n};\n\ncombineFns.combineFn = function(coll1, coll2){\n  return coll1.concat(coll2);\n};\n\ncombineFns.intersect = function(coll1, coll2) {\n  let result = [];\n  const coll1Length = coll1.length;\n  let uncheckedLength = coll2.length;\n\n  if (coll1Length && uncheckedLength) {\n    if (coll1Length + uncheckedLength > maxCollSizeForDeepEqual) {\n      // When we have more than maxCollSizeForDeepEqual items in input collections,\n      // we use a hash table (on JSON strings) for efficiency.\n      let coll2hash = {};\n      coll2.forEach(item => {\n        const hash = hashObject(item);\n        if (coll2hash[hash]) {\n          uncheckedLength--;\n        } else {\n          coll2hash[hash] = true;\n        }\n      });\n\n      for (let i = 0; i < coll1Length && uncheckedLength > 0; ++i) {\n        let item = coll1[i];\n        let hash = hashObject(item);\n        if (coll2hash[hash]) {\n          result.push(item);\n          coll2hash[hash] = false;\n          uncheckedLength--;\n        }\n      }\n    } else {\n      // Otherwise, it is more efficient to perform a deep comparison.\n      result = distinctFn(coll1).filter(\n        obj1 => coll2.some(obj2 => deepEqual(obj1, obj2))\n      );\n    }\n  }\n\n  return result;\n};\n\n\ncombineFns.exclude = function(coll1, coll2) {\n  let result = [];\n\n  const coll1Length = coll1.length;\n  const coll2Length = coll2.length;\n\n  if (!coll2Length) {\n    return coll1;\n  }\n  if (coll1Length) {\n    if (coll1Length + coll2Length > maxCollSizeForDeepEqual) {\n      // When we have more than maxCollSizeForDeepEqual items in input collections,\n      // we use a hash table (on JSON strings) for efficiency.\n      let coll2hash = {};\n      coll2.forEach(item => {\n        const hash = hashObject(item);\n        coll2hash[hash] = true;\n      });\n\n      result = coll1.filter(item => !coll2hash[hashObject(item)]);\n    } else {\n      // Otherwise, it is more efficient to perform a deep comparison.\n      result = coll1.filter(item => {\n        return !coll2.some(item2 => deepEqual(item, item2));\n      });\n    }\n  }\n\n  return result;\n};\n\n\nmodule.exports = combineFns;\n","// These are values that should not change during an evaluation of a FHIRPath\n// expression (e.g. the return value of today(), per the spec.)  They are\n// constant during at least one evaluation.\n\nmodule.exports = {\n  /**\n   *  Resets the constants.  Should be called when before the engine starts its\n   *  processing.\n   */\n  reset: function() {\n    this.nowDate = new Date(); // a Date object representing \"now\"\n    this.today = null;\n    this.now = null;\n    this.timeOfDay = null;\n    this.localTimezoneOffset = null;\n  },\n\n  /**\n   *  The cached value of today().\n   */\n  today: null,\n\n  /**\n   *  The cached value of now().\n   */\n  now: null,\n\n  /**\n   *  The cached value of timeOfDay().\n   */\n  timeOfDay: null\n};\n","var engine = {};\nconst types = require('./types');\nconst constants = require('./constants');\nconst FP_Date = types.FP_Date;\nconst FP_DateTime = types.FP_DateTime;\nconst FP_Time = types.FP_Time;\n\n/**\n *  Implements FHIRPath now().\n */\nengine.now = function(){\n  if (!constants.now) {\n    // return new FP_DateTime((new Date()).toISOString());\n    // The above would construct an FP_DateTime with a timezone of \"Z\", which\n    // would not make a difference for computation, but if the end result of an\n    // expression is \"now()\", then it would look different when output to a user.\n    // Construct it ourselves to preserve timezone\n    var now = constants.nowDate; // a JS Date\n    var isoStr = FP_DateTime.isoDateTime(now);\n    constants.now = new FP_DateTime(isoStr);\n  }\n  return constants.now;\n};\n\n\n/**\n *  Implements FHIRPath today().  See comments in now(). This does not\n *  include a timezone offset.\n */\nengine.today = function(){\n  if (!constants.today) {\n    // Construct the string ourselves to preserve timezone\n    var now = constants.nowDate; // a JS Date\n    var isoStr = FP_Date.isoDate(now);\n    constants.today = new FP_Date(isoStr);\n  }\n  return constants.today;\n};\n\n/**\n *  Implements FHIRPath timeOfDay().  See comments in now(). This does not\n *  include a timezone offset.\n */\nengine.timeOfDay = function() {\n  if (!constants.timeOfDay) {\n    // Construct the string ourselves to preserve timezone\n    const now = constants.nowDate; // a JS Date\n    const isoStr = FP_DateTime.isoTime(now);\n    constants.timeOfDay = new FP_Time(isoStr);\n  }\n  return constants.timeOfDay;\n};\n\nmodule.exports = engine;\n","// Originally copied from node-deep-equal\n// (https://github.com/substack/node-deep-equal), with modifications.\n// For the license for node-deep-equal, see the bottom of this file.\n\nconst {FP_Type, FP_Quantity} = require('./types');\nvar util = require('./utilities');\nvar numbers = require('./numbers');\nvar pSlice = Array.prototype.slice;\nvar objectKeys = Object.keys;\nvar isArguments = function (object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nfunction isString(myVar) {\n  return (typeof myVar === 'string' || myVar instanceof String);\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction normalizeStr(x) {\n  return x.toUpperCase().replace(/\\s+/, ' ');\n}\n\n/**\n * Performs a deep comparison between two values to determine if they are equal.\n * When you need to compare many objects, you can use hashObject instead for\n * optimization (if changes are needed here, they are likely also needed there).\n * @param {any} actual - one of the comparing objects\n * @param {any} expected - one of the comparing objects\n * @param {Object} [opts] - comparison options\n * @param {boolean} [opts.fuzzy] - false (by default), if comparing objects for\n *   equality (see https://hl7.org/fhirpath/#equals).\n *   true, if comparing objects for equivalence\n *   (see https://hl7.org/fhirpath/#equivalent).\n * @return {boolean}\n */\nfunction deepEqual(actual, expected, opts) {\n  actual = util.valDataConverted(actual);\n  expected = util.valDataConverted(expected);\n  if (!opts) opts = {};\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  }\n\n  if (opts.fuzzy) {\n    if(isString(actual) && isString(expected)) {\n      return normalizeStr(actual) == normalizeStr(expected);\n    }\n    if(isNumber(actual) && isNumber(expected)) {\n      return numbers.isEquivalent(actual, expected);\n    }\n  }\n  else { // !opts.fuzzy\n    // If these are numbers, they need to be rounded to the maximum supported\n    // precision to remove floating point arithmetic errors (e.g. 0.1+0.1+0.1 should\n    // equal 0.3) before comparing.\n    if (typeof actual === 'number' && typeof expected === 'number') {\n      return numbers.isEqual(actual, expected);\n    }\n  }\n\n  if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return actual === expected;\n  }\n  else {\n    var actualIsFPT = actual instanceof FP_Type;\n    var expectedIsFPT = expected instanceof FP_Type;\n    if (actualIsFPT && expectedIsFPT) { // if both are FP_Type\n      return opts.fuzzy ? actual.equivalentTo(expected) :\n        actual.equals(expected); // May return undefined\n    }\n    else if (actualIsFPT || expectedIsFPT) { // if only one is an FP_Type\n      let anotherIsNumber = false;\n      if (typeof actual == 'number') {\n        actual = new FP_Quantity(actual, \"'1'\");\n        anotherIsNumber = true;\n      }\n      if (typeof expected == 'number') {\n        expected = new FP_Quantity(expected, \"'1'\");\n        anotherIsNumber = true;\n      }\n      if (anotherIsNumber) {\n        return opts.fuzzy ? actual.equivalentTo(expected) :\n          actual.equals(expected);\n      }\n      return false;\n    }\n    // 7.4. For all other Object pairs, including Array objects, equivalence is\n    // determined by having the same number of owned properties (as verified\n    // with Object.prototype.hasOwnProperty.call), the same set of keys\n    // (although not necessarily the same order), equivalent values for every\n    // corresponding key, and an identical 'prototype' property. Note: this\n    // accounts for both named and indexed properties on Arrays.\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if(isArguments(a) || isArguments(b)) {\n    a = isArguments(a) ? pSlice.call(a) : a;\n    b = isArguments(b) ? pSlice.call(b) : b;\n    return deepEqual(a, b, opts);\n  }\n  try {\n    var ka = objectKeys(a), kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  // If the length of the array is one, return the value of deepEqual (which can\n  // be \"undefined\".\n  if (ka.length === 1) {\n    key = ka[0];\n    return deepEqual(a[key], b[key], opts);\n  }\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\nmodule.exports = {\n  deepEqual,\n  // Maximum collection length to use deepEqual(). When comparing a large number\n  // of collection items, it is more efficient to convert the items to strings\n  // using the hashObject() function and compare them.\n  maxCollSizeForDeepEqual: 6\n};\n\n// The license for node-deep-equal, on which the above code is based, is as\n// follows:\n//\n// This software is released under the MIT license:\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n","// This file holds code to handle the FHIRPath Math functions.\n\nconst util = require(\"./utilities\");\nconst { deepEqual } = require('./deep-equal');\nconst types = require('./types');\nconst FP_Type = types.FP_Type;\nconst FP_DateTime = types.FP_DateTime;\n\nvar engine = {};\n\nfunction equality(x,y){\n  if(util.isEmpty(x) || util.isEmpty(y)) { return []; }\n  return deepEqual(x, y);\n}\n\nfunction equivalence(x,y){\n  if(util.isEmpty(x) && util.isEmpty(y)) { return [true]; }\n  if(util.isEmpty(x) || util.isEmpty(y)) { return []; }\n  return deepEqual(x, y, {fuzzy: true});\n}\n\nengine.equal = function(a, b){\n  return equality(a, b);\n};\n\nengine.unequal = function(a, b){\n  var eq = equality(a, b);\n  return eq === undefined ? undefined : !eq;\n};\n\nengine.equival = function(a, b){\n  return equivalence(a, b);\n};\n\nengine.unequival = function(a, b){\n  return !equivalence(a, b);\n};\n\n/**\n *  Checks that the types of a and b are suitable for comparison in an\n *  inequality expression.\n * @param a the left side of the inequality expression (which should be an array of\n *  one value).\n * @param b the right side of the inequality expression (which should be an array of\n *  one value).\n * @return the singleton values of the arrays a, and b.  If one was an FP_Type\n *  and the other was convertible, the converted value will be returned.\n */\nfunction typecheck(a, b){\n  util.assertOnlyOne(a, \"Singleton was expected\");\n  util.assertOnlyOne(b, \"Singleton was expected\");\n  a = util.valDataConverted(a[0]);\n  b = util.valDataConverted(b[0]);\n  if (a != null && b != null) {\n    let lClass = a instanceof FP_DateTime ? FP_DateTime : a.constructor;\n    let rClass = b instanceof FP_DateTime ? FP_DateTime : b.constructor;\n    if (lClass !== rClass) {\n      util.raiseError('Type of \"' + a + '\" (' + lClass.name + ') did not match type of \"' +\n        b + '\" (' + rClass.name + ')', 'InequalityExpression');\n    }\n  }\n  return [a, b];\n}\n\nengine.lt = function(a, b){\n  const [a0, b0] = typecheck(a,b);\n  if (a0 == null || b0 == null) {\n    return [];\n  }\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare < 0;\n  }\n  return a0 < b0;\n};\n\nengine.gt = function(a, b){\n  const [a0, b0] = typecheck(a,b);\n  if (a0 == null || b0 == null) {\n    return [];\n  }\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare > 0;\n  }\n  return a0 > b0;\n};\n\nengine.lte = function(a, b){\n  const [a0, b0] = typecheck(a,b);\n  if (a0 == null || b0 == null) {\n    return [];\n  }\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare <= 0;\n  }\n  return  a0 <= b0;\n};\n\nengine.gte = function(a, b){\n  const [a0, b0] = typecheck(a,b);\n  if (a0 == null || b0 == null) {\n    return [];\n  }\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare >= 0;\n  }\n  return a0 >= b0;\n};\n\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Existence functions (5.1 in the\n// specification).\n\nconst util = require(\"./utilities\");\nconst {whereMacro, distinctFn} = require(\"./filtering\");\nconst misc = require(\"./misc\");\nconst hashObject = require('./hash-object');\nconst { deepEqual, maxCollSizeForDeepEqual } = require('./deep-equal');\n\nconst engine = {};\nengine.emptyFn = util.isEmpty;\n\nengine.notFn = function(coll) {\n  let d = misc.singleton(coll, 'Boolean');\n  return (typeof (d) === 'boolean') ? !d : [];\n};\n\nengine.existsMacro  = function(coll, expr) {\n  if (expr) {\n    const exprRes = whereMacro.call(this, coll, expr);\n    if (exprRes instanceof Promise) {\n      return exprRes.then(r => engine.existsMacro(r));\n    }\n    return engine.existsMacro(exprRes);\n  }\n  return !util.isEmpty(coll);\n};\n\nengine.allMacro = function(coll, expr) {\n  const promises = [];\n  for (let i=0, len=coll.length; i<len; ++i) {\n    this.$index = i;\n    const exprRes = expr(coll[i]);\n    if (exprRes instanceof Promise) {\n      promises.push(exprRes);\n    } else if(!util.isTrue(exprRes)){\n      return [false];\n    }\n  }\n  if (promises.length) {\n    return Promise.all(promises).then(r => r.some(i => !util.isTrue(i)) ? [false] : [true]);\n  }\n  return [true];\n};\n\nengine.allTrueFn  = function(x) {\n  let rtn = true;\n  for (let i=0, len=x.length; i<len && rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"allTrue\");\n    rtn = xi === true;\n  }\n  return [rtn];\n};\n\nengine.anyTrueFn  = function(x) {\n  let rtn = false;\n  for (let i=0, len=x.length; i<len && !rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"anyTrue\");\n    rtn = xi === true;\n  }\n  return [rtn];\n};\n\nengine.allFalseFn  = function(x) {\n  let rtn = true;\n  for (let i=0, len=x.length; i<len && rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"allFalse\");\n    rtn = xi === false;\n  }\n  return [rtn];\n};\n\nengine.anyFalseFn  = function(x) {\n  let rtn = false;\n  for (let i=0, len=x.length; i<len && !rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"anyFalse\");\n    rtn = xi === false;\n  }\n  return [rtn];\n};\n\n\n/**\n *  Returns true if coll1 is a subset of coll2.\n */\nfunction subsetOf(coll1, coll2) {\n  const coll1Length = coll1.length;\n  const coll2Length = coll2.length;\n  let rtn = coll1Length <= coll2Length;\n  if (rtn) {\n    if (coll1Length + coll2Length > maxCollSizeForDeepEqual) {\n      // When we have more than maxCollSizeForDeepEqual items in input collections,\n      // we use a hash table (on JSON strings) for efficiency.\n      const c2Hash = coll2.reduce((hash, item) => {\n        hash[hashObject(item)] = true;\n        return hash;\n      }, {});\n      rtn = !coll1.some(item => !c2Hash[hashObject(item)]);\n    } else {\n      // Otherwise, it is more efficient to perform a deep comparison.\n      for (let p=0, pLen=coll1.length; p<pLen && rtn; ++p) {\n        let obj1 = util.valData(coll1[p]);\n        rtn = coll2.some(obj2 => deepEqual(obj1, util.valData(obj2)));\n      }\n    }\n  }\n  return rtn;\n}\n\nengine.subsetOfFn = function(coll1, coll2) {\n  return [subsetOf(coll1, coll2)];\n};\n\nengine.supersetOfFn = function(coll1, coll2) {\n  return [subsetOf(coll2, coll1)];\n};\n\nengine.isDistinctFn = function(x) {\n  return [x.length === distinctFn(x).length];\n};\n\nmodule.exports = engine;\n","// This file contains a class that implements the Type Factory API.\n// See https://hl7.org/fhir/fhirpath.html#factory for details.\nconst util = require(\"./utilities\");\nconst { ResourceNode, TypeInfo, instantRE, timeRE, dateRE, dateTimeRE} = require(\"./types\");\n\nclass Factory {\n  // Same as fhirpath.invocationTable, but for %factory methods\n  static invocationTable = {\n    Extension: {fn: Factory.Extension, arity: {2: ['String', 'AnyAtRoot']}},\n    Identifier: {\n      fn: Factory.Identifier,\n      arity: {\n        1: ['String'],\n        2: ['String', 'String'],\n        3: ['String', 'String', 'String'],\n        4: ['String', 'String', 'String', 'Any']\n      }\n    },\n    HumanName: {\n      fn: Factory.HumanName,\n      arity: {\n        1: ['String'],\n        2: ['String', 'AnyAtRoot'],\n        3: ['String', 'AnyAtRoot', 'String'],\n        4: ['String', 'AnyAtRoot', 'String', 'String'],\n        5: ['String', 'AnyAtRoot', 'String', 'String', 'String'],\n        6: ['String', 'AnyAtRoot', 'String', 'String', 'String', 'String']\n      },\n    },\n    ContactPoint: {\n      fn: Factory.ContactPoint,\n      arity: {\n        1: ['String'],\n        2: ['String', 'String'],\n        3: ['String', 'String', 'String']\n      },\n    },\n    Address: {\n      fn: Factory.Address,\n      arity: {\n        1: ['AnyAtRoot'],\n        2: ['AnyAtRoot', 'String'],\n        3: ['AnyAtRoot', 'String', 'String'],\n        4: ['AnyAtRoot', 'String', 'String', 'String'],\n        5: ['AnyAtRoot', 'String', 'String', 'String', 'String'],\n        6: ['AnyAtRoot', 'String', 'String', 'String', 'String', 'String'],\n        7: ['AnyAtRoot', 'String', 'String', 'String', 'String', 'String', 'String']\n      },\n    },\n    Quantity: {\n      fn: Factory.Quantity,\n      arity: {\n        1: ['String'],\n        2: ['String', 'String'],\n        3: ['String', 'String', 'StringOrNumber'],\n        4: ['String', 'String', 'StringOrNumber', 'String']\n      }\n    },\n    Coding: {\n      fn: Factory.Coding,\n      arity: {\n        1: ['String'],\n        2: ['String', 'String'],\n        3: ['String', 'String', 'String'],\n        4: ['String', 'String', 'String', 'String']\n      }\n    },\n    CodeableConcept: {\n      fn: Factory.CodeableConcept,\n      arity: {\n        1: ['AnyAtRoot'],\n        2: ['AnyAtRoot', 'String']\n      }\n    },\n    create: {\n      fn: Factory.create,\n      arity: {\n        1: ['TypeSpecifier']\n      }\n    },\n    withExtension: {\n      fn: Factory.withExtension,\n      arity: {\n        3: ['AnyAtRoot', 'String', 'AnyAtRoot']\n      }\n    },\n    withProperty: {\n      fn: Factory.withProperty,\n      arity: {\n        3: ['AnyAtRoot', 'String', 'AnyAtRoot']\n      }\n    }\n  };\n\n  // Create functions to create primitive types and add these functions to the\n  // invocationTable.\n  static {\n    [\n      {\n        type: 'string',\n        getValue: function (v) {\n          if (typeof v  === 'string' && /^[\\s\\S]+$/.test(v)) {\n            return String(v);\n          }\n          throw new Error(`\"${v}\" is not a string.` );\n        }\n      },\n      {\n        type: 'integer',\n        getValue: (v) => {\n          const n = Number(v);\n          if (Number.isInteger(n)) {\n            return n;\n          }\n          throw new Error(`\"${v}\" is not an integer.` );\n        }\n      },\n      {\n        type: 'unsignedInt',\n        getValue: (v) => {\n          const n = Number(v);\n          if (Number.isInteger(n) && n >= 0) {\n            return n;\n          }\n          throw new Error(`\"${v}\" is not an unsignedInt.` );\n        }\n      },\n      {\n        type: 'positiveInt',\n        getValue: (v) => {\n          const n = Number(v);\n          if (Number.isInteger(n) && n > 0) {\n            return n;\n          }\n          throw new Error(`\"${v}\" is not a positiveInt.` );\n        }\n      },\n      {\n        type: 'integer64',\n        getValue: (v) => {\n          const n = Number(v);\n          if (Number.isInteger(n)) {\n            return n;\n          }\n          throw new Error(`\"${v}\" is not an integer.` );\n        }\n      },\n      {\n        type: 'markdown',\n        getValue(v) {\n          if (typeof v  === 'string' && /^[\\s\\S]+$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a markdown.` );\n        }\n      },\n      {\n        type: 'url',\n        getValue(v) {\n          if (typeof v  === 'string' && /^\\S*$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a url.` );\n        }\n      },\n      {\n        type: 'uri',\n        getValue(v) {\n          if (typeof v  === 'string' && /^\\S*$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a uri.` );\n        }\n      },\n      {\n        type: 'instant',\n        getValue(v) {\n          if (typeof v  === 'string' && instantRE.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not an instant.` );\n        }\n      },\n      {\n        type: 'time',\n        getValue(v) {\n          if (typeof v  === 'string' && timeRE.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a time.` );\n        }\n      },\n      {\n        type: 'date',\n        getValue(v) {\n          if (typeof v  === 'string' && dateRE.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a date.` );\n        }\n      },\n      {\n        type: 'dateTime',\n        getValue(v) {\n          if (typeof v  === 'string' && dateTimeRE.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a dateTime.` );\n        }\n      },\n      {\n        type: 'base64Binary',\n        getValue(v) {\n          if (typeof v  === 'string' &&\n            /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/\n              .test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a base64Binary.` );\n        }\n      },\n      {\n        type: 'decimal',\n        getValue(v) {\n          const n = Number(v);\n          if (Number.isNaN(n)) {\n            throw new Error(`\"${v}\" is not an decimal.` );\n          }\n          return n;\n        }\n      },\n      {\n        type: 'boolean',\n        getValue(v) {\n          if (v === true || v === 'true') {\n            return true;\n          } else if (v === false || v === 'false') {\n            return false;\n          } else {\n            throw new Error(`\"${v}\" is not a boolean.` );\n          }\n        }\n      },\n      {\n        type: 'code',\n        getValue(v) {\n          if (typeof v  === 'string' && /^\\S+( \\S+)*$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not a code.` );\n        }\n      },\n      {\n        type: 'id',\n        getValue(v) {\n          if (typeof v  === 'string' && /^[A-Za-z0-9\\-.]{1,64}$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not an id.` );\n        }\n      },\n      {\n        type: 'oid',\n        getValue(v) {\n          if (typeof v  === 'string' && /^urn:oid:[0-2](\\.(0|[1-9][0-9]*))+$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not an oid.` );\n        }\n      },\n      {\n        type: 'uuid',\n        getValue(v) {\n          if (typeof v  === 'string' && /^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not an uuid.` );\n        }\n      },\n      {\n        type: 'canonical',\n        getValue(v) {\n          if (typeof v  === 'string' && /^\\S*$/.test(v)) {\n            return v;\n          }\n          throw new Error(`\"${v}\" is not an canonical.` );\n        }\n      }\n    ].forEach(({type: primitiveType, getValue}) => {\n      /**\n       * Creates an instance of the type with the value and possibly one or more\n       * extensions.\n       * See primitive type descriptions here:\n       * https://hl7.org/fhir/datatypes.html#primitive\n       * @param {Factory[]} self - an array with one element, which is the\n       *  Factory class.\n       * @param {*} valueColl - a collection that should contain a single value\n       *  of a primitive type.\n       * @param {Extension[]} [extensions] - an optional array of Extensions.\n       * @return {ResourceNode} - a new ResourceNode.\n       */\n      Factory[primitiveType] = function (self, valueColl, extensions) {\n        let data;\n        if (valueColl.length > 1) {\n          throw new Error('Unexpected collection ' + JSON.stringify(valueColl) +\n            ` as a value for %factory.${primitiveType}(value, extensions)`);\n        } else if (valueColl.length === 0) {\n          data = null;\n        } else {\n          const v = util.valData(valueColl[0]);\n          if (v == null) {\n            data = null;\n          } if (typeof v !== 'object') {\n            data = getValue(v);\n          } else {\n            throw new Error(`\"${v}\" is not a ${primitiveType}` );\n          }\n        }\n\n        let _data = null;\n        if (extensions?.length > 0) {\n          _data = {\n            extension: extensions.map(e => {\n              const extensionDataType = TypeInfo.fromValue(e);\n              if (TypeInfo.isType(extensionDataType.name, 'Extension')) {\n                return util.valData(e);\n              } else {\n                throw new Error(`Expected \"FHIR.Extension\", got \"${extensionDataType}\"` );\n              }\n            })\n          };\n        }\n\n        return ResourceNode.makeResNode(data, null, primitiveType, _data, primitiveType);\n      };\n\n      Factory.invocationTable[primitiveType] = {\n        fn: Factory[primitiveType],\n        arity: {1: ['AnyAtRoot'], 2: ['AnyAtRoot', 'Any']}\n      };\n    });\n  }\n\n  /**\n   * Creates an extension with the given url and value\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} url - a string value that identifies the extension\n   * @param {*} value - the value of the extension (any valid type for\n   *  extension.value[x]).\n   * @return {ResourceNode}\n   */\n  static Extension(self, url, value) {\n    if (value.length !== 1) {\n      if (value.length > 1) {\n        throw new Error(\"Unexpected collection \" + JSON.stringify(value) +\n          \" as a value for %factory.Extension(url, value)\");\n      }\n\n      if (value.length === 0) {\n        throw new Error(\"Unexpected empty collection \" + JSON.stringify(value) +\n          \" as a value for %factory.Extension(url, value)\");\n      }\n    } else {\n      return ResourceNode.makeResNode(Factory.createExtensionObject(url, value[0]),\n        null, 'Extension', null, 'Extension');\n    }\n  }\n\n  /**\n   * Creates an object to store the extension value.\n   * @param {string} url - a string value that identifies the extension\n   * @param {*} value - the value of the extension (any valid type for\n   *  extension.value[x]).\n   * @return {{[p: string]: *, url}}\n   */\n  static createExtensionObject(url, value) {\n    const valuePropertyName = 'value' +\n      TypeInfo.fromValue(value).name.replace(/^\\w/, c => c.toUpperCase());\n    return {\n      url,\n      [valuePropertyName]: util.valData(value)\n    };\n  }\n\n  /**\n   * Creates an identifier with the given properties.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} system - a string value that goes in Identifier.system.\n   * @param {string} value - a string value that goes in Identifier.value.\n   * @param {string} use - a string value that goes in Identifier.use.\n   * @param {ResourceNode[]} typeColl - a CodeableConcept that goes in\n   *  Identifier.type.\n   * @return {ResourceNode}\n   */\n  static Identifier (self, system, value, use, typeColl) {\n    if (typeColl?.length > 1) {\n      throw new Error(\"Unexpected collection \" + JSON.stringify(typeColl) +\n        \" as a type for %factory.Identifier{system, value, use, type)\");\n    }\n    const data = {};\n    if (util.isSome(system)) {\n      data.system = system;\n    }\n    if (util.isSome(value)) {\n      data.value = value;\n    }\n    if (util.isSome(use)) {\n      data.use = use;\n    }\n    if (util.isSome(typeColl)) {\n      const typeInfo = TypeInfo.fromValue(typeColl[0]);\n      if (!TypeInfo.isType(typeInfo.name, 'CodeableConcept')) {\n        throw new Error(`Expected \"FHIR.CodeableConcept\", got \"${typeInfo}\"` );\n      }\n      data.type = typeColl[0];\n    }\n    return ResourceNode.makeResNode(data, null, 'Identifier', null,\n      'Identifier');\n  }\n\n  /**\n   * Create a human name with the given properties.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} family - a string value that goes in HumanName.system.\n   * @param {ResourceNode[]} givenColl - a collection of string values that goes\n   *  in HumanName.given.\n   * @param {string} prefix - a string value that goes in HumanName.prefix.\n   * @param {string} suffix - a string value that goes in HumanName.suffix.\n   * @param {string} text - a string value that goes in HumanName.text.\n   * @param {string} use - a string value that goes in HumanName.use.\n   * @return {ResourceNode}\n   */\n  static HumanName(self, family, givenColl, prefix, suffix, text, use) {\n    const data = {};\n    if (util.isSome(family)) {\n      data.family = family;\n    }\n    if (util.isSome(givenColl)) {\n      data.given = givenColl.map(given => {\n        const v = util.valData(given);\n        if (typeof v === \"string\") {\n          return v;\n        }\n        throw new Error(`Expected string, but got: ${JSON.stringify(v)}`);\n      });\n    }\n    if (util.isSome(prefix)) {\n      data.prefix = prefix;\n    }\n    if (util.isSome(suffix)) {\n      data.suffix = suffix;\n    }\n    if (util.isSome(text)) {\n      data.text = text;\n    }\n    if (util.isSome(use)) {\n      data.use = use;\n    }\n    return ResourceNode.makeResNode(data, null, 'HumanName', null,\n      'HumanName');\n  }\n\n  /**\n   * Creates a ContactPoint.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} system - a string value that goes in ContactPoint.system.\n   * @param {string} value - a string value that goes in ContactPoint.value.\n   * @param {string} use - a string value that goes in ContactPoint.use.\n   * @return {ResourceNode}\n   */\n  static ContactPoint(self, system, value, use) {\n    const data = {};\n    if (util.isSome(system)) {\n      data.system = system;\n    }\n    if (util.isSome(value)) {\n      data.value = value;\n    }\n    if (util.isSome(use)) {\n      data.use = use;\n    }\n    return ResourceNode.makeResNode(data, null, 'ContactPoint', null,\n      'ContactPoint');\n  }\n\n  /**\n   * Creates an Address\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {ResourceNode[]} lineColl - a collection of string values that goes\n   *  in Address.line.\n   * @param {string} city - a string value that goes in Address.city.\n   * @param {string} state - a string value that goes in Address.state.\n   * @param {string} postalCode - a string value that goes in Address.postalCode.\n   * @param {string} country - a string value that goes in Address.country.\n   * @param {string} use - a string value that goes in Address.use.\n   * @param {string} type - a string value that goes in Address.type.\n   * @return {ResourceNode}\n   */\n  static Address(self, lineColl, city, state, postalCode, country, use, type) {\n    const data = {};\n    if (util.isSome(lineColl)) {\n      data.line = lineColl.map(line => {\n        const v = util.valData(line);\n        if (typeof v === \"string\") {\n          return v;\n        }\n        throw new Error(`Expected string, but got: ${JSON.stringify(v)}`);\n      });\n    }\n    if (util.isSome(city)) {\n      data.city = city;\n    }\n    if (util.isSome(state)) {\n      data.state = state;\n    }\n    if (util.isSome(postalCode)) {\n      data.postalCode = postalCode;\n    }\n    if (util.isSome(country)) {\n      data.country = country;\n    }\n    if (util.isSome(use)) {\n      data.use = use;\n    }\n    if (util.isSome(type)) {\n      data.type = type;\n    }\n    return ResourceNode.makeResNode(data, null, 'Address', null,\n      'Address');\n  }\n\n  /**\n   * Creates a Quantity.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} system - a string value that goes in Quantity.system.\n   * @param {string} code - a string value that goes in Quantity.code.\n   * @param {string} value - a string or decimal value that goes in\n   *  Quantity.value.\n   * @param {string} unit - a string value that goes in Quantity.unit.\n   * @return {ResourceNode}\n   */\n  static Quantity(self, system, code, value, unit) {\n    const data = {};\n    if (util.isSome(system)) {\n      data.system = system;\n    }\n    if (util.isSome(code)) {\n      data.code = code;\n    }\n    if (util.isSome(value)) {\n      data.value = Number(value);\n    }\n    if (util.isSome(unit)) {\n      data.unit = unit;\n    }\n    return ResourceNode.makeResNode(data, null, 'Quantity', null,\n      'Quantity');\n  }\n\n  /**\n   * Creates a Coding.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {string} system - a string value that goes in Coding.system.\n   * @param {string} code - a string value that goes in Coding.code.\n   * @param {string} display - a string value that goes in Coding.display.\n   * @param {string} version - a string value that goes in Coding.version.\n   * @return {ResourceNode}\n   */\n  static Coding(self, system, code, display, version) {\n    const data = {};\n    if (util.isSome(system)) {\n      data.system = system;\n    }\n    if (util.isSome(code)) {\n      data.code = code;\n    }\n    if (util.isSome(display)) {\n      data.display = display;\n    }\n    if (util.isSome(version)) {\n      data.version = version;\n    }\n    return ResourceNode.makeResNode(data, null, 'Coding', null,\n      'Coding');\n  }\n\n  /**\n   * Creates a CodeableConcept.\n   * @param {Factory[]} self - an array with one element, which is the Factory\n   *  class.\n   * @param {ResourceNode[]} valueColl - a collection of Coding that goes in\n   *  CodeableConcept.coding.\n   * @param {string} text - a string value that goes in CodeableConcept.text.\n   * @return {ResourceNode}\n   */\n  static CodeableConcept(self, valueColl, text) {\n    const data = valueColl?.length > 0 ?\n      {\n        coding: valueColl.map(coding => {\n          if (coding instanceof ResourceNode &&\n            coding.getTypeInfo().name === 'Coding') {\n            return util.valData(coding);\n          }\n          throw new Error(\"Unexpected value \" + JSON.stringify(coding) +\n            \"; expected value of type Coding\");\n        })\n      }\n      : {};\n\n    if (util.isSome(text)) {\n      data.text = text;\n    }\n\n    return ResourceNode.makeResNode(data, null, 'CodeableConcept', null,\n      'CodeableConcept');\n  }\n\n  /**\n   * Create an instance of the named type.\n   * @param {Factory[]} self - an array with one element that refers to\n   *  the current Factory instance.\n   * @param {TypeInfo} typeInfo - a value that is the type to create.\n   * @return {ResourceNode}\n   */\n  static create(self, typeInfo) {\n    if (typeInfo.namespace === TypeInfo.System) {\n      throw new Error('%factory.create(type) doesn\\'t support system types.');\n    }\n    return ResourceNode.makeResNode(null, null, typeInfo.name, null,\n      typeInfo.name);\n  }\n\n  /**\n   * Add an extension, and return the new type.\n   * @param {Factory[]} self - an array with one element that refers to\n   *  the current Factory instance.\n   * @param {ResourceNode[]} instanceColl - a collection that should contain the\n   *  instance to which the extension is to be added.\n   * @param {string} url - a string value that goes in Extension.url.\n   *  specification this could also be an actual ValueSet, but I don't want to\n   *  complicate this example.\n   * @param {ResourceNode[]} value - the value of the extension.\n   * @return {ResourceNode|[]}\n   */\n  static withExtension(self, instanceColl, url, value) {\n    if (instanceColl.length > 1 ) {\n      throw  new Error(\"Unexpected collection \" + JSON.stringify(instanceColl) +\n        \" as an instance for %factory.withExtension(instance, url, value)\");\n    }\n\n    if (value.length !== 1) {\n      if (value.length > 1) {\n        throw new Error(\"Unexpected collection \" + JSON.stringify(value) +\n          \" as a value for %factory.withExtension(instance, url, value)\");\n      }\n\n      if (value.length === 0) {\n        throw new Error(\"Unexpected empty collection \" + JSON.stringify(value) +\n          \" as a value for %factory.withExtension(instance, url, value)\");\n      }\n    }\n\n    if (instanceColl.length === 0) {\n      return [];\n    }\n\n    const instance = instanceColl[0];\n\n    if (instance instanceof ResourceNode) {\n      let data = instance.data;\n      let _data = instance._data;\n      if (TypeInfo.isPrimitive(instance.getTypeInfo())) {\n        _data = {\n          ...(instance._data || {}),\n          extension: [\n            ...(instance._data?.extension || []),\n            Factory.createExtensionObject(url, value[0])\n          ]\n        };\n      } else {\n        data = {\n          ...(instance.data || {}),\n          extension: [\n            ...(instance.data?.extension || []),\n            Factory.createExtensionObject(url, value[0])\n          ]\n        };\n      }\n      return  ResourceNode.makeResNode(data, null, instance.path, _data,\n        instance.fhirNodeDataType);\n    } else {\n      throw new Error('Expected a ResourceNode.');\n    }\n  }\n\n  /**\n   * Set a property value, and return the new type.\n   * @param {Factory[]} self - an array with one element that refers to\n   *  the current Factory instance.\n   * @param {ResourceNode[]} instanceColl - a collection that should contain the\n   *  instance to set the property on.\n   * @param {string} name - a string value that identifies the property to set.\n   * @param {string} value - the value of the property\n   * @return {ResourceNode|*[]}\n   */\n  static withProperty(self, instanceColl, name, value) {\n    if (instanceColl.length > 1 ) {\n      throw  new Error(\"Unexpected collection \" + JSON.stringify(instanceColl) +\n        \" as an instance for %factory.withProperty(instance, name, value)\");\n    }\n\n    if (value.length !== 1) {\n      if (value.length > 1) {\n        throw new Error(\"Unexpected collection \" + JSON.stringify(value) +\n          \" as a value for %factory.withProperty(instance, name, value)\");\n      }\n\n      if (value.length === 0) {\n        throw new Error(\"Unexpected empty collection \" + JSON.stringify(value) +\n          \" as a value for %factory.withProperty(instance, name, value)\");\n      }\n    }\n\n    if (instanceColl.length === 0) {\n      return [];\n    }\n\n    const instance = instanceColl[0];\n\n    if (instance instanceof ResourceNode) {\n      let data = instance.data;\n      let _data = instance._data;\n      if (TypeInfo.isPrimitive(instance.getTypeInfo())) {\n        _data = {\n          ...(instance._data || {}),\n          [name]: util.valData(value[0]),\n          ...(value[0]?._data ? { ['_' + name]: value[0]._data } : {})\n        };\n      } else {\n        data = {\n          ...(instance.data || {}),\n          [name]: util.valData(value[0]),\n          ...(value[0]?._data ? { ['_' + name]: value[0]._data } : {})\n        };\n      }\n      return  ResourceNode.makeResNode(data, null, instance.path, _data,\n        instance.fhirNodeDataType);\n    } else {\n      throw new Error('Expected a ResourceNode.');\n    }\n  }\n\n}\n\nmodule.exports = Factory;\n","// This is fhirpath interpreter\n// everything starts at evaluate function,\n// which is passed  fhirpath AST and resource.\n//\n// We reduce/eval recursively each node in AST\n// passing the context and current data\n//\n// each AST node has eval function, which should be registered in evalTable\n// and named after node type\n// if node needs to eval father it's children it has to call `doEval` function\n//\n// most of nodes do function or operator invocation at the end\n//\n// For invocation's and operator's there is one lookup table -\n// invocationTable and two helper functions doInvoke and infixInvoke for\n// operators\n// 1. operator or function is looked up in table\n// 2. using signature (in  .arity property) unpack parameters\n// 3. check params types\n// 4. do call function\n// 5. wrap result by util.arraify\n//\n// if function is nullable\n// and one of parameters is empty/null - function will not be invoked and empty\n// result returned\n//\n// Not solved problem is overloading functions by types - for example + operator defined\n// for strings and numbers\n// we can make dispatching params type dependent - let see\n\nconst {version} = require('../package.json');\nconst parser = require(\"./parser\");\nconst util = require(\"./utilities\");\nrequire(\"./polyfill\");\nconst constants = require('./constants');\n\nlet engine    = {}; // the object with all FHIRPath functions and operations\nlet existence = require(\"./existence\");\nlet filtering = require(\"./filtering\");\nlet aggregate = require(\"./aggregate\");\nlet supplements = require(\"./sdc-ig-supplements\");\nlet combining = require(\"./combining\");\nlet misc      = require(\"./misc\");\nlet equality  = require(\"./equality\");\nlet collections  = require(\"./collections\");\nlet math      = require(\"./math\");\nlet strings   = require(\"./strings\");\nlet navigation= require(\"./navigation\");\nlet datetime  = require(\"./datetime\");\nlet additional  = require(\"./additional\");\nlet logic  = require(\"./logic\");\nconst types = require(\"./types\");\nconst {\n  FP_Date, FP_DateTime, FP_Time, FP_Quantity,\n  FP_Type, ResourceNode, TypeInfo\n} = types;\nlet makeResNode = ResourceNode.makeResNode;\nconst Terminologies = require('./terminologies');\nconst Factory = require('./factory');\n\n// * fn: handler\n// * arity: is index map with type signature\n//   if type is in array (like [Boolean]) - this means\n//   function accepts value of this type or empty value {}\n// * nullable:  means propagate empty result, i.e. instead\n//   calling function if one of params is  empty return empty\n\nengine.invocationTable = {\n  memberOf:     {fn: additional.memberOf, arity: { 1: ['String']} },\n  empty:        {fn: existence.emptyFn},\n  not:          {fn: existence.notFn},\n  exists:       {fn: existence.existsMacro, arity: {0: [], 1: [\"Expr\"]}},\n  all:          {fn: existence.allMacro, arity: {1: [\"Expr\"]}},\n  allTrue:      {fn: existence.allTrueFn},\n  anyTrue:      {fn: existence.anyTrueFn},\n  allFalse:     {fn: existence.allFalseFn},\n  anyFalse:     {fn: existence.anyFalseFn},\n  subsetOf:     {fn: existence.subsetOfFn, arity: {1: [\"AnyAtRoot\"]}},\n  supersetOf:   {fn: existence.supersetOfFn, arity: {1: [\"AnyAtRoot\"]}},\n  isDistinct:   {fn: existence.isDistinctFn},\n  distinct:     {fn: filtering.distinctFn},\n  count:        {fn: aggregate.countFn},\n  where:        {fn: filtering.whereMacro, arity: {1: [\"Expr\"]}},\n  extension:    {fn: filtering.extension, arity: {1: [\"String\"]}},\n  select:       {fn: filtering.selectMacro, arity: {1: [\"Expr\"]}},\n  aggregate:    {fn: aggregate.aggregateMacro, arity: {1: [\"Expr\"], 2: [\"Expr\", \"AnyAtRoot\"]}},\n  sum:          {fn: aggregate.sumFn},\n  min:          {fn: aggregate.minFn},\n  max:          {fn: aggregate.maxFn},\n  avg:          {fn: aggregate.avgFn},\n  weight:       {fn: supplements.weight},\n  ordinal:      {fn: supplements.weight},\n  single:       {fn: filtering.singleFn},\n  first:        {fn: filtering.firstFn},\n  last:         {fn: filtering.lastFn},\n  type:         {fn: types.typeFn, arity: {0: []}},\n  ofType:       {fn: filtering.ofTypeFn, arity: {1: [\"TypeSpecifier\"]}},\n  is:           {fn: types.isFn, arity: {1: [\"TypeSpecifier\"]}},\n  as:           {fn: types.asFn, arity: {1: [\"TypeSpecifier\"]}},\n  tail:         {fn: filtering.tailFn},\n  take:         {fn: filtering.takeFn, arity: {1: [\"Integer\"]}},\n  skip:         {fn: filtering.skipFn, arity: {1: [\"Integer\"]}},\n  combine:      {fn: combining.combineFn, arity: {1: [\"AnyAtRoot\"]}},\n  union:        {fn: combining.union,   arity: {1: [\"AnyAtRoot\"]}},\n  intersect:    {fn: combining.intersect,   arity: {1: [\"AnyAtRoot\"]}},\n  exclude:      {fn: combining.exclude,   arity: {1: [\"AnyAtRoot\"]}},\n  iif:          {fn: misc.iifMacro,    arity: {2: [\"Expr\", \"Expr\"], 3: [\"Expr\", \"Expr\", \"Expr\"]}},\n  trace:        {fn: misc.traceFn,     arity: {1: [\"String\"], 2: [\"String\", \"Expr\"]}},\n  defineVariable: {fn: misc.defineVariable,     arity: {1: [\"String\"], 2: [\"String\", \"Expr\"]}},\n  toInteger:    {fn: misc.toInteger},\n  toDecimal:    {fn: misc.toDecimal},\n  toString:     {fn: misc.toString},\n  toDate:       {fn: misc.toDate},\n  toDateTime:   {fn: misc.toDateTime},\n  toTime:       {fn: misc.toTime},\n  toBoolean:    {fn: misc.toBoolean},\n  toQuantity:   {fn: misc.toQuantity, arity: {0: [], 1: [\"String\"]}},\n  hasValue:     {fn: misc.hasValueFn},\n  getValue:     {fn: misc.getValueFn},\n  convertsToBoolean:    {fn: misc.createConvertsToFn(misc.toBoolean, 'boolean')},\n  convertsToInteger:    {fn: misc.createConvertsToFn(misc.toInteger, 'number')},\n  convertsToDecimal:    {fn: misc.createConvertsToFn(misc.toDecimal, 'number')},\n  convertsToString:     {fn: misc.createConvertsToFn(misc.toString, 'string')},\n  convertsToDate:       {fn: misc.createConvertsToFn(misc.toDate, FP_Date)},\n  convertsToDateTime:   {fn: misc.createConvertsToFn(misc.toDateTime, FP_DateTime)},\n  convertsToTime:       {fn: misc.createConvertsToFn(misc.toTime, FP_Time)},\n  convertsToQuantity:   {fn: misc.createConvertsToFn(misc.toQuantity, FP_Quantity)},\n\n  indexOf:        {fn: strings.indexOf,          arity: {1: [\"String\"]}},\n  substring:      {fn: strings.substring,        arity: {1: [\"Integer\"], 2: [\"Integer\",\"Integer\"]}},\n  startsWith:     {fn: strings.startsWith,       arity: {1: [\"String\"]}},\n  endsWith:       {fn: strings.endsWith,         arity: {1: [\"String\"]}},\n  contains:       {fn: strings.containsFn,       arity: {1: [\"String\"]}},\n  upper:          {fn: strings.upper},\n  lower:          {fn: strings.lower},\n  replace:        {fn: strings.replace,          arity: {2: [\"String\", \"String\"]}},\n  matches:        {fn: strings.matches,          arity: {1: [\"String\"]}},\n  replaceMatches: {fn: strings.replaceMatches,   arity: {2: [\"String\", \"String\"]}},\n  length:         {fn: strings.length },\n  toChars:        {fn: strings.toChars },\n  join:           {fn: strings.joinFn,           arity: {0: [], 1: [\"String\"]}},\n  split:          {fn: strings.splitFn,          arity: {1: [\"String\"]}},\n  trim:           {fn: strings.trimFn},\n\n  encode:         {fn: strings.encodeFn,         arity: {1: [\"String\"]}},\n  decode:         {fn: strings.decodeFn,         arity: {1: [\"String\"]}},\n\n  abs:            {fn: math.abs},\n  ceiling:        {fn: math.ceiling},\n  exp:            {fn: math.exp},\n  floor:          {fn: math.floor},\n  ln:             {fn: math.ln},\n  log:            {fn: math.log, arity:  {1: [\"Number\"]}, nullable: true},\n  power:          {fn: math.power, arity:  {1: [\"Number\"]}, nullable: true},\n  round:          {fn: math.round, arity:  {0: [], 1: [\"Number\"]}},\n  sqrt:           {fn: math.sqrt},\n  truncate:       {fn: math.truncate},\n\n  now:            {fn: datetime.now },\n  today:          {fn: datetime.today },\n  timeOfDay:      {fn: datetime.timeOfDay },\n\n  repeat:          {fn: filtering.repeatMacro, arity: {1: [\"Expr\"]}},\n  children:        {fn: navigation.children },\n  descendants:     {fn: navigation.descendants },\n\n  \"|\":          {fn: combining.union,   arity: {2: [\"Any\", \"Any\"]}},\n  \"=\":          {fn: equality.equal,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"!=\":         {fn: equality.unequal,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"~\":          {fn: equality.equival,   arity: {2: [\"Any\", \"Any\"]}},\n  \"!~\":         {fn: equality.unequival,   arity: {2: [\"Any\", \"Any\"]}},\n  \"<\":          {fn: equality.lt,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \">\":          {fn: equality.gt,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"<=\":         {fn: equality.lte,  arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \">=\":         {fn: equality.gte,  arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"containsOp\": {fn: collections.contains,   arity: {2: [\"Any\", \"Any\"]}},\n  \"inOp\":       {fn: collections.in,  arity: {2: [\"Any\", \"Any\"]}},\n  \"isOp\":       {fn: types.isFn,  arity: {2: [\"Any\", \"TypeSpecifier\"]}},\n  \"asOp\":       {fn: types.asFn,  arity: {2: [\"Any\", \"TypeSpecifier\"]}},\n  \"&\":          {fn: math.amp,     arity:  {2: [\"String\", \"String\"]}},\n  \"+\":          {fn: math.plus,    arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"-\":          {fn: math.minus,   arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"*\":          {fn: math.mul,     arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"/\":          {fn: math.div,     arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"mod\":        {fn: math.mod,     arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n  \"div\":        {fn: math.intdiv,  arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n\n  \"or\":        {fn: logic.orOp,  arity:       {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"and\":       {fn: logic.andOp,  arity:      {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"xor\":       {fn: logic.xorOp,  arity:      {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"implies\":   {fn: logic.impliesOp,  arity:  {2: [[\"Boolean\"], [\"Boolean\"]]}},\n};\n\nengine.InvocationExpression = function(ctx, parentData, node) {\n  return node.children.reduce(function(acc, ch) {\n    return engine.doEval(ctx, acc, ch);\n  }, parentData);\n};\n\nengine.TermExpression = function(ctx, parentData, node) {\n  if (parentData) {\n    parentData = parentData.map((x) => {\n      if (x instanceof Object && x.resourceType) {\n        return makeResNode(x, null, x.resourceType, null, x.resourceType);\n      }\n      return x;\n    });\n  }\n\n  return engine.doEval(ctx,parentData, node.children[0]);\n};\n\nengine.PolarityExpression = function(ctx, parentData, node) {\n  var sign = node.terminalNodeText[0]; // either - or + per grammar\n  var rtn = engine.doEval(ctx,parentData, node.children[0]);\n  if (rtn.length !== 1) {  // not yet in spec, but per Bryn Rhodes\n    throw new Error('Unary ' + sign +\n     ' can only be applied to an individual number or Quantity.');\n  }\n  if (rtn[0] instanceof FP_Quantity) {\n    if (sign === '-') {\n      rtn[0] = new FP_Quantity(-rtn[0].value, rtn[0].unit);\n    }\n  } else if (typeof rtn[0] === 'number' && !isNaN(rtn[0])) {\n    if (sign === '-') {\n      rtn[0] = -rtn[0];\n    }\n  } else {\n    throw new Error('Unary ' + sign + ' can only be applied to a number or Quantity.');\n  }\n\n  return rtn;\n};\n\nengine.TypeSpecifier = function(ctx, parentData, node) {\n  let namespace, name;\n  const identifiers = node.text.split('.').map(i => i.replace(/(^`|`$)/g, \"\"));\n  switch (identifiers.length) {\n    case 2:\n      [namespace, name] = identifiers;\n      break;\n    case 1:\n      [name] = identifiers;\n      break;\n    default:\n      throw new Error(\"Expected TypeSpecifier node, got \" + JSON.stringify(node));\n  }\n\n  const typeInfo =  new TypeInfo({ namespace, name });\n  if (!typeInfo.isValid()) {\n    throw new Error('\"' + typeInfo + '\" cannot be resolved to a valid type identifier');\n  }\n  return typeInfo;\n};\n\nengine.ExternalConstantTerm = function(ctx, parentData, node) {\n  let varName;\n  const extConstant = node.children[0];\n  // externalConstant(variable name) is defined in the grammar as:\n  // '%' ( identifier | STRING )\n  if (extConstant.terminalNodeText.length === 2) {\n    // if the variable name is a STRING\n    varName = getStringLiteralVal(extConstant.terminalNodeText[1]);\n  } else {\n    // otherwise, it is an identifier\n    varName = getIdentifierVal(extConstant.children[0].text);\n  }\n\n  let value;\n  // Check the user-defined environment variables first as the user can override\n  // the \"context\" variable like we do in unit tests. In this case, the user\n  // environment variable can replace the system environment variable in \"processedVars\".\n  // If the user-defined environment variable has been processed, we don't need to process it again.\n  if (varName in ctx.vars && !ctx.processedUserVarNames.has(varName)) {\n    // Restore the ResourceNodes for the top-level objects of the environment\n    // variables. The nested objects will be converted to ResourceNodes\n    // in the MemberInvocation method.\n    value = ctx.vars[varName];\n    if (Array.isArray(value)) {\n      value = value.map(\n        i => i?.__path__\n          ? makeResNode(i, i.__path__.parentResNode, i.__path__.path, null,\n            i.__path__.fhirNodeDataType)\n          : i?.resourceType\n            ? makeResNode(i, null, null, null)\n            : i );\n    } else {\n      value = value?.__path__\n        ? makeResNode(value, value.__path__.parentResNode, value.__path__.path, null,\n          value.__path__.fhirNodeDataType)\n        : value?.resourceType\n          ? makeResNode(value, null, null, null)\n          : value;\n    }\n    ctx.processedVars[varName] = value;\n    ctx.processedUserVarNames.add(varName);\n  } else if (varName in ctx.processedVars) {\n    // \"processedVars\" are variables with ready-to-use values that have already\n    // been converted to ResourceNodes if necessary.\n    value = ctx.processedVars[varName];\n  } else  if (ctx.definedVars && varName in ctx.definedVars) {\n    // \"definedVars\" are variables defined with the \"defineVariable\" function.\n    value = ctx.definedVars[varName];\n  } else {\n    throw new Error(\n      \"Attempting to access an undefined environment variable: \" + varName\n    );\n  }\n  // For convenience, we all variable values to be passed in without their array\n  // wrapper.  However, when evaluating, we need to put the array back in.\n  return value === undefined || value === null\n    ? []\n    : value instanceof Array ? value : [value];\n};\n\nengine.LiteralTerm = function(ctx, parentData, node) {\n  var term = node.children[0];\n  if(term){\n    return engine.doEval(ctx, parentData, term);\n  } else {\n    return [node.text];\n  }\n};\n\nengine.StringLiteral = function(ctx, parentData, node) {\n  return [getStringLiteralVal(node.text)];\n};\n\n/**\n * Removes the beginning and ending single-quotes and replaces string escape\n * sequences.\n * @param {string} str - string literal\n * @return {string}\n */\nfunction getStringLiteralVal(str) {\n  return str.replace(/(^'|'$)/g, \"\")\n    .replace(/\\\\(u\\d{4}|.)/g, function(match, submatch) {\n      switch(match) {\n        case '\\\\r':\n          return '\\r';\n        case '\\\\n':\n          return \"\\n\";\n        case '\\\\t':\n          return '\\t';\n        case '\\\\f':\n          return '\\f';\n        default:\n          if (submatch.length > 1)\n            return String.fromCharCode('0x'+submatch.slice(1));\n          else\n            return submatch;\n      }\n    });\n}\n\nengine.BooleanLiteral = function(ctx, parentData, node) {\n  if(node.text  === \"true\") {\n    return [true];\n  } else {\n    return [false];\n  }\n};\n\nengine.QuantityLiteral = function(ctx, parentData, node) {\n  var valueNode = node.children[0];\n  var value = Number(valueNode.terminalNodeText[0]);\n  var unitNode = valueNode.children[0];\n  var unit = unitNode.terminalNodeText[0];\n  // Sometimes the unit is in a child node of the child\n  if (!unit && unitNode.children)\n    unit = unitNode.children[0].terminalNodeText[0];\n\n  return [new FP_Quantity(value, unit)];\n};\n\nengine.DateTimeLiteral = function(ctx, parentData, node) {\n  var dateStr = node.text.slice(1); // Remove the @\n  return [new FP_DateTime(dateStr)];\n};\n\nengine.TimeLiteral = function(ctx, parentData, node) {\n  var timeStr = node.text.slice(1); // Remove the @\n  return [new FP_Time(timeStr)];\n};\n\nengine.NumberLiteral = function(ctx, parentData, node) {\n  return [Number(node.text)];\n};\n\nengine.Identifier = function(ctx, parentData, node) {\n  return [getIdentifierVal(node.text)];\n};\n\n/**\n * Removes the beginning and ending back-quotes.\n * @param {string} str - identifier string\n * @return {string}\n */\nfunction getIdentifierVal(str) {\n  return str.replace(/(^`|`$)/g, \"\");\n}\n\nengine.InvocationTerm = function(ctx, parentData, node) {\n  return engine.doEval(ctx,parentData, node.children[0]);\n};\n\n\nengine.MemberInvocation = function(ctx, parentData, node ) {\n  const key = engine.doEval(ctx, parentData, node.children[0])[0];\n  const model = ctx.model;\n\n  if (parentData) {\n    return parentData.reduce(function(acc, res) {\n      res = makeResNode(res, null, res.__path__?.path, null,\n        res.__path__?.fhirNodeDataType);\n      if (res.data?.resourceType === key) {\n        acc.push(res);\n      } else {\n        util.pushFn(acc, util.makeChildResNodes(res, key, model));\n      }\n      return acc;\n    }, []);\n  } else {\n    return [];\n  }\n};\n\nengine.IndexerExpression = function(ctx, parentData, node) {\n  const coll_node = node.children[0];\n  const idx_node = node.children[1];\n  var coll = engine.doEval(ctx, parentData, coll_node);\n  var idx = engine.doEval(ctx, parentData, idx_node);\n\n  if(util.isEmpty(idx)) {\n    return [];\n  }\n\n  var idxNum = parseInt(idx[0]);\n  if(coll && util.isSome(idxNum) && coll.length>idxNum && idxNum>=0) {\n    return [coll[idxNum]];\n  } else {\n    return [];\n  }\n};\n\nengine.Functn = function(ctx, parentData, node) {\n  return node.children.map(function(x) {\n    return engine.doEval(ctx, parentData, x);\n  });\n};\n\nengine.realizeParams = function(ctx, parentData, args) {\n  if(args && args[0] && args[0].children) {\n    return args[0].children.map(function(x) {\n      return engine.doEval(ctx, parentData, x);\n    });\n  } else {\n    return [];\n  }\n};\n\nfunction makeParam(ctx, parentData, type, param) {\n  if(type === \"Expr\"){\n    return function(data) {\n      const $this = util.arraify(data);\n      let ctxExpr = { ...ctx, $this };\n      if (ctx.definedVars) {\n        // Each parameter subexpression needs its own set of defined variables\n        // (cloned from the parent context). This way, the changes to the variables\n        // are isolated in the subexpression.\n        ctxExpr.definedVars = {...ctx.definedVars};\n      }\n      return engine.doEval(ctxExpr, $this, param);\n    };\n  }\n  if(type === \"AnyAtRoot\"){\n    const $this = ctx.$this || ctx.dataRoot;\n    let ctxExpr = { ...ctx, $this};\n    if (ctx.definedVars) {\n      // Each parameter subexpression needs its own set of defined variables\n      // (cloned from the parent context). This way, the changes to the variables\n      // are isolated in the subexpression.\n      ctxExpr.definedVars = {...ctx.definedVars};\n    }\n    return engine.doEval(ctxExpr, $this, param);\n  }\n  if(type === \"Identifier\"){\n    if(param.type === \"TermExpression\") {\n      return param.text;\n    } else {\n      throw new Error(\"Expected identifier node, got \" + JSON.stringify(param));\n    }\n  }\n\n  if(type === \"TypeSpecifier\") {\n    return engine.TypeSpecifier(ctx, parentData, param);\n  }\n\n  let res;\n  if(type === 'AnySingletonAtRoot'){\n    const $this = ctx.$this || ctx.dataRoot;\n    let ctxExpr = { ...ctx, $this};\n    if (ctx.definedVars) {\n      // Each parameter subexpression needs its own set of defined variables\n      // (cloned from the parent context). This way, the changes to the variables\n      // are isolated in the subexpression.\n      ctxExpr.definedVars = {...ctx.definedVars};\n    }\n    res = engine.doEval(ctxExpr, $this, param);\n  } else {\n    let ctxExpr = {...ctx};\n    if (ctx.definedVars) {\n      // Each parameter subexpression needs its own set of defined variables\n      // (cloned from the parent context). This way, the changes to the variables\n      // are isolated in the subexpression.\n      ctxExpr.definedVars = {...ctx.definedVars};\n    }\n    res = engine.doEval(ctxExpr, parentData, param);\n    if (type === \"Any\") {\n      return res;\n    }\n    if (Array.isArray(type)) {\n      if (res.length === 0) {\n        return [];\n      } else {\n        type = type[0];\n      }\n    }\n  }\n\n  return res instanceof Promise ?\n    res.then(r => misc.singleton(r, type)) :\n    misc.singleton(res, type);\n}\n\nfunction doInvoke(ctx, fnName, data, rawParams){\n  var invoc =\n    ctx.userInvocationTable\n    && Object.prototype.hasOwnProperty.call(ctx.userInvocationTable, fnName)\n    && ctx.userInvocationTable?.[fnName]\n    || engine.invocationTable[fnName]\n    || data.length === 1 && data[0]?.invocationTable[fnName];\n  var res;\n  if(invoc) {\n    if(!invoc.arity){\n      if(!rawParams){\n        res = invoc.fn.call(ctx, data);\n        return util.resolveAndArraify(res);\n      } else {\n        throw new Error(fnName + \" expects no params\");\n      }\n    } else {\n      var paramsNumber = rawParams ? rawParams.length : 0;\n      var argTypes = invoc.arity[paramsNumber];\n      if(argTypes){\n        var params = [];\n        for(var i = 0; i < paramsNumber; i++){\n          var tp = argTypes[i];\n          var pr = rawParams[i];\n          params.push(makeParam(ctx, data, tp, pr));\n        }\n        params.unshift(data);\n        if(invoc.nullable) {\n          if(params.some(isNullable)){\n            return [];\n          }\n        }\n        if (params.some(p => p instanceof Promise)) {\n          return Promise.all(params).then(p => {\n            res = invoc.fn.apply(ctx, p);\n            return util.resolveAndArraify(res);\n          });\n        }\n        res = invoc.fn.apply(ctx, params);\n        return util.resolveAndArraify(res);\n      } else {\n        console.log(fnName + \" wrong arity: got \" + paramsNumber );\n        return [];\n      }\n    }\n  } else {\n    throw new Error(\"Not implemented: \" + fnName);\n  }\n}\nfunction isNullable(x) {\n  return x === null || x === undefined || util.isEmpty(x);\n}\n\nfunction infixInvoke(ctx, fnName, data, rawParams){\n  var invoc = engine.invocationTable[fnName];\n  if(invoc && invoc.fn) {\n    var paramsNumber = rawParams ? rawParams.length : 0;\n    if(paramsNumber !== 2) { throw new Error(\"Infix invoke should have arity 2\"); }\n    var argTypes = invoc.arity[paramsNumber];\n    if(argTypes){\n      var params = [];\n      for(var i = 0; i < paramsNumber; i++){\n        var tp = argTypes[i];\n        var pr = rawParams[i];\n        params.push(makeParam(ctx, data, tp, pr));\n      }\n      if(invoc.nullable) {\n        if(params.some(isNullable)){\n          return [];\n        }\n      }\n      if (params.some(p => p instanceof Promise)) {\n        return Promise.all(params).then(p => {\n          var res = invoc.fn.apply(ctx, p);\n          return util.arraify(res);\n        });\n      }\n      var res = invoc.fn.apply(ctx, params);\n      return util.arraify(res);\n    } else {\n      console.log(fnName + \" wrong arity: got \" + paramsNumber );\n      return [];\n    }\n  } else {\n    throw new Error(\"Not impl \" + fnName);\n  }\n}\n\nengine.FunctionInvocation = function(ctx, parentData, node) {\n  var args = engine.doEval(ctx, parentData, node.children[0]);\n  const fnName = args[0];\n  args.shift();\n  var rawParams = args && args[0] && args[0].children;\n  return doInvoke(ctx, fnName, parentData, rawParams);\n};\n\nengine.ParamList = function(ctx, parentData, node) {\n  // we do not eval param list because sometimes it should be passed as\n  // lambda/macro (for example in case of where(...)\n  return node;\n};\n\n\nengine.UnionExpression = function(ctx, parentData, node) {\n  return infixInvoke(ctx, '|', parentData, node.children);\n};\n\nengine.ThisInvocation = function(ctx) {\n  return ctx.$this;\n};\n\nengine.TotalInvocation = function(ctx) {\n  return util.arraify(ctx.$total);\n};\n\nengine.IndexInvocation = function(ctx) {\n  return util.arraify(ctx.$index);\n};\n\nengine.OpExpression = function(ctx, parentData, node) {\n  var op = node.terminalNodeText[0];\n  return infixInvoke(ctx, op, parentData, node.children);\n};\n\nengine.AliasOpExpression = function(map){\n  return function(ctx, parentData, node) {\n    var op = node.terminalNodeText[0];\n    var alias = map[op];\n    if(!alias) { throw new Error(\"Do not know how to alias \" + op + \" by \" + JSON.stringify(map)); }\n    return infixInvoke(ctx, alias, parentData, node.children);\n  };\n};\n\nengine.NullLiteral = function() {\n  return [];\n};\n\nengine.ParenthesizedTerm = function(ctx, parentData, node) {\n  return engine.doEval(ctx, parentData, node.children[0]);\n};\n\n\nengine.evalTable = { // not every evaluator is listed if they are defined on engine\n  BooleanLiteral: engine.BooleanLiteral,\n  EqualityExpression: engine.OpExpression,\n  FunctionInvocation: engine.FunctionInvocation,\n  Functn: engine.Functn,\n  Identifier: engine.Identifier,\n  IndexerExpression: engine.IndexerExpression,\n  InequalityExpression: engine.OpExpression,\n  InvocationExpression: engine.InvocationExpression,\n  AdditiveExpression: engine.OpExpression,\n  MultiplicativeExpression: engine.OpExpression,\n  TypeExpression: engine.AliasOpExpression({\"is\": \"isOp\", \"as\": \"asOp\"}),\n  MembershipExpression: engine.AliasOpExpression({\"contains\": \"containsOp\", \"in\": \"inOp\"}),\n  NullLiteral: engine.NullLiteral,\n  EntireExpression: engine.InvocationTerm,\n  InvocationTerm: engine.InvocationTerm,\n  LiteralTerm: engine.LiteralTerm,\n  MemberInvocation: engine.MemberInvocation,\n  NumberLiteral: engine.NumberLiteral,\n  ParamList: engine.ParamList,\n  ParenthesizedTerm: engine.ParenthesizedTerm,\n  StringLiteral: engine.StringLiteral,\n  TermExpression: engine.TermExpression,\n  ThisInvocation: engine.ThisInvocation,\n  TotalInvocation: engine.TotalInvocation,\n  IndexInvocation: engine.IndexInvocation,\n  UnionExpression: engine.UnionExpression,\n  OrExpression: engine.OpExpression,\n  ImpliesExpression: engine.OpExpression,\n  AndExpression: engine.OpExpression,\n  XorExpression: engine.OpExpression\n};\n\n\nengine.doEval = function(ctx, parentData, node) {\n  if (parentData instanceof Promise) {\n    return parentData.then(p => engine.doEvalSync(ctx, p, node));\n  } else {\n    return  engine.doEvalSync(ctx, parentData, node);\n  }\n};\n\nengine.doEvalSync = function(ctx, parentData, node) {\n  const evaluator = engine.evalTable[node.type] || engine[node.type];\n  if(evaluator){\n    return evaluator.call(engine, ctx, parentData, node);\n  } else {\n    throw new Error(\"No \" + node.type + \" evaluator \");\n  }\n};\n\nfunction parse(path) {\n  return parser.parse(path);\n}\n\n\n/**\n *  Applies the given parsed FHIRPath expression to the given resource,\n *  returning the result of doEval.\n * @param {(object|object[])} resource -  FHIR resource, bundle as js object or array of resources\n *  This resource will be modified by this function to add type information.\n * @param {object} parsedPath - a special object created by the parser that describes the structure of a fhirpath expression.\n * @param {object} envVars - a hash of variable name/value pairs.\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n * @param {object} options - additional options:\n * @param {boolean} [options.resolveInternalTypes] - whether values of internal\n *  types should be converted to strings, true by default.\n * @param {function} [options.traceFn] - An optional trace function to call when tracing.\n * @param {object} [options.userInvocationTable] - a user invocation table used\n *  to replace any existing or define new functions.\n * @param {boolean|string} [options.async] - defines how to support asynchronous functions:\n *  false or similar to false, e.g. undefined, null, or 0 (default) - throw an exception;\n *  true or similar to true - return Promise only for asynchronous functions;\n *  \"always\" - return Promise always.\n *  @param {string} [options.terminologyUrl] - a URL that points to a FHIR\n *   RESTful API that is used to create %terminologies that implements\n *   the Terminology Service API.\n */\nfunction applyParsedPath(resource, parsedPath, envVars, model, options) {\n  constants.reset();\n  let dataRoot = util.arraify(resource).map(\n    i => i?.__path__\n      ? makeResNode(i, i.__path__.parentResNode, i.__path__.path, null,\n        i.__path__.fhirNodeDataType)\n      : i?.resourceType\n        ? makeResNode(i, null, null, null)\n        : i);\n  // doEval takes a \"ctx\" object, and we store things in that as we parse, so we\n  // need to put user-provided variable data in a sub-object, ctx.vars.\n  // Set up default standard variables, and allow override from the variables.\n  // However, we'll keep our own copy of dataRoot for internal processing.\n  let ctx = {\n    dataRoot,\n    processedVars: {\n      ucum: 'http://unitsofmeasure.org',\n      context: dataRoot\n    },\n    processedUserVarNames: new Set(),\n    vars: envVars || {},\n    model\n  };\n  if (options.traceFn) {\n    ctx.customTraceFn = options.traceFn;\n  }\n  if (options.userInvocationTable) {\n    ctx.userInvocationTable = options.userInvocationTable;\n  }\n  ctx.defaultScoreExts = [\n    'http://hl7.org/fhir/StructureDefinition/ordinalValue',\n    'http://hl7.org/fhir/StructureDefinition/itemWeight',\n    'http://hl7.org/fhir/StructureDefinition/questionnaire-ordinalValue'\n  ];\n  if (options.async) {\n    ctx.async = options.async;\n  }\n  if (options.terminologyUrl) {\n    ctx.processedVars.terminologies = new Terminologies(options.terminologyUrl);\n  }\n  ctx.processedVars.factory = Factory;\n  const res = engine.doEval(ctx, dataRoot, parsedPath.children[0]);\n  return res instanceof Promise\n    ? res.then(r => prepareEvalResult(r, options))\n    : options.async === 'always'\n      ? Promise.resolve(prepareEvalResult(res, options))\n      : prepareEvalResult(res, options);\n}\n\n/**\n * Prepares the result after evaluating an expression.\n * engine.doEval returns array of \"ResourceNode\" and/or \"FP_Type\" instances.\n * \"ResourceNode\" or \"FP_Type\" instances are not created for sub-items.\n * Resolves any internal \"ResourceNode\" instances to plain objects and if\n * options.resolveInternalTypes is true, resolve any internal \"FP_Type\"\n * instances to strings.\n * @param {Array} result - result of expression evaluation.\n * @param {object} options - additional options (see function \"applyParsedPath\").\n * @return {Array}\n */\nfunction prepareEvalResult(result, options) {\n  return result\n    .reduce((acc, n) => {\n      // Path for the data extracted from the resource.\n      let path;\n      let fhirNodeDataType;\n      let parentResNode;\n      if (n instanceof ResourceNode) {\n        path = n.path;\n        fhirNodeDataType = n.fhirNodeDataType;\n        parentResNode = n.parentResNode;\n      }\n      n = util.valData(n);\n      if (n instanceof FP_Type) {\n        if (options.resolveInternalTypes) {\n          n = n.toString();\n        }\n      }\n      // Exclude nulls\n      if (n != null) {\n        // Add a hidden (non-enumerable) property with the path to the data extracted\n        // from the resource.\n        if (path && typeof n === 'object' && !n.__path__) {\n          Object.defineProperty(n, '__path__', { value: {path, fhirNodeDataType, parentResNode} });\n        }\n        acc.push(n);\n      }\n      return acc;\n    }, []);\n}\n\n/**\n * Resolves any internal \"FP_Type\" instances in a result of FHIRPath expression\n * evaluation to standard JavaScript types.\n * @param {any} val - a result of FHIRPath expression evaluation\n * @returns {any} a new object with resolved values.\n */\nfunction resolveInternalTypes(val) {\n  if (Array.isArray(val)) {\n    for (let i=0, len=val.length; i<len; ++i)\n      val[i] = resolveInternalTypes(val[i]);\n  }\n  else if (val instanceof FP_Type) {\n    val = val.toString();\n  }\n  else if (typeof val === 'object') {\n    for (let k of Object.keys(val))\n      val[k] = resolveInternalTypes(val[k]);\n  }\n  return val;\n}\n\n/**\n *  Evaluates the \"path\" FHIRPath expression on the given resource or part of the resource,\n *  using data from \"context\" for variables mentioned in the \"path\" expression.\n * @param {(object|object[])} fhirData -  FHIR resource, part of a resource (in this case\n *  path.base should be provided), bundle as js object or array of resources.\n *  This object/array will be modified by this function to add type information.\n * @param {string|object} path - string with FHIRPath expression, sample 'Patient.name.given',\n *  or object, if fhirData represents the part of the FHIR resource:\n * @param {string} path.base - base path in resource from which fhirData was extracted\n * @param {string} path.expression - FHIRPath expression relative to path.base\n * @param {object} [envVars] - a hash of variable name/value pairs.\n * @param {object} [model] - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n * @param {object} [options] - additional options:\n * @param {boolean} [options.resolveInternalTypes] - whether values of internal\n *  types should be converted to standard JavaScript types (true by default).\n *  If false is passed, this conversion can be done later by calling\n *  resolveInternalTypes().\n * @param {function} [options.traceFn] - An optional trace function to call when tracing.\n * @param {object} [options.userInvocationTable] - a user invocation table used\n *  to replace any existing or define new functions.\n * @param {boolean|string} [options.async] - defines how to support asynchronous functions:\n *  false or similar to false, e.g. undefined, null, or 0 (default) - throw an exception,\n *  true or similar to true - return Promise, only for asynchronous functions,\n *  \"always\" - return Promise always.\n * @param {string} [options.terminologyUrl] - a URL that points to a FHIR\n *   RESTful API that is used to create %terminologies that implements\n *   the Terminology Service API.\n */\nfunction evaluate(fhirData, path, envVars, model, options) {\n  return compile(path, model, options)(fhirData, envVars);\n}\n\n/**\n *  Returns a function that takes a resource or part of the resource and an\n *  optional context hash (see \"evaluate\"), and returns the result of evaluating\n *  the given FHIRPath expression on that resource.  The advantage of this\n *  function over \"evaluate\" is that if you have multiple resources, the given\n *  FHIRPath expression will only be parsed once.\n * @param {string|object} path - string with FHIRPath expression to be parsed or object:\n * @param {string} path.base - base path in resource from which a part of\n *   the resource was extracted\n * @param {string} path.expression - FHIRPath expression relative to path.base\n * @param {object} [model] - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n * @param {object} [options] - additional options:\n * @param {boolean} [options.resolveInternalTypes] - whether values of internal\n *  types should be converted to strings, true by default.\n * @param {function} [options.traceFn] - An optional trace function to call when tracing.\n * @param {object} [options.userInvocationTable] - a user invocation table used\n *  to replace any existing or define new functions.\n * @param {boolean|string} [options.async] - defines how to support asynchronous functions:\n *  false or similar to false, e.g. undefined, null, or 0 (default) - throw an exception,\n *  true or similar to true - return Promise, only for asynchronous functions,\n *  \"always\" - return Promise always.\n *   @param {string} [options.terminologyUrl] - a URL that points to a FHIR\n *   RESTful API that is used to create %terminologies that implements\n *   the Terminology Service API.\n */\nfunction compile(path, model, options) {\n  options = {\n    resolveInternalTypes: true,\n    ... options\n  };\n\n  const userInvocationTable = options.userInvocationTable;\n  if (userInvocationTable) {\n    options.userInvocationTable = Object.keys(userInvocationTable).reduce(\n      (invocationTable, fnName) => {\n        if (userInvocationTable[fnName].internalStructures) {\n          invocationTable[fnName] = userInvocationTable[fnName];\n        } else {\n          invocationTable[fnName] = {\n            ...userInvocationTable[fnName],\n            fn: (...args) => {\n              return userInvocationTable[fnName].fn.apply(\n                // When we check Array.isArray(arg), we are checking if the\n                // singleton function has been called. An alternative to this is\n                // to check that the type of the argument is Integer, Boolean,\n                // Number, or String.\n                this, args.map(arg => Array.isArray(arg) ? arg.map(item => util.valData(item)) : arg)\n              );\n            }\n          };\n        }\n        return invocationTable;\n      }, {});\n  }\n\n  if (typeof path === 'object') {\n    const node = parse(path.expression);\n    return function (fhirData, envVars) {\n      if (path.base) {\n        let basePath = model.pathsDefinedElsewhere[path.base] || path.base;\n        const baseFhirNodeDataType = model && model.path2Type[basePath];\n        basePath = baseFhirNodeDataType === 'BackboneElement' || baseFhirNodeDataType === 'Element' ? basePath : baseFhirNodeDataType || basePath;\n\n        fhirData = makeResNode(fhirData, null, basePath, null, baseFhirNodeDataType);\n      }\n      // Globally set model before applying parsed FHIRPath expression\n      TypeInfo.model = model;\n      return applyParsedPath(fhirData, node, envVars, model, options);\n    };\n  } else {\n    const node = parse(path);\n    return function (fhirData, envVars) {\n      // Globally set model before applying parsed FHIRPath expression\n      TypeInfo.model = model;\n      return applyParsedPath(fhirData, node, envVars, model, options);\n    };\n  }\n}\n\n/**\n * Returns the type of each element in fhirpathResult array which was obtained\n * from evaluate() with option resolveInternalTypes=false.\n * @param {any} fhirpathResult - a result of FHIRPath expression evaluation.\n * @returns {string[]} an array of types, e.g. ['FHIR.Quantity', 'FHIR.date', 'System.String'].\n */\nfunction typesFn(fhirpathResult) {\n  return util.arraify(fhirpathResult).map(value => {\n    const ti = TypeInfo.fromValue(\n      value?.__path__\n        ? new ResourceNode(value, value.__path__?.parentResNode,\n          value.__path__?.path, null, value.__path__?.fhirNodeDataType)\n        : value );\n    return `${ti.namespace}.${ti.name}`;\n  });\n}\n\nmodule.exports = {\n  version,\n  parse,\n  compile,\n  evaluate,\n  resolveInternalTypes,\n  types: typesFn,\n  // Might as well export the UCUM library, since we are using it.\n  ucumUtils: require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance(),\n  // Utility functions that can be used to implement custom functions\n  util\n};\n","// Contains the FHIRPath Filtering and Projection functions.  (Section 5.2 of\n// the FHIRPath 1.0.0 specification).\n\n/**\n *  Adds the filtering and projection functions to the given FHIRPath engine.\n */\nconst util = require('./utilities');\nconst {TypeInfo, ResourceNode} = require('./types');\nconst hashObject = require('./hash-object');\nconst { deepEqual, maxCollSizeForDeepEqual } = require('./deep-equal');\n\nvar engine = {};\nengine.whereMacro = function(parentData, expr) {\n  if(parentData !== false && ! parentData) { return []; }\n\n  return util.flatten(parentData.map((x, i) => {\n    this.$index = i;\n    const condition = expr(x);\n    if (condition instanceof Promise) {\n      return condition.then(c => c[0] ? x : []);\n    }\n    return condition[0] ? x : [];\n  }));\n};\n\nengine.extension = function(parentData, url) {\n  if(parentData !== false && ! parentData || !url) { return []; }\n\n  return util.flatten(parentData.map((x, i) => {\n    this.$index = i;\n    const extensions = (x && (x.data && x.data.extension || x._data && x._data.extension));\n    if (extensions) {\n      return extensions\n        .filter(extension => extension.url === url)\n        .map(e => ResourceNode.makeResNode(e, x, 'Extension', null, 'Extension'));\n    }\n    return [];\n  }));\n};\n\nengine.selectMacro = function(data, expr) {\n  if(data !== false && ! data) { return []; }\n  return util.flatten(data.map((x, i) => {\n    this.$index = i;\n    return expr(x);\n  }));\n};\n\nengine.repeatMacro = function(parentData, expr, res = [], unique = {}) {\n  if(parentData !== false && ! parentData) { return []; }\n\n  let newItems = [].concat(...parentData.map(i => expr(i)));\n  if (newItems.some(i => i instanceof Promise)) {\n    return Promise.all(newItems).then(items => {\n      items = [].concat(...items);\n      if (items.length) {\n        return engine.repeatMacro(getNewItems(items, unique, res), expr, res, unique);\n      }\n      return res;\n    });\n  } else if (newItems.length) {\n    return engine.repeatMacro(getNewItems(newItems, unique, res), expr, res, unique);\n  } else {\n    return res;\n  }\n};\n\n/**\n * Returns new items from the input array that are not in the hash of existing\n * unique items and adds them to the result array.\n * @param {Array<*>} items - inout array.\n * @param {{[key: string]: *}} unique - hash of existing unique items\n * @param {Array<*>} res - result array.\n * @return {Array<*>}\n */\nfunction getNewItems(items, unique, res) {\n  const newItems = items.filter(item => {\n    const key = hashObject(item);\n    const isUnique = !unique[key];\n    if (isUnique) {\n      unique[key] = true;\n    }\n    return isUnique;\n  });\n  res.push.apply(res, newItems);\n  return newItems;\n}\n\n//TODO: behavior on object?\nengine.singleFn = function(x) {\n  if(x.length === 1){\n    return x;\n  } else if (x.length === 0) {\n    return [];\n  } else {\n    throw new Error(\"Expected single\");\n  }\n};\n\n\nengine.firstFn = function(x) {\n  return x[0];\n};\n\nengine.lastFn = function(x) {\n  return x[x.length - 1];\n};\n\nengine.tailFn = function(x) {\n  return x.slice(1, x.length);\n};\n\nengine.takeFn = function(x, n) {\n  return x.slice(0, n);\n};\n\nengine.skipFn = function(x, num) {\n  return x.slice(num, x.length);\n};\n\nengine.ofTypeFn = function(coll, typeInfo) {\n  return coll.filter(value => {\n    return TypeInfo.fromValue(value).is(typeInfo);\n  });\n};\n\nengine.distinctFn = function(x) {\n  let unique = [];\n  if (x.length > 0) {\n    if (x.length > maxCollSizeForDeepEqual) {\n      // When we have more than maxCollSizeForDeepEqual items in input collection,\n      // we use a hash table (on JSON strings) for efficiency.\n      let uniqueHash = {};\n      for (let i = 0, len = x.length; i < len; ++i) {\n        let xObj = x[i];\n        let xStr = hashObject(xObj);\n        if (!uniqueHash[xStr]) {\n          unique.push(xObj);\n          uniqueHash[xStr] = true;\n        }\n      }\n    } else {\n      // Otherwise, it is more efficient to perform a deep comparison.\n      // Use reverse() + pop() instead of shift() to improve performance and\n      // maintain order.\n      x = x.concat().reverse();\n      do {\n        let xObj = x.pop();\n        unique.push(xObj);\n        x = x.filter(o => !deepEqual(xObj, o));\n      } while (x.length);\n    }\n  }\n  return unique;\n};\n\nmodule.exports = engine;\n","const ucumUtils = require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance();\nconst {roundToMaxPrecision} = require('./numbers');\nconst {valDataConverted} = require('./utilities');\nconst {FP_Type, FP_Quantity} = require('./types');\n\n/**\n *  Returns a JSON version of the given object, but with the object's keys\n *  in sorted order (or at least stable order,\n *  see https://stackoverflow.com/a/35810961/360782) and the values in\n *  unified forms, e.g. \"1 year\" is converted to the same value as \"12 months\",\n *  \"3 'min'\" is converted to the same value as \"120 'sec'\".\n *  This function is used instead of deepEqual for optimization when you need\n *  to compare many objects.\n */\nfunction hashObject(obj) {\n  return JSON.stringify(prepareObject(obj));\n}\n\n/**\n * Brings an object to the unified form so that it can be serialized to JSON to\n * compare with other objects according to https://hl7.org/fhirpath/#equals\n * This function is following the logic from deepEqual (if changes are needed\n * here they are likely also needed there).\n */\nfunction prepareObject(value) {\n  value = valDataConverted(value);\n  if (value === null) {\n    return null;\n  } else if (typeof value === 'number') {\n    return roundToMaxPrecision(value);\n  } else if (value instanceof Date) {\n    return value.toISOString();\n  } if (value instanceof FP_Quantity) {\n    const magnitude = FP_Quantity._yearMonthConversionFactor[value.unit];\n    if (magnitude) {\n      return '_!yearMonth!_:' + magnitude * value.value;\n    } else {\n      const ucumQuantity = FP_Quantity.toUcumQuantity(value.value, value.unit);\n      const unit = ucumUtils.getSpecifiedUnit(ucumQuantity.unit).unit;\n      return '_!' + unit.property_ + '!_:' + unit.magnitude_ * ucumQuantity.value;\n    }\n  } else if (value instanceof FP_Type) {\n    return value.toString();\n  } else if (typeof value === 'object') {\n    return Array.isArray(value) ?\n      value.map(prepareObject) :\n      Object.keys(value).sort().reduce(\n        (o, key) => {\n          const v = value[key];\n          o[key] = prepareObject(v);\n          return o;\n        }, {});\n  }\n\n  return  value;\n}\n\nmodule.exports = hashObject;\n","var engine = {};\n\nengine.orOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return true;\n    } else if (a === false) {\n      return [];\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return true;\n    } else {\n      return [];\n    }\n  }\n  return a || b;\n};\n\nengine.andOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return [];\n    } else if (a === false) {\n      return false;\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return [];\n    } else {\n      return false;\n    }\n  }\n  return a && b;\n};\n\nengine.xorOp = function(a, b) {\n  // If a or b are arrays, they must be the empty set.\n  // In that case, the result is always the empty set.\n  if (Array.isArray(a) || Array.isArray(b))\n    return [];\n  return ( a && !b ) || ( !a && b );\n};\n\nengine.impliesOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return [];\n    } else if (a === false) {\n      return true;\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return true;\n    } else {\n      return [];\n    }\n  }\n  if(a === false) { return true; }\n  return (a && b);\n};\n\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Math functions.\n\nconst {FP_Quantity, FP_Type} = require('./types');\nconst util = require(\"./utilities\");\n\n/**\n *  Adds the math functions to the given FHIRPath engine.\n */\nconst engine = {};\n\n/**\n * Checks if input collection is a number singleton and runs the passed function.\n * @param {Array<ResourceNode|number|any>} x - input collection\n * @param {Function} fn - math function\n * @throws Error\n * @return {number}\n */\nfunction callFnForNumericSingleton(x, fn){\n  let res;\n  if (isEmpty(x)){\n    res = [];\n  } else if (x.length !== 1) {\n    throw new Error(\"Unexpected collection\" + JSON.stringify(x) +\n      \"; expected singleton of type number\");\n  } else {\n    const num = util.valData(x[0]);\n    if (num == null) {\n      res = [];\n    } else if (typeof num === 'number') {\n      res = fn(num);\n    } else {\n      throw new Error(\"Expected number, but got \" + JSON.stringify(num));\n    }\n  }\n  return res;\n}\n\nfunction isEmpty(x) {\n  if(typeof(x) == 'number'){\n    return false;\n  }\n  return x.length === 0;\n}\n\nengine.amp = function(x, y){\n  return (x || \"\") + (y || \"\");\n};\n\n//HACK: for only polymorphic function\n//  Actually, \"minus\" is now also polymorphic\nengine.plus = function(xs, ys){\n  let res;\n  if(xs.length === 1 && ys.length === 1) {\n    const x = util.valDataConverted(xs[0]);\n    const y = util.valDataConverted(ys[0]);\n    // In the future, this and other functions might need to return ResourceNode\n    // to preserve the type information (integer vs decimal, and maybe decimal\n    // vs string if decimals are represented as strings), in order to support\n    // \"as\" and \"is\", but that support is deferred for now.\n    if (x == null || y == null) {\n      res = [];\n    } else if (typeof x == \"string\" && typeof y == \"string\") {\n      res = x + y;\n    } else if(typeof x == \"number\") {\n      if (typeof y == \"number\") {\n        res = x + y;\n      } else if (y instanceof FP_Quantity) {\n        res = (new FP_Quantity(x, \"'1'\")).plus(y);\n      }\n    } else if(x instanceof FP_Type) {\n      if (y instanceof FP_Quantity) {\n        res = x.plus(y);\n      } else if (y instanceof FP_Type) {\n        res = y.plus(x);\n      } else if (typeof y == \"number\") {\n        res = x.plus(new FP_Quantity(y, \"'1'\"));\n      }\n    }\n  }\n  if (res === undefined) {\n    throw new Error(\"Cannot \" + JSON.stringify(xs) + \" + \" + JSON.stringify(ys));\n  }\n  return res;\n};\n\nengine.minus = function(xs, ys){\n  if(xs.length === 1 && ys.length === 1) {\n    const x = util.valDataConverted(xs[0]);\n    const y = util.valDataConverted(ys[0]);\n    if (x == null || y == null) {\n      return [];\n    }\n    if(typeof x == \"number\") {\n      if (typeof y == \"number\") {\n        return x - y;\n      }\n      if (y instanceof FP_Quantity) {\n        return (new FP_Quantity(x, \"'1'\")).plus(new FP_Quantity(-y.value, y.unit));\n      }\n    }\n\n    if(x instanceof FP_Type) {\n      if (y instanceof FP_Quantity) {\n        return x.plus(new FP_Quantity(-y.value, y.unit));\n      }\n      if (typeof y == \"number\") {\n        return x.plus(new FP_Quantity(-y, \"'1'\"));\n      }\n    }\n  }\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" - \" + JSON.stringify(ys));\n};\n\n\nengine.mul = function(xs, ys){\n  if(xs.length === 1 && ys.length === 1) {\n    const x = util.valDataConverted(xs[0]);\n    const y = util.valDataConverted(ys[0]);\n    if (x == null || y == null) {\n      return [];\n    }\n    if(typeof x == \"number\") {\n      if (typeof y == \"number\") {\n        return x * y;\n      }\n      if (y instanceof FP_Quantity) {\n        return (new FP_Quantity(x, \"'1'\")).mul(y);\n      }\n    }\n\n    if(x instanceof FP_Type) {\n      if (y instanceof FP_Quantity) {\n        return x.mul(y);\n      }\n      if (typeof y == 'number') {\n        return x.mul(new FP_Quantity(y, \"'1'\"));\n      }\n    }\n  }\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" * \" + JSON.stringify(ys));\n};\n\nengine.div = function(xs, ys){\n  if(xs.length === 1 && ys.length === 1) {\n    const x = util.valDataConverted(xs[0]);\n    const y = util.valDataConverted(ys[0]);\n    if (x == null || y == null) {\n      return [];\n    }\n    if(typeof x == \"number\") {\n      if (typeof y == \"number\") {\n        if (y === 0) return [];\n        return x / y;\n      }\n      if (y instanceof FP_Quantity) {\n        return (new FP_Quantity(x, \"'1'\")).div(y);\n      }\n    }\n\n    if(x instanceof FP_Type) {\n      if (y instanceof FP_Quantity) {\n        return x.div(y);\n      }\n      if (typeof y == \"number\") {\n        return x.div(new FP_Quantity(y, \"'1'\"));\n      }\n    }\n  }\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" / \" + JSON.stringify(ys));\n\n};\n\nengine.intdiv = function(x, y){\n  if (y === 0) return [];\n  return Math.floor(x / y);\n};\n\nengine.mod = function(x, y){\n  if (y === 0) return [];\n  return x % y;\n};\n\nengine.abs = function(x){\n  let res;\n\n  if (isEmpty(x)) {\n    res = [];\n  } else if (x.length !== 1) {\n    throw new Error(\"Unexpected collection\" + JSON.stringify(x) +\n      \"; expected singleton of type number or Quantity\");\n  } else {\n    var val = util.valData(x[0]);\n    if (val == null) {\n      res = [];\n    } else if (typeof val === 'number') {\n      res = Math.abs(val);\n    } else if (val instanceof FP_Quantity) {\n      res = new FP_Quantity(Math.abs(val.value), val.unit);\n    } else {\n      throw new Error(\"Expected number or Quantity, but got \" + JSON.stringify(val || x));\n    }\n  }\n\n  return res;\n};\n\nengine.ceiling = function(x) {\n  return callFnForNumericSingleton(x, Math.ceil);\n};\n\nengine.exp = function(x){\n  return callFnForNumericSingleton(x, Math.exp);\n};\n\nengine.floor = function(x){\n  return callFnForNumericSingleton(x, Math.floor);\n};\n\nengine.ln = function(x){\n  return callFnForNumericSingleton(x, Math.log);\n};\n\nengine.log = function(x, base){\n  return callFnForNumericSingleton(x, (num) => {\n    return (Math.log(num) / Math.log(base));\n  });\n};\n\nengine.power = function(x, exponent){\n  return callFnForNumericSingleton(x, (num) => {\n    const res = Math.pow(num, exponent);\n    return isNaN(res) ? [] : res;\n  });\n};\n\n/**\n * Implements the \"round\" function documented at\n * https://hl7.org/fhirpath/#roundprecision-integer-decimal\n * @param {Array} x - input collection\n * @param {integer} [precision] - determines what decimal place to round to\n * @return {number}\n */\nengine.round = function(x, precision){\n  return callFnForNumericSingleton(x, (num) => {\n    if (precision === undefined) {\n      return (Math.round(num));\n    } else {\n      let degree = Math.pow(10, precision);\n      return (Math.round(num * degree) / degree);\n    }\n  });\n};\n\nengine.sqrt = function(x){\n  return callFnForNumericSingleton(x, (num) => {\n    if (num < 0) {\n      return [];\n    } else {\n      return Math.sqrt(num);\n    }\n  });\n};\n\nengine.truncate = function(x){\n  return callFnForNumericSingleton(x, Math.trunc);\n};\n\nmodule.exports = engine;\n","\n// This file holds code to hande the FHIRPath Existence functions (5.1 in the\n// specification).\n\nvar util = require(\"./utilities\");\nvar types = require(\"./types\");\n\nconst { FP_Quantity, TypeInfo } = types;\n\nvar engine = {};\n\nengine.iifMacro = function(data, cond, ok, fail) {\n  const condition = cond(data);\n  if (condition instanceof Promise) {\n    return condition.then(c => iifMacroSync(data, c, ok, fail));\n  }\n  return iifMacroSync(data, condition, ok, fail);\n};\n\nfunction iifMacroSync(data, condition, ok, fail) {\n  if(util.isTrue(condition)) {\n    return ok(data);\n  } else {\n    return fail ? fail(data) : [];\n  }\n}\n\nengine.traceFn = function (x, label, expr) {\n  const exprRes = expr ? expr(x) : null;\n  if (exprRes instanceof Promise) {\n    return exprRes.then((r) => engine.traceFn(x, label, r));\n  }\n  if (this.customTraceFn) {\n    if (expr){\n      this.customTraceFn(expr(x), label ?? \"\");\n    }\n    else {\n      this.customTraceFn(x, label ?? \"\");\n    }\n  }\n  else {\n    if (expr){\n      console.log(\"TRACE:[\" + (label || \"\") + \"]\", JSON.stringify(expr(x), null, \" \"));\n    }\n    else {\n      console.log(\"TRACE:[\" + (label || \"\") + \"]\", JSON.stringify(x, null, \" \"));\n    }\n  }\n  return x;\n};\n\n/**\n * Defines a variable named name that is accessible in subsequent expressions\n * and has the value of expr if present, otherwise the value of the input\n * collection.\n * @param {Array} x - the input collection on which the function is executed\n * @param {string} label - the name of the variable to define\n * @param {*} [expr] - an expression to run on the input collection\n * @returns the value of the input collection (The function should be transparent\n *  to the caller)\n */\nengine.defineVariable = function (x, label, expr) {\n  let data = x;\n  if (expr){\n    data = expr(x);\n  }\n  // Just in time initialization of definedVars\n  if (!this.definedVars) this.definedVars = {};\n\n  if (label in this.vars || label in this.processedVars) {\n    throw new Error(\"Environment Variable %\" + label + \" already defined\");\n  }\n\n  if (Object.keys(this.definedVars).includes(label)) {\n    throw new Error(\"Variable %\" + label + \" already defined\");\n  }\n\n  this.definedVars[label] = data;\n  return x;\n};\n\nvar intRegex = /^[+-]?\\d+$/;\nengine.toInteger = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valData(coll[0]);\n  if(v === false) {return 0;}\n  if(v === true) {return 1;}\n  if(typeof v === \"number\") {\n    if(Number.isInteger(v)) {\n      return v;\n    } else {\n      return [];\n    }\n  }\n  if(typeof v === \"string\" && intRegex.test(v)) {\n    return parseInt(v);\n  }\n  return [];\n};\n\nconst quantityRegex = /^((\\+|-)?\\d+(\\.\\d+)?)\\s*(('[^']+')|([a-zA-Z]+))?$/,\n  quantityRegexMap = {value:1,unit:5,time:6};\nengine.toQuantity = function (coll, toUnit) {\n  let result;\n\n  if (coll.length > 1) {\n    throw new Error(\"Could not convert to quantity: input collection contains multiple items\");\n  } else if (coll.length === 1) {\n    if (toUnit) {\n      const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n      const toUnitInSeconds = FP_Quantity._calendarDuration2Seconds[toUnit];\n      if (\n        !thisUnitInSeconds !== !toUnitInSeconds &&\n        (thisUnitInSeconds > 1 || toUnitInSeconds > 1)\n      ) {\n        // Conversion from calendar duration quantities greater than seconds to\n        // time-valued UCUM quantities greater than seconds or vice versa is not\n        // allowed.\n        return null;\n      }\n\n      // Surround UCUM unit code in the toUnit parameter with single quotes\n      if (!FP_Quantity.mapTimeUnitsToUCUMCode[toUnit]) {\n        toUnit = `'${toUnit}'`;\n      }\n    }\n\n    var v = util.valDataConverted(coll[0]);\n    let quantityRegexRes;\n\n    if (typeof v === \"number\") {\n      result = new FP_Quantity(v, '\\'1\\'');\n    } else if (v instanceof FP_Quantity) {\n      result = v;\n    } else if (typeof v === 'boolean') {\n      result = new FP_Quantity(v ? 1 : 0, '\\'1\\'');\n    } else if (typeof v === \"string\" && (quantityRegexRes = quantityRegex.exec(v)) ) {\n      const value = quantityRegexRes[quantityRegexMap.value],\n        unit = quantityRegexRes[quantityRegexMap.unit],\n        time = quantityRegexRes[quantityRegexMap.time];\n\n      // UCUM unit code in the input string must be surrounded with single quotes\n      if (!time || FP_Quantity.mapTimeUnitsToUCUMCode[time]) {\n        result = new FP_Quantity(Number(value), unit || time || '\\'1\\'');\n      }\n    }\n\n    if (result && toUnit && result.unit !== toUnit) {\n      result = FP_Quantity.convUnitTo(result.unit, result.value, toUnit);\n    }\n  }\n\n  return result || [];\n};\n\nvar numRegex = /^[+-]?\\d+(\\.\\d+)?$/;\nengine.toDecimal = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valData(coll[0]);\n  if(v === false) {return 0;}\n  if(v === true) {return 1.0;}\n  if(typeof v === \"number\") {\n    return v;\n  }\n  if(typeof v === \"string\" && numRegex.test(v)) {\n    return parseFloat(v);\n  }\n  return [];\n};\n\nengine.toString = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valDataConverted(coll[0]);\n  if (v == null) { return []; }\n  return v.toString();\n};\n\n\n/**\n *  Defines a function on engine called to+timeType (e.g., toDateTime, etc.).\n * @param timeType The string name of a class for a time type (e.g. \"FP_DateTime\").\n */\nfunction defineTimeConverter(timeType) {\n  let timeName = timeType.slice(3); // Remove 'FP_'\n  engine['to'+timeName] = function(coll) {\n    var rtn = [];\n    if (coll.length > 1)\n      throw Error('to '+timeName+' called for a collection of length '+coll.length);\n    if (coll.length === 1) {\n      var v = util.valData(coll[0]);\n      if (typeof v === \"string\") {\n        var t = types[timeType].checkString(v);\n        if (t) {\n          rtn = t;\n        }\n      }\n    }\n    return rtn;\n  };\n}\ndefineTimeConverter('FP_Date');\ndefineTimeConverter('FP_DateTime');\ndefineTimeConverter('FP_Time');\n\n// Possible string values convertible to the true boolean value\nconst trueStrings = ['true', 't', 'yes', 'y', '1', '1.0'].reduce((acc, val) => {\n  acc[val] = true;\n  return acc;\n}, {});\n\n// Possible string values convertible to the false boolean value\nconst falseStrings = ['false', 'f', 'no', 'n', '0', '0.0'].reduce((acc, val) => {\n  acc[val] = true;\n  return acc;\n}, {});\n\nengine.toBoolean = function (coll) {\n  if(coll.length !== 1) {\n    return [];\n  }\n\n  const v = util.valData(coll[0]);\n  switch (typeof v) {\n    case 'boolean':\n      return v;\n    case 'number':\n      if (v === 1) {\n        return true;\n      }\n      if (v === 0) {\n        return false;\n      }\n      break;\n    case 'string':\n      // eslint-disable-next-line no-case-declarations\n      const lowerCaseValue = v.toLowerCase();\n      if (trueStrings[lowerCaseValue]) {\n        return true;\n      }\n      if (falseStrings[lowerCaseValue]) {\n        return false;\n      }\n  }\n  return [];\n};\n\n/**\n * Creates function that checks if toFunction returns specified type\n * @param {function(coll: array): <type|[]>} toFunction\n * @param {string|class} type - specifies type, for example: 'string' or FP_Quantity\n * @return {function(coll: array)}\n */\nengine.createConvertsToFn = function (toFunction, type) {\n  if (typeof type === 'string') {\n    return function (coll) {\n      if (coll.length !== 1) {\n        return [];\n      }\n\n      return typeof toFunction(coll) === type;\n    };\n  }\n\n  return function (coll) {\n    if (coll.length !== 1) {\n      return [];\n    }\n\n    return toFunction(coll) instanceof type;\n  };\n};\n\nconst singletonEvalByType = {\n  \"Integer\": function(d){\n    if (Number.isInteger(d)) {\n      return d;\n    }\n  },\n  \"Boolean\": function(d){\n    if (d === true || d === false) {\n      return d;\n    } else {\n      return true;\n    }\n  },\n  \"Number\": function(d) {\n    if (typeof d === \"number\") {\n      return d;\n    }\n  },\n  \"String\": function(d){\n    if (typeof d === \"string\") {\n      return d;\n    }\n  },\n  \"StringOrNumber\": function(d){\n    if (typeof d === \"string\" || typeof d === \"number\") {\n      return d;\n    }\n  },\n  \"AnySingletonAtRoot\": function (d) {\n    return d;\n  }\n};\n\n/**\n * Converts a collection to a singleton of the specified type.\n * The result can be an empty array if input collection is empty.\n * See http://hl7.org/fhirpath/#singleton-evaluation-of-collections for details.\n * @param {Array} coll - collection\n * @param {string} type - 'Integer', 'Boolean', 'Number' or 'String'\n * @throws {Error}  if there is more than one item in input collection,\n *   or an item that is not a specified type\n * @return {*|[]} the value of specified type or empty array\n */\nengine.singleton = function (coll, type) {\n  if(coll.length > 1){\n    throw new Error(\"Unexpected collection\" + JSON.stringify(coll) +\n      \"; expected singleton of type \" + type);\n  } else if (coll.length === 0) {\n    return [];\n  }\n  const v = util.valData(coll[0]);\n  if (v == null) {\n    return [];\n  }\n  const toSingleton = singletonEvalByType[type];\n  if (toSingleton) {\n    const value = toSingleton(v);\n    if (value !== undefined) {\n      return value;\n    }\n    throw new Error(`Expected ${type.toLowerCase()}, but got: ${JSON.stringify(coll)}`);\n  }\n  throw new Error('Not supported type ' + type);\n};\n\nengine.hasValueFn = function(coll) {\n  return coll.length === 1 && util.valData(coll[0]) != null\n    && TypeInfo.isPrimitive(TypeInfo.fromValue(coll[0]));\n};\n\n/**\n * Returns the underlying system value for the FHIR primitive if the input\n * collection contains a single value which is a FHIR primitive, and it has a\n * primitive value. Otherwise, the return value is empty (i.e. []).\n *\n * See: https://hl7.org/fhir/fhirpath.html#functions\n * @param {Array<*>} coll - input collection\n * @returns {*|[]}\n */\nengine.getValueFn = function(coll) {\n  if (coll.length === 1) {\n    const node = coll[0];\n    const v = util.valData(node);\n    if (v != null && TypeInfo.isPrimitive(TypeInfo.fromValue(node))) {\n      return v;\n    }\n  }\n  return [];\n};\n\nmodule.exports = engine;\n","const util = require(\"./utilities\");\n\nvar engine = {};\n\nengine.children = function(coll){\n  let model = this.model; // \"this\" is the context object\n  return coll.reduce(function(acc, x){\n    let d = util.valData(x);\n    if (d == null) {\n      return acc;\n    } else if (typeof d === 'object') {\n      for (var prop of Object.keys(d)) {\n        util.pushFn(acc, util.makeChildResNodes(x, prop, model));\n      }\n      return acc;\n    } else {\n      return acc;\n    }\n  }, []);\n};\n\nengine.descendants = function(coll){\n  var ch = engine.children.call(this, coll); // \"this\" is the context object\n  var res = [];\n  while(ch.length > 0){\n    util.pushFn(res, ch);\n    ch = engine.children.call(this, ch);\n  }\n  return res;\n};\n\nmodule.exports = engine;\n","let numberFns = {};\n\n// Returns the number of digits in the number after the decimal point, ignoring\n// trailing zeros.\nfunction decimalPlaces(x) {\n  // Based on https://stackoverflow.com/a/9539746/360782\n  // Make sure it is a number and use the builtin number -> string.\n  const s = \"\" + (+x),\n    match = /(\\d+)(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/.exec(s);\n  // NaN or Infinity or integer.\n  // We arbitrarily decide that Infinity is integral.\n  if (!match) { return 0; }\n  // Count the number of digits in the fraction and subtract the\n  // exponent to simulate moving the decimal point left by exponent places.\n  // 1.234e+2 has 1 fraction digit and '234'.length -  2 == 1\n  // 1.234e-2 has 5 fraction digit and '234'.length - -2 == 5\n  //var wholeNum = match[1];\n  const fraction = match[2],\n    exponent = match[3];\n  return Math.max(\n    0,  // lower limit.\n    (fraction === '0' ? 0 : (fraction || '').length)  // fraction length\n    - (exponent || 0));  // exponent\n}\n\n/**\n *  Rounds a number to the specified number of decimal places.\n * @param x the decimal number to be rounded\n * @param n the (maximum) number of decimal places to preserve.  (The result\n *  could contain fewer if the decimal digits in x contain zeros).\n */\nfunction roundToDecimalPlaces (x, n) {\n  const scale = Math.pow(10, n);\n  return Math.round(x*scale)/scale;\n}\n\n/**\n *  The smallest representable number in FHIRPath.\n */\nconst PRECISION_STEP = 1e-8;\n\n/**\n *  Rounds a number to the nearest multiple of PRECISION_STEP.\n */\nconst roundToMaxPrecision = numberFns.roundToMaxPrecision = function (x) {\n  return Math.round(x/PRECISION_STEP)*PRECISION_STEP;\n};\n\n/**\n * Determines numbers equivalence\n * @param {number} actual\n * @param {number} expected\n * @return {boolean}\n */\nnumberFns.isEquivalent = function(actual, expected) {\n  if(Number.isInteger(actual) && Number.isInteger(expected)) {\n    return actual === expected;\n  }\n\n  const prec = Math.min(decimalPlaces(actual), decimalPlaces(expected));\n\n  if(prec === 0){\n    return Math.round(actual) === Math.round(expected);\n  } else {\n    // Note: parseFloat(0.00000011).toPrecision(7) ===  \"1.100000e-7\"\n    // It does # of significant digits, not decimal places.\n    return roundToDecimalPlaces(actual, prec) ===\n      roundToDecimalPlaces(expected, prec);\n  }\n};\n\n/**\n * Determines numbers equality\n * @param {number} actual\n * @param {number} expected\n * @return {boolean}\n */\nnumberFns.isEqual = function(actual, expected) {\n  return roundToMaxPrecision(actual) === roundToMaxPrecision(expected);\n};\n\nmodule.exports = numberFns;\n","// This is a modified version of antr4's index.js, in which\n// the \"require\" statements of two unused classes are commented out\n// to avoid introducing a dependency on Node.js' \"fs\" package.\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nexports.atn = require('antlr4/src/antlr4/atn/index');\nexports.codepointat = require('antlr4/src/antlr4/polyfills/codepointat');\nexports.dfa = require('antlr4/src/antlr4/dfa/index');\nexports.fromcodepoint = require('antlr4/src/antlr4/polyfills/fromcodepoint');\nexports.tree = require('antlr4/src/antlr4/tree/index');\nexports.error = require('antlr4/src/antlr4/error/index');\nexports.Token = require('antlr4/src/antlr4/Token').Token;\n// Commented out to avoid the problem with 'fs' during the webpack build\n// exports.CharStreams = require('antlr4/src/antlr4/CharStreams');\nexports.CommonToken = require('antlr4/src/antlr4/Token').CommonToken;\nexports.InputStream = require('antlr4/src/antlr4/InputStream');\n// Commented out to avoid the problem with 'fs' during the webpack build\n// exports.FileStream = require('antlr4/src/antlr4/FileStream');\nexports.CommonTokenStream = require('antlr4/src/antlr4/CommonTokenStream');\nexports.Lexer = require('antlr4/src/antlr4/Lexer');\nexports.Parser = require('antlr4/src/antlr4/Parser');\nvar pc = require('antlr4/src/antlr4/PredictionContext');\nexports.PredictionContextCache = pc.PredictionContextCache;\nexports.ParserRuleContext = require('antlr4/src/antlr4/ParserRuleContext');\nexports.Interval = require('antlr4/src/antlr4/IntervalSet').Interval;\nexports.IntervalSet = require('antlr4/src/antlr4/IntervalSet').IntervalSet;\nexports.Utils = require('antlr4/src/antlr4/Utils');\nexports.LL1Analyzer = require('antlr4/src/antlr4/LL1Analyzer').LL1Analyzer;\n","// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = require('../antlr4-index');\n\n\n\nconst serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\",\n    \"\\u5964\\u0002A\\u0203\\b\\u0001\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\",\n    \"\\u0004\\u0004\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\",\n    \"\\t\\u0007\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\",\n    \"\\f\\t\\f\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\",\n    \"\\t\\u0010\\u0004\\u0011\\t\\u0011\\u0004\\u0012\\t\\u0012\\u0004\\u0013\\t\\u0013\",\n    \"\\u0004\\u0014\\t\\u0014\\u0004\\u0015\\t\\u0015\\u0004\\u0016\\t\\u0016\\u0004\\u0017\",\n    \"\\t\\u0017\\u0004\\u0018\\t\\u0018\\u0004\\u0019\\t\\u0019\\u0004\\u001a\\t\\u001a\",\n    \"\\u0004\\u001b\\t\\u001b\\u0004\\u001c\\t\\u001c\\u0004\\u001d\\t\\u001d\\u0004\\u001e\",\n    \"\\t\\u001e\\u0004\\u001f\\t\\u001f\\u0004 \\t \\u0004!\\t!\\u0004\\\"\\t\\\"\\u0004#\",\n    \"\\t#\\u0004$\\t$\\u0004%\\t%\\u0004&\\t&\\u0004\\'\\t\\'\\u0004(\\t(\\u0004)\\t)\\u0004\",\n    \"*\\t*\\u0004+\\t+\\u0004,\\t,\\u0004-\\t-\\u0004.\\t.\\u0004/\\t/\\u00040\\t0\\u0004\",\n    \"1\\t1\\u00042\\t2\\u00043\\t3\\u00044\\t4\\u00045\\t5\\u00046\\t6\\u00047\\t7\\u0004\",\n    \"8\\t8\\u00049\\t9\\u0004:\\t:\\u0004;\\t;\\u0004<\\t<\\u0004=\\t=\\u0004>\\t>\\u0004\",\n    \"?\\t?\\u0004@\\t@\\u0004A\\tA\\u0004B\\tB\\u0004C\\tC\\u0004D\\tD\\u0003\\u0002\\u0003\",\n    \"\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\\u0005\\u0003\",\n    \"\\u0005\\u0003\\u0006\\u0003\\u0006\\u0003\\u0007\\u0003\\u0007\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\",\n    \"\\u000b\\u0003\\u000b\\u0003\\f\\u0003\\f\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\u000e\",\n    \"\\u0003\\u000e\\u0003\\u000f\\u0003\\u000f\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\",\n    \"\\u0003\\u0011\\u0003\\u0011\\u0003\\u0011\\u0003\\u0012\\u0003\\u0012\\u0003\\u0012\",\n    \"\\u0003\\u0013\\u0003\\u0013\\u0003\\u0014\\u0003\\u0014\\u0003\\u0015\\u0003\\u0015\",\n    \"\\u0003\\u0015\\u0003\\u0016\\u0003\\u0016\\u0003\\u0016\\u0003\\u0017\\u0003\\u0017\",\n    \"\\u0003\\u0017\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\",\n    \"\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0019\\u0003\\u0019\",\n    \"\\u0003\\u0019\\u0003\\u0019\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\\u0003\\u001b\",\n    \"\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\",\n    \"\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001d\",\n    \"\\u0003\\u001d\\u0003\\u001e\\u0003\\u001e\\u0003\\u001f\\u0003\\u001f\\u0003 \",\n    \"\\u0003 \\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003\",\n    \"\\\"\\u0003\\\"\\u0003\\\"\\u0003#\\u0003#\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\",\n    \"\\u0003$\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003&\\u0003\",\n    \"&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003\\'\\u0003\\'\\u0003(\\u0003(\\u0003\",\n    \"(\\u0003(\\u0003(\\u0003)\\u0003)\\u0003)\\u0003)\\u0003)\\u0003)\\u0003*\\u0003\",\n    \"*\\u0003*\\u0003*\\u0003*\\u0003+\\u0003+\\u0003+\\u0003+\\u0003,\\u0003,\\u0003\",\n    \",\\u0003,\\u0003,\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003\",\n    \".\\u0003.\\u0003.\\u0003.\\u0003.\\u0003.\\u0003.\\u0003/\\u0003/\\u0003/\\u0003\",\n    \"/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u00030\\u0003\",\n    \"0\\u00030\\u00030\\u00030\\u00030\\u00031\\u00031\\u00031\\u00031\\u00031\\u0003\",\n    \"1\\u00031\\u00032\\u00032\\u00032\\u00032\\u00032\\u00032\\u00033\\u00033\\u0003\",\n    \"3\\u00033\\u00033\\u00034\\u00034\\u00034\\u00034\\u00034\\u00034\\u00035\\u0003\",\n    \"5\\u00035\\u00035\\u00035\\u00035\\u00035\\u00035\\u00036\\u00036\\u00036\\u0003\",\n    \"6\\u00036\\u00036\\u00036\\u00036\\u00037\\u00037\\u00037\\u00037\\u00037\\u0003\",\n    \"7\\u00037\\u00037\\u00037\\u00037\\u00037\\u00037\\u00037\\u00038\\u00038\\u0003\",\n    \"8\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u0003\",\n    \"8\\u00058\\u0183\\n8\\u00058\\u0185\\n8\\u00058\\u0187\\n8\\u00038\\u00058\\u018a\",\n    \"\\n8\\u00039\\u00039\\u00039\\u00039\\u0003:\\u0003:\\u0003:\\u0003:\\u0003:\\u0003\",\n    \":\\u0003:\\u0003:\\u0003:\\u0003:\\u0006:\\u019a\\n:\\r:\\u000e:\\u019b\\u0005\",\n    \":\\u019e\\n:\\u0005:\\u01a0\\n:\\u0005:\\u01a2\\n:\\u0003:\\u0003:\\u0003:\\u0003\",\n    \":\\u0003:\\u0003:\\u0003:\\u0005:\\u01ab\\n:\\u0003;\\u0005;\\u01ae\\n;\\u0003\",\n    \";\\u0007;\\u01b1\\n;\\f;\\u000e;\\u01b4\\u000b;\\u0003<\\u0003<\\u0003<\\u0007\",\n    \"<\\u01b9\\n<\\f<\\u000e<\\u01bc\\u000b<\\u0003<\\u0003<\\u0003=\\u0003=\\u0003\",\n    \"=\\u0007=\\u01c3\\n=\\f=\\u000e=\\u01c6\\u000b=\\u0003=\\u0003=\\u0003>\\u0006\",\n    \">\\u01cb\\n>\\r>\\u000e>\\u01cc\\u0003>\\u0003>\\u0006>\\u01d1\\n>\\r>\\u000e>\\u01d2\",\n    \"\\u0005>\\u01d5\\n>\\u0003?\\u0006?\\u01d8\\n?\\r?\\u000e?\\u01d9\\u0003?\\u0003\",\n    \"?\\u0003@\\u0003@\\u0003@\\u0003@\\u0007@\\u01e2\\n@\\f@\\u000e@\\u01e5\\u000b\",\n    \"@\\u0003@\\u0003@\\u0003@\\u0003@\\u0003@\\u0003A\\u0003A\\u0003A\\u0003A\\u0007\",\n    \"A\\u01f0\\nA\\fA\\u000eA\\u01f3\\u000bA\\u0003A\\u0003A\\u0003B\\u0003B\\u0003\",\n    \"B\\u0005B\\u01fa\\nB\\u0003C\\u0003C\\u0003C\\u0003C\\u0003C\\u0003C\\u0003D\\u0003\",\n    \"D\\u0003\\u01e3\\u0002E\\u0003\\u0003\\u0005\\u0004\\u0007\\u0005\\t\\u0006\\u000b\",\n    \"\\u0007\\r\\b\\u000f\\t\\u0011\\n\\u0013\\u000b\\u0015\\f\\u0017\\r\\u0019\\u000e\\u001b\",\n    \"\\u000f\\u001d\\u0010\\u001f\\u0011!\\u0012#\\u0013%\\u0014\\'\\u0015)\\u0016+\",\n    \"\\u0017-\\u0018/\\u00191\\u001a3\\u001b5\\u001c7\\u001d9\\u001e;\\u001f= ?!A\",\n    \"\\\"C#E$G%I&K\\'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s\\u0002u;w<y={>}\",\n    \"?\\u007f@\\u0081A\\u0083\\u0002\\u0085\\u0002\\u0087\\u0002\\u0003\\u0002\\f\\u0003\",\n    \"\\u00022;\\u0004\\u0002--//\\u0005\\u0002C\\\\aac|\\u0006\\u00022;C\\\\aac|\\u0004\",\n    \"\\u0002^^bb\\u0003\\u0002))\\u0005\\u0002\\u000b\\f\\u000f\\u000f\\\"\\\"\\u0004\\u0002\",\n    \"\\f\\f\\u000f\\u000f\\n\\u0002))11^^bbhhppttvv\\u0005\\u00022;CHch\\u0002\\u0214\",\n    \"\\u0002\\u0003\\u0003\\u0002\\u0002\\u0002\\u0002\\u0005\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0007\\u0003\\u0002\\u0002\\u0002\\u0002\\t\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u000b\\u0003\\u0002\\u0002\\u0002\\u0002\\r\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u000f\\u0003\\u0002\\u0002\\u0002\\u0002\\u0011\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0013\\u0003\\u0002\\u0002\\u0002\\u0002\\u0015\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0017\\u0003\\u0002\\u0002\\u0002\\u0002\\u0019\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u001b\\u0003\\u0002\\u0002\\u0002\\u0002\\u001d\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u001f\\u0003\\u0002\\u0002\\u0002\\u0002!\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002#\\u0003\\u0002\\u0002\\u0002\\u0002%\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"\\'\\u0003\\u0002\\u0002\\u0002\\u0002)\\u0003\\u0002\\u0002\\u0002\\u0002+\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002-\\u0003\\u0002\\u0002\\u0002\\u0002/\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00021\\u0003\\u0002\\u0002\\u0002\\u00023\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00025\\u0003\\u0002\\u0002\\u0002\\u00027\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00029\\u0003\\u0002\\u0002\\u0002\\u0002;\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"=\\u0003\\u0002\\u0002\\u0002\\u0002?\\u0003\\u0002\\u0002\\u0002\\u0002A\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002C\\u0003\\u0002\\u0002\\u0002\\u0002E\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002G\\u0003\\u0002\\u0002\\u0002\\u0002I\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002K\\u0003\\u0002\\u0002\\u0002\\u0002M\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002O\\u0003\\u0002\\u0002\\u0002\\u0002Q\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"S\\u0003\\u0002\\u0002\\u0002\\u0002U\\u0003\\u0002\\u0002\\u0002\\u0002W\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002Y\\u0003\\u0002\\u0002\\u0002\\u0002[\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002]\\u0003\\u0002\\u0002\\u0002\\u0002_\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002a\\u0003\\u0002\\u0002\\u0002\\u0002c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002e\\u0003\\u0002\\u0002\\u0002\\u0002g\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"i\\u0003\\u0002\\u0002\\u0002\\u0002k\\u0003\\u0002\\u0002\\u0002\\u0002m\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002o\\u0003\\u0002\\u0002\\u0002\\u0002q\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002u\\u0003\\u0002\\u0002\\u0002\\u0002w\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002y\\u0003\\u0002\\u0002\\u0002\\u0002{\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002}\\u0003\\u0002\\u0002\\u0002\\u0002\\u007f\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0081\\u0003\\u0002\\u0002\\u0002\\u0003\\u0089\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0005\\u008b\\u0003\\u0002\\u0002\\u0002\\u0007\\u008d\\u0003\\u0002\\u0002\\u0002\",\n    \"\\t\\u008f\\u0003\\u0002\\u0002\\u0002\\u000b\\u0091\\u0003\\u0002\\u0002\\u0002\",\n    \"\\r\\u0093\\u0003\\u0002\\u0002\\u0002\\u000f\\u0095\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0011\\u0097\\u0003\\u0002\\u0002\\u0002\\u0013\\u009b\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0015\\u009f\\u0003\\u0002\\u0002\\u0002\\u0017\\u00a1\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0019\\u00a3\\u0003\\u0002\\u0002\\u0002\\u001b\\u00a6\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u001d\\u00a8\\u0003\\u0002\\u0002\\u0002\\u001f\\u00aa\\u0003\\u0002\\u0002\\u0002\",\n    \"!\\u00ad\\u0003\\u0002\\u0002\\u0002#\\u00b0\\u0003\\u0002\\u0002\\u0002%\\u00b3\",\n    \"\\u0003\\u0002\\u0002\\u0002\\'\\u00b5\\u0003\\u0002\\u0002\\u0002)\\u00b7\\u0003\",\n    \"\\u0002\\u0002\\u0002+\\u00ba\\u0003\\u0002\\u0002\\u0002-\\u00bd\\u0003\\u0002\",\n    \"\\u0002\\u0002/\\u00c0\\u0003\\u0002\\u0002\\u00021\\u00c9\\u0003\\u0002\\u0002\",\n    \"\\u00023\\u00cd\\u0003\\u0002\\u0002\\u00025\\u00d0\\u0003\\u0002\\u0002\\u0002\",\n    \"7\\u00d4\\u0003\\u0002\\u0002\\u00029\\u00dc\\u0003\\u0002\\u0002\\u0002;\\u00de\",\n    \"\\u0003\\u0002\\u0002\\u0002=\\u00e0\\u0003\\u0002\\u0002\\u0002?\\u00e2\\u0003\",\n    \"\\u0002\\u0002\\u0002A\\u00e4\\u0003\\u0002\\u0002\\u0002C\\u00e9\\u0003\\u0002\",\n    \"\\u0002\\u0002E\\u00ef\\u0003\\u0002\\u0002\\u0002G\\u00f1\\u0003\\u0002\\u0002\",\n    \"\\u0002I\\u00f7\\u0003\\u0002\\u0002\\u0002K\\u00fe\\u0003\\u0002\\u0002\\u0002\",\n    \"M\\u0105\\u0003\\u0002\\u0002\\u0002O\\u0107\\u0003\\u0002\\u0002\\u0002Q\\u010c\",\n    \"\\u0003\\u0002\\u0002\\u0002S\\u0112\\u0003\\u0002\\u0002\\u0002U\\u0117\\u0003\",\n    \"\\u0002\\u0002\\u0002W\\u011b\\u0003\\u0002\\u0002\\u0002Y\\u0120\\u0003\\u0002\",\n    \"\\u0002\\u0002[\\u0127\\u0003\\u0002\\u0002\\u0002]\\u012e\\u0003\\u0002\\u0002\",\n    \"\\u0002_\\u013a\\u0003\\u0002\\u0002\\u0002a\\u0140\\u0003\\u0002\\u0002\\u0002\",\n    \"c\\u0147\\u0003\\u0002\\u0002\\u0002e\\u014d\\u0003\\u0002\\u0002\\u0002g\\u0152\",\n    \"\\u0003\\u0002\\u0002\\u0002i\\u0158\\u0003\\u0002\\u0002\\u0002k\\u0160\\u0003\",\n    \"\\u0002\\u0002\\u0002m\\u0168\\u0003\\u0002\\u0002\\u0002o\\u0175\\u0003\\u0002\",\n    \"\\u0002\\u0002q\\u018b\\u0003\\u0002\\u0002\\u0002s\\u018f\\u0003\\u0002\\u0002\",\n    \"\\u0002u\\u01ad\\u0003\\u0002\\u0002\\u0002w\\u01b5\\u0003\\u0002\\u0002\\u0002\",\n    \"y\\u01bf\\u0003\\u0002\\u0002\\u0002{\\u01ca\\u0003\\u0002\\u0002\\u0002}\\u01d7\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u007f\\u01dd\\u0003\\u0002\\u0002\\u0002\\u0081\\u01eb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0083\\u01f6\\u0003\\u0002\\u0002\\u0002\\u0085\\u01fb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0087\\u0201\\u0003\\u0002\\u0002\\u0002\\u0089\\u008a\",\n    \"\\u00070\\u0002\\u0002\\u008a\\u0004\\u0003\\u0002\\u0002\\u0002\\u008b\\u008c\",\n    \"\\u0007]\\u0002\\u0002\\u008c\\u0006\\u0003\\u0002\\u0002\\u0002\\u008d\\u008e\",\n    \"\\u0007_\\u0002\\u0002\\u008e\\b\\u0003\\u0002\\u0002\\u0002\\u008f\\u0090\\u0007\",\n    \"-\\u0002\\u0002\\u0090\\n\\u0003\\u0002\\u0002\\u0002\\u0091\\u0092\\u0007/\\u0002\",\n    \"\\u0002\\u0092\\f\\u0003\\u0002\\u0002\\u0002\\u0093\\u0094\\u0007,\\u0002\\u0002\",\n    \"\\u0094\\u000e\\u0003\\u0002\\u0002\\u0002\\u0095\\u0096\\u00071\\u0002\\u0002\",\n    \"\\u0096\\u0010\\u0003\\u0002\\u0002\\u0002\\u0097\\u0098\\u0007f\\u0002\\u0002\",\n    \"\\u0098\\u0099\\u0007k\\u0002\\u0002\\u0099\\u009a\\u0007x\\u0002\\u0002\\u009a\",\n    \"\\u0012\\u0003\\u0002\\u0002\\u0002\\u009b\\u009c\\u0007o\\u0002\\u0002\\u009c\",\n    \"\\u009d\\u0007q\\u0002\\u0002\\u009d\\u009e\\u0007f\\u0002\\u0002\\u009e\\u0014\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u009f\\u00a0\\u0007(\\u0002\\u0002\\u00a0\\u0016\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u00a1\\u00a2\\u0007~\\u0002\\u0002\\u00a2\\u0018\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u00a3\\u00a4\\u0007>\\u0002\\u0002\\u00a4\\u00a5\",\n    \"\\u0007?\\u0002\\u0002\\u00a5\\u001a\\u0003\\u0002\\u0002\\u0002\\u00a6\\u00a7\",\n    \"\\u0007>\\u0002\\u0002\\u00a7\\u001c\\u0003\\u0002\\u0002\\u0002\\u00a8\\u00a9\",\n    \"\\u0007@\\u0002\\u0002\\u00a9\\u001e\\u0003\\u0002\\u0002\\u0002\\u00aa\\u00ab\",\n    \"\\u0007@\\u0002\\u0002\\u00ab\\u00ac\\u0007?\\u0002\\u0002\\u00ac \\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00ad\\u00ae\\u0007k\\u0002\\u0002\\u00ae\\u00af\\u0007u\\u0002\",\n    \"\\u0002\\u00af\\\"\\u0003\\u0002\\u0002\\u0002\\u00b0\\u00b1\\u0007c\\u0002\\u0002\",\n    \"\\u00b1\\u00b2\\u0007u\\u0002\\u0002\\u00b2$\\u0003\\u0002\\u0002\\u0002\\u00b3\",\n    \"\\u00b4\\u0007?\\u0002\\u0002\\u00b4&\\u0003\\u0002\\u0002\\u0002\\u00b5\\u00b6\",\n    \"\\u0007\\u0080\\u0002\\u0002\\u00b6(\\u0003\\u0002\\u0002\\u0002\\u00b7\\u00b8\",\n    \"\\u0007#\\u0002\\u0002\\u00b8\\u00b9\\u0007?\\u0002\\u0002\\u00b9*\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00ba\\u00bb\\u0007#\\u0002\\u0002\\u00bb\\u00bc\\u0007\\u0080\",\n    \"\\u0002\\u0002\\u00bc,\\u0003\\u0002\\u0002\\u0002\\u00bd\\u00be\\u0007k\\u0002\",\n    \"\\u0002\\u00be\\u00bf\\u0007p\\u0002\\u0002\\u00bf.\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00c0\\u00c1\\u0007e\\u0002\\u0002\\u00c1\\u00c2\\u0007q\\u0002\\u0002\\u00c2\",\n    \"\\u00c3\\u0007p\\u0002\\u0002\\u00c3\\u00c4\\u0007v\\u0002\\u0002\\u00c4\\u00c5\",\n    \"\\u0007c\\u0002\\u0002\\u00c5\\u00c6\\u0007k\\u0002\\u0002\\u00c6\\u00c7\\u0007\",\n    \"p\\u0002\\u0002\\u00c7\\u00c8\\u0007u\\u0002\\u0002\\u00c80\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00c9\\u00ca\\u0007c\\u0002\\u0002\\u00ca\\u00cb\\u0007p\\u0002\\u0002\",\n    \"\\u00cb\\u00cc\\u0007f\\u0002\\u0002\\u00cc2\\u0003\\u0002\\u0002\\u0002\\u00cd\",\n    \"\\u00ce\\u0007q\\u0002\\u0002\\u00ce\\u00cf\\u0007t\\u0002\\u0002\\u00cf4\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00d0\\u00d1\\u0007z\\u0002\\u0002\\u00d1\\u00d2\\u0007\",\n    \"q\\u0002\\u0002\\u00d2\\u00d3\\u0007t\\u0002\\u0002\\u00d36\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00d4\\u00d5\\u0007k\\u0002\\u0002\\u00d5\\u00d6\\u0007o\\u0002\\u0002\",\n    \"\\u00d6\\u00d7\\u0007r\\u0002\\u0002\\u00d7\\u00d8\\u0007n\\u0002\\u0002\\u00d8\",\n    \"\\u00d9\\u0007k\\u0002\\u0002\\u00d9\\u00da\\u0007g\\u0002\\u0002\\u00da\\u00db\",\n    \"\\u0007u\\u0002\\u0002\\u00db8\\u0003\\u0002\\u0002\\u0002\\u00dc\\u00dd\\u0007\",\n    \"*\\u0002\\u0002\\u00dd:\\u0003\\u0002\\u0002\\u0002\\u00de\\u00df\\u0007+\\u0002\",\n    \"\\u0002\\u00df<\\u0003\\u0002\\u0002\\u0002\\u00e0\\u00e1\\u0007}\\u0002\\u0002\",\n    \"\\u00e1>\\u0003\\u0002\\u0002\\u0002\\u00e2\\u00e3\\u0007\\u007f\\u0002\\u0002\",\n    \"\\u00e3@\\u0003\\u0002\\u0002\\u0002\\u00e4\\u00e5\\u0007v\\u0002\\u0002\\u00e5\",\n    \"\\u00e6\\u0007t\\u0002\\u0002\\u00e6\\u00e7\\u0007w\\u0002\\u0002\\u00e7\\u00e8\",\n    \"\\u0007g\\u0002\\u0002\\u00e8B\\u0003\\u0002\\u0002\\u0002\\u00e9\\u00ea\\u0007\",\n    \"h\\u0002\\u0002\\u00ea\\u00eb\\u0007c\\u0002\\u0002\\u00eb\\u00ec\\u0007n\\u0002\",\n    \"\\u0002\\u00ec\\u00ed\\u0007u\\u0002\\u0002\\u00ed\\u00ee\\u0007g\\u0002\\u0002\",\n    \"\\u00eeD\\u0003\\u0002\\u0002\\u0002\\u00ef\\u00f0\\u0007\\'\\u0002\\u0002\\u00f0\",\n    \"F\\u0003\\u0002\\u0002\\u0002\\u00f1\\u00f2\\u0007&\\u0002\\u0002\\u00f2\\u00f3\",\n    \"\\u0007v\\u0002\\u0002\\u00f3\\u00f4\\u0007j\\u0002\\u0002\\u00f4\\u00f5\\u0007\",\n    \"k\\u0002\\u0002\\u00f5\\u00f6\\u0007u\\u0002\\u0002\\u00f6H\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00f7\\u00f8\\u0007&\\u0002\\u0002\\u00f8\\u00f9\\u0007k\\u0002\\u0002\",\n    \"\\u00f9\\u00fa\\u0007p\\u0002\\u0002\\u00fa\\u00fb\\u0007f\\u0002\\u0002\\u00fb\",\n    \"\\u00fc\\u0007g\\u0002\\u0002\\u00fc\\u00fd\\u0007z\\u0002\\u0002\\u00fdJ\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00fe\\u00ff\\u0007&\\u0002\\u0002\\u00ff\\u0100\\u0007\",\n    \"v\\u0002\\u0002\\u0100\\u0101\\u0007q\\u0002\\u0002\\u0101\\u0102\\u0007v\\u0002\",\n    \"\\u0002\\u0102\\u0103\\u0007c\\u0002\\u0002\\u0103\\u0104\\u0007n\\u0002\\u0002\",\n    \"\\u0104L\\u0003\\u0002\\u0002\\u0002\\u0105\\u0106\\u0007.\\u0002\\u0002\\u0106\",\n    \"N\\u0003\\u0002\\u0002\\u0002\\u0107\\u0108\\u0007{\\u0002\\u0002\\u0108\\u0109\",\n    \"\\u0007g\\u0002\\u0002\\u0109\\u010a\\u0007c\\u0002\\u0002\\u010a\\u010b\\u0007\",\n    \"t\\u0002\\u0002\\u010bP\\u0003\\u0002\\u0002\\u0002\\u010c\\u010d\\u0007o\\u0002\",\n    \"\\u0002\\u010d\\u010e\\u0007q\\u0002\\u0002\\u010e\\u010f\\u0007p\\u0002\\u0002\",\n    \"\\u010f\\u0110\\u0007v\\u0002\\u0002\\u0110\\u0111\\u0007j\\u0002\\u0002\\u0111\",\n    \"R\\u0003\\u0002\\u0002\\u0002\\u0112\\u0113\\u0007y\\u0002\\u0002\\u0113\\u0114\",\n    \"\\u0007g\\u0002\\u0002\\u0114\\u0115\\u0007g\\u0002\\u0002\\u0115\\u0116\\u0007\",\n    \"m\\u0002\\u0002\\u0116T\\u0003\\u0002\\u0002\\u0002\\u0117\\u0118\\u0007f\\u0002\",\n    \"\\u0002\\u0118\\u0119\\u0007c\\u0002\\u0002\\u0119\\u011a\\u0007{\\u0002\\u0002\",\n    \"\\u011aV\\u0003\\u0002\\u0002\\u0002\\u011b\\u011c\\u0007j\\u0002\\u0002\\u011c\",\n    \"\\u011d\\u0007q\\u0002\\u0002\\u011d\\u011e\\u0007w\\u0002\\u0002\\u011e\\u011f\",\n    \"\\u0007t\\u0002\\u0002\\u011fX\\u0003\\u0002\\u0002\\u0002\\u0120\\u0121\\u0007\",\n    \"o\\u0002\\u0002\\u0121\\u0122\\u0007k\\u0002\\u0002\\u0122\\u0123\\u0007p\\u0002\",\n    \"\\u0002\\u0123\\u0124\\u0007w\\u0002\\u0002\\u0124\\u0125\\u0007v\\u0002\\u0002\",\n    \"\\u0125\\u0126\\u0007g\\u0002\\u0002\\u0126Z\\u0003\\u0002\\u0002\\u0002\\u0127\",\n    \"\\u0128\\u0007u\\u0002\\u0002\\u0128\\u0129\\u0007g\\u0002\\u0002\\u0129\\u012a\",\n    \"\\u0007e\\u0002\\u0002\\u012a\\u012b\\u0007q\\u0002\\u0002\\u012b\\u012c\\u0007\",\n    \"p\\u0002\\u0002\\u012c\\u012d\\u0007f\\u0002\\u0002\\u012d\\\\\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u012e\\u012f\\u0007o\\u0002\\u0002\\u012f\\u0130\\u0007k\\u0002\\u0002\",\n    \"\\u0130\\u0131\\u0007n\\u0002\\u0002\\u0131\\u0132\\u0007n\\u0002\\u0002\\u0132\",\n    \"\\u0133\\u0007k\\u0002\\u0002\\u0133\\u0134\\u0007u\\u0002\\u0002\\u0134\\u0135\",\n    \"\\u0007g\\u0002\\u0002\\u0135\\u0136\\u0007e\\u0002\\u0002\\u0136\\u0137\\u0007\",\n    \"q\\u0002\\u0002\\u0137\\u0138\\u0007p\\u0002\\u0002\\u0138\\u0139\\u0007f\\u0002\",\n    \"\\u0002\\u0139^\\u0003\\u0002\\u0002\\u0002\\u013a\\u013b\\u0007{\\u0002\\u0002\",\n    \"\\u013b\\u013c\\u0007g\\u0002\\u0002\\u013c\\u013d\\u0007c\\u0002\\u0002\\u013d\",\n    \"\\u013e\\u0007t\\u0002\\u0002\\u013e\\u013f\\u0007u\\u0002\\u0002\\u013f`\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0140\\u0141\\u0007o\\u0002\\u0002\\u0141\\u0142\\u0007\",\n    \"q\\u0002\\u0002\\u0142\\u0143\\u0007p\\u0002\\u0002\\u0143\\u0144\\u0007v\\u0002\",\n    \"\\u0002\\u0144\\u0145\\u0007j\\u0002\\u0002\\u0145\\u0146\\u0007u\\u0002\\u0002\",\n    \"\\u0146b\\u0003\\u0002\\u0002\\u0002\\u0147\\u0148\\u0007y\\u0002\\u0002\\u0148\",\n    \"\\u0149\\u0007g\\u0002\\u0002\\u0149\\u014a\\u0007g\\u0002\\u0002\\u014a\\u014b\",\n    \"\\u0007m\\u0002\\u0002\\u014b\\u014c\\u0007u\\u0002\\u0002\\u014cd\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u014d\\u014e\\u0007f\\u0002\\u0002\\u014e\\u014f\\u0007c\\u0002\",\n    \"\\u0002\\u014f\\u0150\\u0007{\\u0002\\u0002\\u0150\\u0151\\u0007u\\u0002\\u0002\",\n    \"\\u0151f\\u0003\\u0002\\u0002\\u0002\\u0152\\u0153\\u0007j\\u0002\\u0002\\u0153\",\n    \"\\u0154\\u0007q\\u0002\\u0002\\u0154\\u0155\\u0007w\\u0002\\u0002\\u0155\\u0156\",\n    \"\\u0007t\\u0002\\u0002\\u0156\\u0157\\u0007u\\u0002\\u0002\\u0157h\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0158\\u0159\\u0007o\\u0002\\u0002\\u0159\\u015a\\u0007k\\u0002\",\n    \"\\u0002\\u015a\\u015b\\u0007p\\u0002\\u0002\\u015b\\u015c\\u0007w\\u0002\\u0002\",\n    \"\\u015c\\u015d\\u0007v\\u0002\\u0002\\u015d\\u015e\\u0007g\\u0002\\u0002\\u015e\",\n    \"\\u015f\\u0007u\\u0002\\u0002\\u015fj\\u0003\\u0002\\u0002\\u0002\\u0160\\u0161\",\n    \"\\u0007u\\u0002\\u0002\\u0161\\u0162\\u0007g\\u0002\\u0002\\u0162\\u0163\\u0007\",\n    \"e\\u0002\\u0002\\u0163\\u0164\\u0007q\\u0002\\u0002\\u0164\\u0165\\u0007p\\u0002\",\n    \"\\u0002\\u0165\\u0166\\u0007f\\u0002\\u0002\\u0166\\u0167\\u0007u\\u0002\\u0002\",\n    \"\\u0167l\\u0003\\u0002\\u0002\\u0002\\u0168\\u0169\\u0007o\\u0002\\u0002\\u0169\",\n    \"\\u016a\\u0007k\\u0002\\u0002\\u016a\\u016b\\u0007n\\u0002\\u0002\\u016b\\u016c\",\n    \"\\u0007n\\u0002\\u0002\\u016c\\u016d\\u0007k\\u0002\\u0002\\u016d\\u016e\\u0007\",\n    \"u\\u0002\\u0002\\u016e\\u016f\\u0007g\\u0002\\u0002\\u016f\\u0170\\u0007e\\u0002\",\n    \"\\u0002\\u0170\\u0171\\u0007q\\u0002\\u0002\\u0171\\u0172\\u0007p\\u0002\\u0002\",\n    \"\\u0172\\u0173\\u0007f\\u0002\\u0002\\u0173\\u0174\\u0007u\\u0002\\u0002\\u0174\",\n    \"n\\u0003\\u0002\\u0002\\u0002\\u0175\\u0176\\u0007B\\u0002\\u0002\\u0176\\u0177\",\n    \"\\t\\u0002\\u0002\\u0002\\u0177\\u0178\\t\\u0002\\u0002\\u0002\\u0178\\u0179\\t\\u0002\",\n    \"\\u0002\\u0002\\u0179\\u0186\\t\\u0002\\u0002\\u0002\\u017a\\u017b\\u0007/\\u0002\",\n    \"\\u0002\\u017b\\u017c\\t\\u0002\\u0002\\u0002\\u017c\\u0184\\t\\u0002\\u0002\\u0002\",\n    \"\\u017d\\u017e\\u0007/\\u0002\\u0002\\u017e\\u017f\\t\\u0002\\u0002\\u0002\\u017f\",\n    \"\\u0182\\t\\u0002\\u0002\\u0002\\u0180\\u0181\\u0007V\\u0002\\u0002\\u0181\\u0183\",\n    \"\\u0005s:\\u0002\\u0182\\u0180\\u0003\\u0002\\u0002\\u0002\\u0182\\u0183\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0183\\u0185\\u0003\\u0002\\u0002\\u0002\\u0184\\u017d\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0184\\u0185\\u0003\\u0002\\u0002\\u0002\\u0185\\u0187\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0186\\u017a\\u0003\\u0002\\u0002\\u0002\\u0186\\u0187\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0187\\u0189\\u0003\\u0002\\u0002\\u0002\\u0188\\u018a\\u0007\",\n    \"\\\\\\u0002\\u0002\\u0189\\u0188\\u0003\\u0002\\u0002\\u0002\\u0189\\u018a\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u018ap\\u0003\\u0002\\u0002\\u0002\\u018b\\u018c\\u0007\",\n    \"B\\u0002\\u0002\\u018c\\u018d\\u0007V\\u0002\\u0002\\u018d\\u018e\\u0005s:\\u0002\",\n    \"\\u018er\\u0003\\u0002\\u0002\\u0002\\u018f\\u0190\\t\\u0002\\u0002\\u0002\\u0190\",\n    \"\\u01a1\\t\\u0002\\u0002\\u0002\\u0191\\u0192\\u0007<\\u0002\\u0002\\u0192\\u0193\",\n    \"\\t\\u0002\\u0002\\u0002\\u0193\\u019f\\t\\u0002\\u0002\\u0002\\u0194\\u0195\\u0007\",\n    \"<\\u0002\\u0002\\u0195\\u0196\\t\\u0002\\u0002\\u0002\\u0196\\u019d\\t\\u0002\\u0002\",\n    \"\\u0002\\u0197\\u0199\\u00070\\u0002\\u0002\\u0198\\u019a\\t\\u0002\\u0002\\u0002\",\n    \"\\u0199\\u0198\\u0003\\u0002\\u0002\\u0002\\u019a\\u019b\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019b\\u0199\\u0003\\u0002\\u0002\\u0002\\u019b\\u019c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019c\\u019e\\u0003\\u0002\\u0002\\u0002\\u019d\\u0197\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019d\\u019e\\u0003\\u0002\\u0002\\u0002\\u019e\\u01a0\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019f\\u0194\\u0003\\u0002\\u0002\\u0002\\u019f\\u01a0\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a0\\u01a2\\u0003\\u0002\\u0002\\u0002\\u01a1\\u0191\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a1\\u01a2\\u0003\\u0002\\u0002\\u0002\\u01a2\\u01aa\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a3\\u01ab\\u0007\\\\\\u0002\\u0002\\u01a4\\u01a5\\t\\u0003\\u0002\\u0002\\u01a5\",\n    \"\\u01a6\\t\\u0002\\u0002\\u0002\\u01a6\\u01a7\\t\\u0002\\u0002\\u0002\\u01a7\\u01a8\",\n    \"\\u0007<\\u0002\\u0002\\u01a8\\u01a9\\t\\u0002\\u0002\\u0002\\u01a9\\u01ab\\t\\u0002\",\n    \"\\u0002\\u0002\\u01aa\\u01a3\\u0003\\u0002\\u0002\\u0002\\u01aa\\u01a4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01aa\\u01ab\\u0003\\u0002\\u0002\\u0002\\u01abt\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01ac\\u01ae\\t\\u0004\\u0002\\u0002\\u01ad\\u01ac\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01ae\\u01b2\\u0003\\u0002\\u0002\\u0002\\u01af\\u01b1\\t\\u0005\",\n    \"\\u0002\\u0002\\u01b0\\u01af\\u0003\\u0002\\u0002\\u0002\\u01b1\\u01b4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b2\\u01b0\\u0003\\u0002\\u0002\\u0002\\u01b2\\u01b3\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b3v\\u0003\\u0002\\u0002\\u0002\\u01b4\\u01b2\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b5\\u01ba\\u0007b\\u0002\\u0002\\u01b6\\u01b9\\u0005\\u0083\",\n    \"B\\u0002\\u01b7\\u01b9\\n\\u0006\\u0002\\u0002\\u01b8\\u01b6\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01b8\\u01b7\\u0003\\u0002\\u0002\\u0002\\u01b9\\u01bc\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01ba\\u01b8\\u0003\\u0002\\u0002\\u0002\\u01ba\\u01bb\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01bb\\u01bd\\u0003\\u0002\\u0002\\u0002\\u01bc\\u01ba\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01bd\\u01be\\u0007b\\u0002\\u0002\\u01bex\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01bf\\u01c4\\u0007)\\u0002\\u0002\\u01c0\\u01c3\\u0005\\u0083B\\u0002\\u01c1\",\n    \"\\u01c3\\n\\u0007\\u0002\\u0002\\u01c2\\u01c0\\u0003\\u0002\\u0002\\u0002\\u01c2\",\n    \"\\u01c1\\u0003\\u0002\\u0002\\u0002\\u01c3\\u01c6\\u0003\\u0002\\u0002\\u0002\\u01c4\",\n    \"\\u01c2\\u0003\\u0002\\u0002\\u0002\\u01c4\\u01c5\\u0003\\u0002\\u0002\\u0002\\u01c5\",\n    \"\\u01c7\\u0003\\u0002\\u0002\\u0002\\u01c6\\u01c4\\u0003\\u0002\\u0002\\u0002\\u01c7\",\n    \"\\u01c8\\u0007)\\u0002\\u0002\\u01c8z\\u0003\\u0002\\u0002\\u0002\\u01c9\\u01cb\",\n    \"\\t\\u0002\\u0002\\u0002\\u01ca\\u01c9\\u0003\\u0002\\u0002\\u0002\\u01cb\\u01cc\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01cc\\u01ca\\u0003\\u0002\\u0002\\u0002\\u01cc\\u01cd\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01cd\\u01d4\\u0003\\u0002\\u0002\\u0002\\u01ce\\u01d0\",\n    \"\\u00070\\u0002\\u0002\\u01cf\\u01d1\\t\\u0002\\u0002\\u0002\\u01d0\\u01cf\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d1\\u01d2\\u0003\\u0002\\u0002\\u0002\\u01d2\\u01d0\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d2\\u01d3\\u0003\\u0002\\u0002\\u0002\\u01d3\\u01d5\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d4\\u01ce\\u0003\\u0002\\u0002\\u0002\\u01d4\\u01d5\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d5|\\u0003\\u0002\\u0002\\u0002\\u01d6\\u01d8\\t\\b\\u0002\",\n    \"\\u0002\\u01d7\\u01d6\\u0003\\u0002\\u0002\\u0002\\u01d8\\u01d9\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01d9\\u01d7\\u0003\\u0002\\u0002\\u0002\\u01d9\\u01da\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01da\\u01db\\u0003\\u0002\\u0002\\u0002\\u01db\\u01dc\\b?\\u0002\\u0002\",\n    \"\\u01dc~\\u0003\\u0002\\u0002\\u0002\\u01dd\\u01de\\u00071\\u0002\\u0002\\u01de\",\n    \"\\u01df\\u0007,\\u0002\\u0002\\u01df\\u01e3\\u0003\\u0002\\u0002\\u0002\\u01e0\",\n    \"\\u01e2\\u000b\\u0002\\u0002\\u0002\\u01e1\\u01e0\\u0003\\u0002\\u0002\\u0002\\u01e2\",\n    \"\\u01e5\\u0003\\u0002\\u0002\\u0002\\u01e3\\u01e4\\u0003\\u0002\\u0002\\u0002\\u01e3\",\n    \"\\u01e1\\u0003\\u0002\\u0002\\u0002\\u01e4\\u01e6\\u0003\\u0002\\u0002\\u0002\\u01e5\",\n    \"\\u01e3\\u0003\\u0002\\u0002\\u0002\\u01e6\\u01e7\\u0007,\\u0002\\u0002\\u01e7\",\n    \"\\u01e8\\u00071\\u0002\\u0002\\u01e8\\u01e9\\u0003\\u0002\\u0002\\u0002\\u01e9\",\n    \"\\u01ea\\b@\\u0002\\u0002\\u01ea\\u0080\\u0003\\u0002\\u0002\\u0002\\u01eb\\u01ec\",\n    \"\\u00071\\u0002\\u0002\\u01ec\\u01ed\\u00071\\u0002\\u0002\\u01ed\\u01f1\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01ee\\u01f0\\n\\t\\u0002\\u0002\\u01ef\\u01ee\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f0\\u01f3\\u0003\\u0002\\u0002\\u0002\\u01f1\\u01ef\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f1\\u01f2\\u0003\\u0002\\u0002\\u0002\\u01f2\\u01f4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f3\\u01f1\\u0003\\u0002\\u0002\\u0002\\u01f4\\u01f5\\bA\\u0002\",\n    \"\\u0002\\u01f5\\u0082\\u0003\\u0002\\u0002\\u0002\\u01f6\\u01f9\\u0007^\\u0002\",\n    \"\\u0002\\u01f7\\u01fa\\t\\n\\u0002\\u0002\\u01f8\\u01fa\\u0005\\u0085C\\u0002\\u01f9\",\n    \"\\u01f7\\u0003\\u0002\\u0002\\u0002\\u01f9\\u01f8\\u0003\\u0002\\u0002\\u0002\\u01fa\",\n    \"\\u0084\\u0003\\u0002\\u0002\\u0002\\u01fb\\u01fc\\u0007w\\u0002\\u0002\\u01fc\",\n    \"\\u01fd\\u0005\\u0087D\\u0002\\u01fd\\u01fe\\u0005\\u0087D\\u0002\\u01fe\\u01ff\",\n    \"\\u0005\\u0087D\\u0002\\u01ff\\u0200\\u0005\\u0087D\\u0002\\u0200\\u0086\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0201\\u0202\\t\\u000b\\u0002\\u0002\\u0202\\u0088\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u001a\\u0002\\u0182\\u0184\\u0186\\u0189\\u019b\\u019d\\u019f\",\n    \"\\u01a1\\u01aa\\u01ad\\u01b0\\u01b2\\u01b8\\u01ba\\u01c2\\u01c4\\u01cc\\u01d2\\u01d4\",\n    \"\\u01d9\\u01e3\\u01f1\\u01f9\\u0003\\u0002\\u0003\\u0002\"].join(\"\");\n\n\nconst atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\n\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );\n\nclass FHIRPathLexer extends antlr4.Lexer {\n\n    static grammarFileName = \"FHIRPath.g4\";\n    static channelNames = [ \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\" ];\n\tstatic modeNames = [ \"DEFAULT_MODE\" ];\n\tstatic literalNames = [ null, \"'.'\", \"'['\", \"']'\", \"'+'\", \"'-'\", \"'*'\", \n                         \"'/'\", \"'div'\", \"'mod'\", \"'&'\", \"'|'\", \"'<='\", \n                         \"'<'\", \"'>'\", \"'>='\", \"'is'\", \"'as'\", \"'='\", \"'~'\", \n                         \"'!='\", \"'!~'\", \"'in'\", \"'contains'\", \"'and'\", \n                         \"'or'\", \"'xor'\", \"'implies'\", \"'('\", \"')'\", \"'{'\", \n                         \"'}'\", \"'true'\", \"'false'\", \"'%'\", \"'$this'\", \"'$index'\", \n                         \"'$total'\", \"','\", \"'year'\", \"'month'\", \"'week'\", \n                         \"'day'\", \"'hour'\", \"'minute'\", \"'second'\", \"'millisecond'\", \n                         \"'years'\", \"'months'\", \"'weeks'\", \"'days'\", \"'hours'\", \n                         \"'minutes'\", \"'seconds'\", \"'milliseconds'\" ];\n\tstatic symbolicNames = [ null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, \"DATETIME\", \n                          \"TIME\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \"STRING\", \n                          \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\" ];\n\tstatic ruleNames = [ \"T__0\", \"T__1\", \"T__2\", \"T__3\", \"T__4\", \"T__5\", \"T__6\", \n                      \"T__7\", \"T__8\", \"T__9\", \"T__10\", \"T__11\", \"T__12\", \n                      \"T__13\", \"T__14\", \"T__15\", \"T__16\", \"T__17\", \"T__18\", \n                      \"T__19\", \"T__20\", \"T__21\", \"T__22\", \"T__23\", \"T__24\", \n                      \"T__25\", \"T__26\", \"T__27\", \"T__28\", \"T__29\", \"T__30\", \n                      \"T__31\", \"T__32\", \"T__33\", \"T__34\", \"T__35\", \"T__36\", \n                      \"T__37\", \"T__38\", \"T__39\", \"T__40\", \"T__41\", \"T__42\", \n                      \"T__43\", \"T__44\", \"T__45\", \"T__46\", \"T__47\", \"T__48\", \n                      \"T__49\", \"T__50\", \"T__51\", \"T__52\", \"T__53\", \"DATETIME\", \n                      \"TIME\", \"TIMEFORMAT\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \n                      \"STRING\", \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\", \n                      \"ESC\", \"UNICODE\", \"HEX\" ];\n\n    constructor(input) {\n        super(input)\n        this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());\n    }\n\n    get atn() {\n        return atn;\n    }\n}\n\nFHIRPathLexer.EOF = antlr4.Token.EOF;\nFHIRPathLexer.T__0 = 1;\nFHIRPathLexer.T__1 = 2;\nFHIRPathLexer.T__2 = 3;\nFHIRPathLexer.T__3 = 4;\nFHIRPathLexer.T__4 = 5;\nFHIRPathLexer.T__5 = 6;\nFHIRPathLexer.T__6 = 7;\nFHIRPathLexer.T__7 = 8;\nFHIRPathLexer.T__8 = 9;\nFHIRPathLexer.T__9 = 10;\nFHIRPathLexer.T__10 = 11;\nFHIRPathLexer.T__11 = 12;\nFHIRPathLexer.T__12 = 13;\nFHIRPathLexer.T__13 = 14;\nFHIRPathLexer.T__14 = 15;\nFHIRPathLexer.T__15 = 16;\nFHIRPathLexer.T__16 = 17;\nFHIRPathLexer.T__17 = 18;\nFHIRPathLexer.T__18 = 19;\nFHIRPathLexer.T__19 = 20;\nFHIRPathLexer.T__20 = 21;\nFHIRPathLexer.T__21 = 22;\nFHIRPathLexer.T__22 = 23;\nFHIRPathLexer.T__23 = 24;\nFHIRPathLexer.T__24 = 25;\nFHIRPathLexer.T__25 = 26;\nFHIRPathLexer.T__26 = 27;\nFHIRPathLexer.T__27 = 28;\nFHIRPathLexer.T__28 = 29;\nFHIRPathLexer.T__29 = 30;\nFHIRPathLexer.T__30 = 31;\nFHIRPathLexer.T__31 = 32;\nFHIRPathLexer.T__32 = 33;\nFHIRPathLexer.T__33 = 34;\nFHIRPathLexer.T__34 = 35;\nFHIRPathLexer.T__35 = 36;\nFHIRPathLexer.T__36 = 37;\nFHIRPathLexer.T__37 = 38;\nFHIRPathLexer.T__38 = 39;\nFHIRPathLexer.T__39 = 40;\nFHIRPathLexer.T__40 = 41;\nFHIRPathLexer.T__41 = 42;\nFHIRPathLexer.T__42 = 43;\nFHIRPathLexer.T__43 = 44;\nFHIRPathLexer.T__44 = 45;\nFHIRPathLexer.T__45 = 46;\nFHIRPathLexer.T__46 = 47;\nFHIRPathLexer.T__47 = 48;\nFHIRPathLexer.T__48 = 49;\nFHIRPathLexer.T__49 = 50;\nFHIRPathLexer.T__50 = 51;\nFHIRPathLexer.T__51 = 52;\nFHIRPathLexer.T__52 = 53;\nFHIRPathLexer.T__53 = 54;\nFHIRPathLexer.DATETIME = 55;\nFHIRPathLexer.TIME = 56;\nFHIRPathLexer.IDENTIFIER = 57;\nFHIRPathLexer.DELIMITEDIDENTIFIER = 58;\nFHIRPathLexer.STRING = 59;\nFHIRPathLexer.NUMBER = 60;\nFHIRPathLexer.WS = 61;\nFHIRPathLexer.COMMENT = 62;\nFHIRPathLexer.LINE_COMMENT = 63;\n\n\n\n\nmodule.exports = FHIRPathLexer;","// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = require('../antlr4-index');\n\n// This class defines a complete listener for a parse tree produced by FHIRPathParser.\nclass FHIRPathListener extends antlr4.tree.ParseTreeListener {\n\n\t// Enter a parse tree produced by FHIRPathParser#entireExpression.\n\tenterEntireExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#entireExpression.\n\texitEntireExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#indexerExpression.\n\tenterIndexerExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#indexerExpression.\n\texitIndexerExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#polarityExpression.\n\tenterPolarityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#polarityExpression.\n\texitPolarityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#additiveExpression.\n\tenterAdditiveExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#additiveExpression.\n\texitAdditiveExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#multiplicativeExpression.\n\tenterMultiplicativeExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#multiplicativeExpression.\n\texitMultiplicativeExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#unionExpression.\n\tenterUnionExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#unionExpression.\n\texitUnionExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#orExpression.\n\tenterOrExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#orExpression.\n\texitOrExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#andExpression.\n\tenterAndExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#andExpression.\n\texitAndExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#membershipExpression.\n\tenterMembershipExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#membershipExpression.\n\texitMembershipExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#inequalityExpression.\n\tenterInequalityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#inequalityExpression.\n\texitInequalityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#invocationExpression.\n\tenterInvocationExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#invocationExpression.\n\texitInvocationExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#equalityExpression.\n\tenterEqualityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#equalityExpression.\n\texitEqualityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#impliesExpression.\n\tenterImpliesExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#impliesExpression.\n\texitImpliesExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#termExpression.\n\tenterTermExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#termExpression.\n\texitTermExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#typeExpression.\n\tenterTypeExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#typeExpression.\n\texitTypeExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#invocationTerm.\n\tenterInvocationTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#invocationTerm.\n\texitInvocationTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#literalTerm.\n\tenterLiteralTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#literalTerm.\n\texitLiteralTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#externalConstantTerm.\n\tenterExternalConstantTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#externalConstantTerm.\n\texitExternalConstantTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#parenthesizedTerm.\n\tenterParenthesizedTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#parenthesizedTerm.\n\texitParenthesizedTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#nullLiteral.\n\tenterNullLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#nullLiteral.\n\texitNullLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#booleanLiteral.\n\tenterBooleanLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#booleanLiteral.\n\texitBooleanLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#stringLiteral.\n\tenterStringLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#stringLiteral.\n\texitStringLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#numberLiteral.\n\tenterNumberLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#numberLiteral.\n\texitNumberLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#dateTimeLiteral.\n\tenterDateTimeLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#dateTimeLiteral.\n\texitDateTimeLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#timeLiteral.\n\tenterTimeLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#timeLiteral.\n\texitTimeLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#quantityLiteral.\n\tenterQuantityLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#quantityLiteral.\n\texitQuantityLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#externalConstant.\n\tenterExternalConstant(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#externalConstant.\n\texitExternalConstant(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#memberInvocation.\n\tenterMemberInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#memberInvocation.\n\texitMemberInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#functionInvocation.\n\tenterFunctionInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#functionInvocation.\n\texitFunctionInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#thisInvocation.\n\tenterThisInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#thisInvocation.\n\texitThisInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#indexInvocation.\n\tenterIndexInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#indexInvocation.\n\texitIndexInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#totalInvocation.\n\tenterTotalInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#totalInvocation.\n\texitTotalInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#functn.\n\tenterFunctn(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#functn.\n\texitFunctn(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#paramList.\n\tenterParamList(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#paramList.\n\texitParamList(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#quantity.\n\tenterQuantity(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#quantity.\n\texitQuantity(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#unit.\n\tenterUnit(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#unit.\n\texitUnit(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#dateTimePrecision.\n\tenterDateTimePrecision(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#dateTimePrecision.\n\texitDateTimePrecision(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#pluralDateTimePrecision.\n\tenterPluralDateTimePrecision(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#pluralDateTimePrecision.\n\texitPluralDateTimePrecision(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#typeSpecifier.\n\tenterTypeSpecifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#typeSpecifier.\n\texitTypeSpecifier(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#qualifiedIdentifier.\n\tenterQualifiedIdentifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#qualifiedIdentifier.\n\texitQualifiedIdentifier(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#identifier.\n\tenterIdentifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#identifier.\n\texitIdentifier(ctx) {\n\t}\n\n\n\n}\nmodule.exports = FHIRPathListener;","// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = require('../antlr4-index');\nconst FHIRPathListener = require('./FHIRPathListener');\n\nconst serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\",\n    \"\\u5964\\u0003A\\u009c\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\\u0004\\u0004\",\n    \"\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\\t\\u0007\",\n    \"\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\\f\\t\\f\",\n    \"\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\\t\\u0010\",\n    \"\\u0003\\u0002\\u0003\\u0002\\u0003\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0005\\u0003(\\n\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0007\\u0003\",\n    \"P\\n\\u0003\\f\\u0003\\u000e\\u0003S\\u000b\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\",\n    \"\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0005\\u0004\\\\\",\n    \"\\n\\u0004\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\",\n    \"\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0005\\u0005f\\n\\u0005\\u0003\\u0006\",\n    \"\\u0003\\u0006\\u0003\\u0006\\u0005\\u0006k\\n\\u0006\\u0003\\u0007\\u0003\\u0007\",\n    \"\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0005\\u0007r\\n\\u0007\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\b\\u0005\\bw\\n\\b\\u0003\\b\\u0003\\b\\u0003\\t\\u0003\\t\\u0003\\t\\u0007\",\n    \"\\t~\\n\\t\\f\\t\\u000e\\t\\u0081\\u000b\\t\\u0003\\n\\u0003\\n\\u0005\\n\\u0085\\n\\n\",\n    \"\\u0003\\u000b\\u0003\\u000b\\u0003\\u000b\\u0005\\u000b\\u008a\\n\\u000b\\u0003\",\n    \"\\f\\u0003\\f\\u0003\\r\\u0003\\r\\u0003\\u000e\\u0003\\u000e\\u0003\\u000f\\u0003\",\n    \"\\u000f\\u0003\\u000f\\u0007\\u000f\\u0095\\n\\u000f\\f\\u000f\\u000e\\u000f\\u0098\",\n    \"\\u000b\\u000f\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\\u0002\\u0003\\u0004\\u0011\",\n    \"\\u0002\\u0004\\u0006\\b\\n\\f\\u000e\\u0010\\u0012\\u0014\\u0016\\u0018\\u001a\\u001c\",\n    \"\\u001e\\u0002\\u000e\\u0003\\u0002\\u0006\\u0007\\u0003\\u0002\\b\\u000b\\u0004\",\n    \"\\u0002\\u0006\\u0007\\f\\f\\u0003\\u0002\\u000e\\u0011\\u0003\\u0002\\u0014\\u0017\",\n    \"\\u0003\\u0002\\u0018\\u0019\\u0003\\u0002\\u001b\\u001c\\u0003\\u0002\\u0012\\u0013\",\n    \"\\u0003\\u0002\\\"#\\u0003\\u0002)0\\u0003\\u000218\\u0005\\u0002\\u0012\\u0013\",\n    \"\\u0018\\u0019;<\\u0002\\u00ad\\u0002 \\u0003\\u0002\\u0002\\u0002\\u0004\\'\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0006[\\u0003\\u0002\\u0002\\u0002\\be\\u0003\\u0002\\u0002\",\n    \"\\u0002\\ng\\u0003\\u0002\\u0002\\u0002\\fq\\u0003\\u0002\\u0002\\u0002\\u000es\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0010z\\u0003\\u0002\\u0002\\u0002\\u0012\\u0082\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0014\\u0089\\u0003\\u0002\\u0002\\u0002\\u0016\\u008b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0018\\u008d\\u0003\\u0002\\u0002\\u0002\\u001a\\u008f\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u001c\\u0091\\u0003\\u0002\\u0002\\u0002\\u001e\\u0099\",\n    \"\\u0003\\u0002\\u0002\\u0002 !\\u0005\\u0004\\u0003\\u0002!\\\"\\u0007\\u0002\\u0002\",\n    \"\\u0003\\\"\\u0003\\u0003\\u0002\\u0002\\u0002#$\\b\\u0003\\u0001\\u0002$(\\u0005\",\n    \"\\u0006\\u0004\\u0002%&\\t\\u0002\\u0002\\u0002&(\\u0005\\u0004\\u0003\\r\\'#\\u0003\",\n    \"\\u0002\\u0002\\u0002\\'%\\u0003\\u0002\\u0002\\u0002(Q\\u0003\\u0002\\u0002\\u0002\",\n    \")*\\f\\f\\u0002\\u0002*+\\t\\u0003\\u0002\\u0002+P\\u0005\\u0004\\u0003\\r,-\\f\\u000b\",\n    \"\\u0002\\u0002-.\\t\\u0004\\u0002\\u0002.P\\u0005\\u0004\\u0003\\f/0\\f\\n\\u0002\",\n    \"\\u000201\\u0007\\r\\u0002\\u00021P\\u0005\\u0004\\u0003\\u000b23\\f\\t\\u0002\\u0002\",\n    \"34\\t\\u0005\\u0002\\u00024P\\u0005\\u0004\\u0003\\n56\\f\\u0007\\u0002\\u00026\",\n    \"7\\t\\u0006\\u0002\\u00027P\\u0005\\u0004\\u0003\\b89\\f\\u0006\\u0002\\u00029:\",\n    \"\\t\\u0007\\u0002\\u0002:P\\u0005\\u0004\\u0003\\u0007;<\\f\\u0005\\u0002\\u0002\",\n    \"<=\\u0007\\u001a\\u0002\\u0002=P\\u0005\\u0004\\u0003\\u0006>?\\f\\u0004\\u0002\",\n    \"\\u0002?@\\t\\b\\u0002\\u0002@P\\u0005\\u0004\\u0003\\u0005AB\\f\\u0003\\u0002\\u0002\",\n    \"BC\\u0007\\u001d\\u0002\\u0002CP\\u0005\\u0004\\u0003\\u0004DE\\f\\u000f\\u0002\",\n    \"\\u0002EF\\u0007\\u0003\\u0002\\u0002FP\\u0005\\f\\u0007\\u0002GH\\f\\u000e\\u0002\",\n    \"\\u0002HI\\u0007\\u0004\\u0002\\u0002IJ\\u0005\\u0004\\u0003\\u0002JK\\u0007\\u0005\",\n    \"\\u0002\\u0002KP\\u0003\\u0002\\u0002\\u0002LM\\f\\b\\u0002\\u0002MN\\t\\t\\u0002\",\n    \"\\u0002NP\\u0005\\u001a\\u000e\\u0002O)\\u0003\\u0002\\u0002\\u0002O,\\u0003\\u0002\",\n    \"\\u0002\\u0002O/\\u0003\\u0002\\u0002\\u0002O2\\u0003\\u0002\\u0002\\u0002O5\\u0003\",\n    \"\\u0002\\u0002\\u0002O8\\u0003\\u0002\\u0002\\u0002O;\\u0003\\u0002\\u0002\\u0002\",\n    \"O>\\u0003\\u0002\\u0002\\u0002OA\\u0003\\u0002\\u0002\\u0002OD\\u0003\\u0002\\u0002\",\n    \"\\u0002OG\\u0003\\u0002\\u0002\\u0002OL\\u0003\\u0002\\u0002\\u0002PS\\u0003\\u0002\",\n    \"\\u0002\\u0002QO\\u0003\\u0002\\u0002\\u0002QR\\u0003\\u0002\\u0002\\u0002R\\u0005\",\n    \"\\u0003\\u0002\\u0002\\u0002SQ\\u0003\\u0002\\u0002\\u0002T\\\\\\u0005\\f\\u0007\",\n    \"\\u0002U\\\\\\u0005\\b\\u0005\\u0002V\\\\\\u0005\\n\\u0006\\u0002WX\\u0007\\u001e\\u0002\",\n    \"\\u0002XY\\u0005\\u0004\\u0003\\u0002YZ\\u0007\\u001f\\u0002\\u0002Z\\\\\\u0003\",\n    \"\\u0002\\u0002\\u0002[T\\u0003\\u0002\\u0002\\u0002[U\\u0003\\u0002\\u0002\\u0002\",\n    \"[V\\u0003\\u0002\\u0002\\u0002[W\\u0003\\u0002\\u0002\\u0002\\\\\\u0007\\u0003\\u0002\",\n    \"\\u0002\\u0002]^\\u0007 \\u0002\\u0002^f\\u0007!\\u0002\\u0002_f\\t\\n\\u0002\\u0002\",\n    \"`f\\u0007=\\u0002\\u0002af\\u0007>\\u0002\\u0002bf\\u00079\\u0002\\u0002cf\\u0007\",\n    \":\\u0002\\u0002df\\u0005\\u0012\\n\\u0002e]\\u0003\\u0002\\u0002\\u0002e_\\u0003\",\n    \"\\u0002\\u0002\\u0002e`\\u0003\\u0002\\u0002\\u0002ea\\u0003\\u0002\\u0002\\u0002\",\n    \"eb\\u0003\\u0002\\u0002\\u0002ec\\u0003\\u0002\\u0002\\u0002ed\\u0003\\u0002\\u0002\",\n    \"\\u0002f\\t\\u0003\\u0002\\u0002\\u0002gj\\u0007$\\u0002\\u0002hk\\u0005\\u001e\",\n    \"\\u0010\\u0002ik\\u0007=\\u0002\\u0002jh\\u0003\\u0002\\u0002\\u0002ji\\u0003\",\n    \"\\u0002\\u0002\\u0002k\\u000b\\u0003\\u0002\\u0002\\u0002lr\\u0005\\u001e\\u0010\",\n    \"\\u0002mr\\u0005\\u000e\\b\\u0002nr\\u0007%\\u0002\\u0002or\\u0007&\\u0002\\u0002\",\n    \"pr\\u0007\\'\\u0002\\u0002ql\\u0003\\u0002\\u0002\\u0002qm\\u0003\\u0002\\u0002\",\n    \"\\u0002qn\\u0003\\u0002\\u0002\\u0002qo\\u0003\\u0002\\u0002\\u0002qp\\u0003\\u0002\",\n    \"\\u0002\\u0002r\\r\\u0003\\u0002\\u0002\\u0002st\\u0005\\u001e\\u0010\\u0002tv\",\n    \"\\u0007\\u001e\\u0002\\u0002uw\\u0005\\u0010\\t\\u0002vu\\u0003\\u0002\\u0002\\u0002\",\n    \"vw\\u0003\\u0002\\u0002\\u0002wx\\u0003\\u0002\\u0002\\u0002xy\\u0007\\u001f\\u0002\",\n    \"\\u0002y\\u000f\\u0003\\u0002\\u0002\\u0002z\\u007f\\u0005\\u0004\\u0003\\u0002\",\n    \"{|\\u0007(\\u0002\\u0002|~\\u0005\\u0004\\u0003\\u0002}{\\u0003\\u0002\\u0002\",\n    \"\\u0002~\\u0081\\u0003\\u0002\\u0002\\u0002\\u007f}\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u007f\\u0080\\u0003\\u0002\\u0002\\u0002\\u0080\\u0011\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0081\\u007f\\u0003\\u0002\\u0002\\u0002\\u0082\\u0084\\u0007>\\u0002\\u0002\",\n    \"\\u0083\\u0085\\u0005\\u0014\\u000b\\u0002\\u0084\\u0083\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0084\\u0085\\u0003\\u0002\\u0002\\u0002\\u0085\\u0013\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0086\\u008a\\u0005\\u0016\\f\\u0002\\u0087\\u008a\\u0005\\u0018\\r\\u0002\\u0088\",\n    \"\\u008a\\u0007=\\u0002\\u0002\\u0089\\u0086\\u0003\\u0002\\u0002\\u0002\\u0089\",\n    \"\\u0087\\u0003\\u0002\\u0002\\u0002\\u0089\\u0088\\u0003\\u0002\\u0002\\u0002\\u008a\",\n    \"\\u0015\\u0003\\u0002\\u0002\\u0002\\u008b\\u008c\\t\\u000b\\u0002\\u0002\\u008c\",\n    \"\\u0017\\u0003\\u0002\\u0002\\u0002\\u008d\\u008e\\t\\f\\u0002\\u0002\\u008e\\u0019\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u008f\\u0090\\u0005\\u001c\\u000f\\u0002\\u0090\\u001b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0091\\u0096\\u0005\\u001e\\u0010\\u0002\\u0092\\u0093\",\n    \"\\u0007\\u0003\\u0002\\u0002\\u0093\\u0095\\u0005\\u001e\\u0010\\u0002\\u0094\\u0092\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0095\\u0098\\u0003\\u0002\\u0002\\u0002\\u0096\\u0094\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0096\\u0097\\u0003\\u0002\\u0002\\u0002\\u0097\\u001d\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0098\\u0096\\u0003\\u0002\\u0002\\u0002\\u0099\\u009a\",\n    \"\\t\\r\\u0002\\u0002\\u009a\\u001f\\u0003\\u0002\\u0002\\u0002\\u000e\\'OQ[ejqv\",\n    \"\\u007f\\u0084\\u0089\\u0096\"].join(\"\");\n\n\nconst atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\n\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );\n\nconst sharedContextCache = new antlr4.PredictionContextCache();\n\nclass FHIRPathParser extends antlr4.Parser {\n\n    static grammarFileName = \"FHIRPath.g4\";\n    static literalNames = [ null, \"'.'\", \"'['\", \"']'\", \"'+'\", \"'-'\", \"'*'\", \n                            \"'/'\", \"'div'\", \"'mod'\", \"'&'\", \"'|'\", \"'<='\", \n                            \"'<'\", \"'>'\", \"'>='\", \"'is'\", \"'as'\", \"'='\", \n                            \"'~'\", \"'!='\", \"'!~'\", \"'in'\", \"'contains'\", \n                            \"'and'\", \"'or'\", \"'xor'\", \"'implies'\", \"'('\", \n                            \"')'\", \"'{'\", \"'}'\", \"'true'\", \"'false'\", \"'%'\", \n                            \"'$this'\", \"'$index'\", \"'$total'\", \"','\", \"'year'\", \n                            \"'month'\", \"'week'\", \"'day'\", \"'hour'\", \"'minute'\", \n                            \"'second'\", \"'millisecond'\", \"'years'\", \"'months'\", \n                            \"'weeks'\", \"'days'\", \"'hours'\", \"'minutes'\", \n                            \"'seconds'\", \"'milliseconds'\" ];\n    static symbolicNames = [ null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, \"DATETIME\", \n                             \"TIME\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \n                             \"STRING\", \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\" ];\n    static ruleNames = [ \"entireExpression\", \"expression\", \"term\", \"literal\", \n                         \"externalConstant\", \"invocation\", \"functn\", \"paramList\", \n                         \"quantity\", \"unit\", \"dateTimePrecision\", \"pluralDateTimePrecision\", \n                         \"typeSpecifier\", \"qualifiedIdentifier\", \"identifier\" ];\n\n    constructor(input) {\n        super(input);\n        this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);\n        this.ruleNames = FHIRPathParser.ruleNames;\n        this.literalNames = FHIRPathParser.literalNames;\n        this.symbolicNames = FHIRPathParser.symbolicNames;\n    }\n\n    get atn() {\n        return atn;\n    }\n\n    sempred(localctx, ruleIndex, predIndex) {\n    \tswitch(ruleIndex) {\n    \tcase 1:\n    \t    \t\treturn this.expression_sempred(localctx, predIndex);\n        default:\n            throw \"No predicate with index:\" + ruleIndex;\n       }\n    }\n\n    expression_sempred(localctx, predIndex) {\n    \tswitch(predIndex) {\n    \t\tcase 0:\n    \t\t\treturn this.precpred(this._ctx, 10);\n    \t\tcase 1:\n    \t\t\treturn this.precpred(this._ctx, 9);\n    \t\tcase 2:\n    \t\t\treturn this.precpred(this._ctx, 8);\n    \t\tcase 3:\n    \t\t\treturn this.precpred(this._ctx, 7);\n    \t\tcase 4:\n    \t\t\treturn this.precpred(this._ctx, 5);\n    \t\tcase 5:\n    \t\t\treturn this.precpred(this._ctx, 4);\n    \t\tcase 6:\n    \t\t\treturn this.precpred(this._ctx, 3);\n    \t\tcase 7:\n    \t\t\treturn this.precpred(this._ctx, 2);\n    \t\tcase 8:\n    \t\t\treturn this.precpred(this._ctx, 1);\n    \t\tcase 9:\n    \t\t\treturn this.precpred(this._ctx, 13);\n    \t\tcase 10:\n    \t\t\treturn this.precpred(this._ctx, 12);\n    \t\tcase 11:\n    \t\t\treturn this.precpred(this._ctx, 6);\n    \t\tdefault:\n    \t\t\tthrow \"No predicate with index:\" + predIndex;\n    \t}\n    };\n\n\n\n\n\tentireExpression() {\n\t    let localctx = new EntireExpressionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 0, FHIRPathParser.RULE_entireExpression);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 30;\n\t        this.expression(0);\n\t        this.state = 31;\n\t        this.match(FHIRPathParser.EOF);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\texpression(_p) {\n\t\tif(_p===undefined) {\n\t\t    _p = 0;\n\t\t}\n\t    const _parentctx = this._ctx;\n\t    const _parentState = this.state;\n\t    let localctx = new ExpressionContext(this, this._ctx, _parentState);\n\t    let _prevctx = localctx;\n\t    const _startState = 2;\n\t    this.enterRecursionRule(localctx, 2, FHIRPathParser.RULE_expression, _p);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 37;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.T__27:\n\t        case FHIRPathParser.T__29:\n\t        case FHIRPathParser.T__31:\n\t        case FHIRPathParser.T__32:\n\t        case FHIRPathParser.T__33:\n\t        case FHIRPathParser.T__34:\n\t        case FHIRPathParser.T__35:\n\t        case FHIRPathParser.T__36:\n\t        case FHIRPathParser.DATETIME:\n\t        case FHIRPathParser.TIME:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t        case FHIRPathParser.STRING:\n\t        case FHIRPathParser.NUMBER:\n\t            localctx = new TermExpressionContext(this, localctx);\n\t            this._ctx = localctx;\n\t            _prevctx = localctx;\n\n\t            this.state = 34;\n\t            this.term();\n\t            break;\n\t        case FHIRPathParser.T__3:\n\t        case FHIRPathParser.T__4:\n\t            localctx = new PolarityExpressionContext(this, localctx);\n\t            this._ctx = localctx;\n\t            _prevctx = localctx;\n\t            this.state = 35;\n\t            _la = this._input.LA(1);\n\t            if(!(_la===FHIRPathParser.T__3 || _la===FHIRPathParser.T__4)) {\n\t            this._errHandler.recoverInline(this);\n\t            }\n\t            else {\n\t            \tthis._errHandler.reportMatch(this);\n\t                this.consume();\n\t            }\n\t            this.state = 36;\n\t            this.expression(11);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t        this._ctx.stop = this._input.LT(-1);\n\t        this.state = 79;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,2,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                if(this._parseListeners!==null) {\n\t                    this.triggerExitRuleEvent();\n\t                }\n\t                _prevctx = localctx;\n\t                this.state = 77;\n\t                this._errHandler.sync(this);\n\t                var la_ = this._interp.adaptivePredict(this._input,1,this._ctx);\n\t                switch(la_) {\n\t                case 1:\n\t                    localctx = new MultiplicativeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 39;\n\t                    if (!( this.precpred(this._ctx, 10))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 10)\");\n\t                    }\n\t                    this.state = 40;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__5) | (1 << FHIRPathParser.T__6) | (1 << FHIRPathParser.T__7) | (1 << FHIRPathParser.T__8))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 41;\n\t                    this.expression(11);\n\t                    break;\n\n\t                case 2:\n\t                    localctx = new AdditiveExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 42;\n\t                    if (!( this.precpred(this._ctx, 9))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 9)\");\n\t                    }\n\t                    this.state = 43;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__3) | (1 << FHIRPathParser.T__4) | (1 << FHIRPathParser.T__9))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 44;\n\t                    this.expression(10);\n\t                    break;\n\n\t                case 3:\n\t                    localctx = new UnionExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 45;\n\t                    if (!( this.precpred(this._ctx, 8))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 8)\");\n\t                    }\n\t                    this.state = 46;\n\t                    this.match(FHIRPathParser.T__10);\n\t                    this.state = 47;\n\t                    this.expression(9);\n\t                    break;\n\n\t                case 4:\n\t                    localctx = new InequalityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 48;\n\t                    if (!( this.precpred(this._ctx, 7))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 7)\");\n\t                    }\n\t                    this.state = 49;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__11) | (1 << FHIRPathParser.T__12) | (1 << FHIRPathParser.T__13) | (1 << FHIRPathParser.T__14))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 50;\n\t                    this.expression(8);\n\t                    break;\n\n\t                case 5:\n\t                    localctx = new EqualityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 51;\n\t                    if (!( this.precpred(this._ctx, 5))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 5)\");\n\t                    }\n\t                    this.state = 52;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__17) | (1 << FHIRPathParser.T__18) | (1 << FHIRPathParser.T__19) | (1 << FHIRPathParser.T__20))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 53;\n\t                    this.expression(6);\n\t                    break;\n\n\t                case 6:\n\t                    localctx = new MembershipExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 54;\n\t                    if (!( this.precpred(this._ctx, 4))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 4)\");\n\t                    }\n\t                    this.state = 55;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__21 || _la===FHIRPathParser.T__22)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 56;\n\t                    this.expression(5);\n\t                    break;\n\n\t                case 7:\n\t                    localctx = new AndExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 57;\n\t                    if (!( this.precpred(this._ctx, 3))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 3)\");\n\t                    }\n\t                    this.state = 58;\n\t                    this.match(FHIRPathParser.T__23);\n\t                    this.state = 59;\n\t                    this.expression(4);\n\t                    break;\n\n\t                case 8:\n\t                    localctx = new OrExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 60;\n\t                    if (!( this.precpred(this._ctx, 2))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 2)\");\n\t                    }\n\t                    this.state = 61;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__24 || _la===FHIRPathParser.T__25)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 62;\n\t                    this.expression(3);\n\t                    break;\n\n\t                case 9:\n\t                    localctx = new ImpliesExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 63;\n\t                    if (!( this.precpred(this._ctx, 1))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 1)\");\n\t                    }\n\t                    this.state = 64;\n\t                    this.match(FHIRPathParser.T__26);\n\t                    this.state = 65;\n\t                    this.expression(2);\n\t                    break;\n\n\t                case 10:\n\t                    localctx = new InvocationExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 66;\n\t                    if (!( this.precpred(this._ctx, 13))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 13)\");\n\t                    }\n\t                    this.state = 67;\n\t                    this.match(FHIRPathParser.T__0);\n\t                    this.state = 68;\n\t                    this.invocation();\n\t                    break;\n\n\t                case 11:\n\t                    localctx = new IndexerExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 69;\n\t                    if (!( this.precpred(this._ctx, 12))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 12)\");\n\t                    }\n\t                    this.state = 70;\n\t                    this.match(FHIRPathParser.T__1);\n\t                    this.state = 71;\n\t                    this.expression(0);\n\t                    this.state = 72;\n\t                    this.match(FHIRPathParser.T__2);\n\t                    break;\n\n\t                case 12:\n\t                    localctx = new TypeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 74;\n\t                    if (!( this.precpred(this._ctx, 6))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 6)\");\n\t                    }\n\t                    this.state = 75;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__15 || _la===FHIRPathParser.T__16)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 76;\n\t                    this.typeSpecifier();\n\t                    break;\n\n\t                } \n\t            }\n\t            this.state = 81;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,2,this._ctx);\n\t        }\n\n\t    } catch( error) {\n\t        if(error instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = error;\n\t\t        this._errHandler.reportError(this, error);\n\t\t        this._errHandler.recover(this, error);\n\t\t    } else {\n\t\t    \tthrow error;\n\t\t    }\n\t    } finally {\n\t        this.unrollRecursionContexts(_parentctx)\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tterm() {\n\t    let localctx = new TermContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 4, FHIRPathParser.RULE_term);\n\t    try {\n\t        this.state = 89;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.T__34:\n\t        case FHIRPathParser.T__35:\n\t        case FHIRPathParser.T__36:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t            localctx = new InvocationTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 82;\n\t            this.invocation();\n\t            break;\n\t        case FHIRPathParser.T__29:\n\t        case FHIRPathParser.T__31:\n\t        case FHIRPathParser.T__32:\n\t        case FHIRPathParser.DATETIME:\n\t        case FHIRPathParser.TIME:\n\t        case FHIRPathParser.STRING:\n\t        case FHIRPathParser.NUMBER:\n\t            localctx = new LiteralTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 83;\n\t            this.literal();\n\t            break;\n\t        case FHIRPathParser.T__33:\n\t            localctx = new ExternalConstantTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 84;\n\t            this.externalConstant();\n\t            break;\n\t        case FHIRPathParser.T__27:\n\t            localctx = new ParenthesizedTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 85;\n\t            this.match(FHIRPathParser.T__27);\n\t            this.state = 86;\n\t            this.expression(0);\n\t            this.state = 87;\n\t            this.match(FHIRPathParser.T__28);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tliteral() {\n\t    let localctx = new LiteralContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 6, FHIRPathParser.RULE_literal);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.state = 99;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,4,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            localctx = new NullLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 91;\n\t            this.match(FHIRPathParser.T__29);\n\t            this.state = 92;\n\t            this.match(FHIRPathParser.T__30);\n\t            break;\n\n\t        case 2:\n\t            localctx = new BooleanLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 93;\n\t            _la = this._input.LA(1);\n\t            if(!(_la===FHIRPathParser.T__31 || _la===FHIRPathParser.T__32)) {\n\t            this._errHandler.recoverInline(this);\n\t            }\n\t            else {\n\t            \tthis._errHandler.reportMatch(this);\n\t                this.consume();\n\t            }\n\t            break;\n\n\t        case 3:\n\t            localctx = new StringLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 94;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\n\t        case 4:\n\t            localctx = new NumberLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 95;\n\t            this.match(FHIRPathParser.NUMBER);\n\t            break;\n\n\t        case 5:\n\t            localctx = new DateTimeLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 96;\n\t            this.match(FHIRPathParser.DATETIME);\n\t            break;\n\n\t        case 6:\n\t            localctx = new TimeLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 6);\n\t            this.state = 97;\n\t            this.match(FHIRPathParser.TIME);\n\t            break;\n\n\t        case 7:\n\t            localctx = new QuantityLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 7);\n\t            this.state = 98;\n\t            this.quantity();\n\t            break;\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\texternalConstant() {\n\t    let localctx = new ExternalConstantContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 8, FHIRPathParser.RULE_externalConstant);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 101;\n\t        this.match(FHIRPathParser.T__33);\n\t        this.state = 104;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t            this.state = 102;\n\t            this.identifier();\n\t            break;\n\t        case FHIRPathParser.STRING:\n\t            this.state = 103;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tinvocation() {\n\t    let localctx = new InvocationContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 10, FHIRPathParser.RULE_invocation);\n\t    try {\n\t        this.state = 111;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,6,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            localctx = new MemberInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 106;\n\t            this.identifier();\n\t            break;\n\n\t        case 2:\n\t            localctx = new FunctionInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 107;\n\t            this.functn();\n\t            break;\n\n\t        case 3:\n\t            localctx = new ThisInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 108;\n\t            this.match(FHIRPathParser.T__34);\n\t            break;\n\n\t        case 4:\n\t            localctx = new IndexInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 109;\n\t            this.match(FHIRPathParser.T__35);\n\t            break;\n\n\t        case 5:\n\t            localctx = new TotalInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 110;\n\t            this.match(FHIRPathParser.T__36);\n\t            break;\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tfunctn() {\n\t    let localctx = new FunctnContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 12, FHIRPathParser.RULE_functn);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 113;\n\t        this.identifier();\n\t        this.state = 114;\n\t        this.match(FHIRPathParser.T__27);\n\t        this.state = 116;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__3) | (1 << FHIRPathParser.T__4) | (1 << FHIRPathParser.T__15) | (1 << FHIRPathParser.T__16) | (1 << FHIRPathParser.T__21) | (1 << FHIRPathParser.T__22) | (1 << FHIRPathParser.T__27) | (1 << FHIRPathParser.T__29))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (FHIRPathParser.T__31 - 32)) | (1 << (FHIRPathParser.T__32 - 32)) | (1 << (FHIRPathParser.T__33 - 32)) | (1 << (FHIRPathParser.T__34 - 32)) | (1 << (FHIRPathParser.T__35 - 32)) | (1 << (FHIRPathParser.T__36 - 32)) | (1 << (FHIRPathParser.DATETIME - 32)) | (1 << (FHIRPathParser.TIME - 32)) | (1 << (FHIRPathParser.IDENTIFIER - 32)) | (1 << (FHIRPathParser.DELIMITEDIDENTIFIER - 32)) | (1 << (FHIRPathParser.STRING - 32)) | (1 << (FHIRPathParser.NUMBER - 32)))) !== 0)) {\n\t            this.state = 115;\n\t            this.paramList();\n\t        }\n\n\t        this.state = 118;\n\t        this.match(FHIRPathParser.T__28);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tparamList() {\n\t    let localctx = new ParamListContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 14, FHIRPathParser.RULE_paramList);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 120;\n\t        this.expression(0);\n\t        this.state = 125;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===FHIRPathParser.T__37) {\n\t            this.state = 121;\n\t            this.match(FHIRPathParser.T__37);\n\t            this.state = 122;\n\t            this.expression(0);\n\t            this.state = 127;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tquantity() {\n\t    let localctx = new QuantityContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 16, FHIRPathParser.RULE_quantity);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 128;\n\t        this.match(FHIRPathParser.NUMBER);\n\t        this.state = 130;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,9,this._ctx);\n\t        if(la_===1) {\n\t            this.state = 129;\n\t            this.unit();\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tunit() {\n\t    let localctx = new UnitContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 18, FHIRPathParser.RULE_unit);\n\t    try {\n\t        this.state = 135;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__38:\n\t        case FHIRPathParser.T__39:\n\t        case FHIRPathParser.T__40:\n\t        case FHIRPathParser.T__41:\n\t        case FHIRPathParser.T__42:\n\t        case FHIRPathParser.T__43:\n\t        case FHIRPathParser.T__44:\n\t        case FHIRPathParser.T__45:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 132;\n\t            this.dateTimePrecision();\n\t            break;\n\t        case FHIRPathParser.T__46:\n\t        case FHIRPathParser.T__47:\n\t        case FHIRPathParser.T__48:\n\t        case FHIRPathParser.T__49:\n\t        case FHIRPathParser.T__50:\n\t        case FHIRPathParser.T__51:\n\t        case FHIRPathParser.T__52:\n\t        case FHIRPathParser.T__53:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 133;\n\t            this.pluralDateTimePrecision();\n\t            break;\n\t        case FHIRPathParser.STRING:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 134;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tdateTimePrecision() {\n\t    let localctx = new DateTimePrecisionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 20, FHIRPathParser.RULE_dateTimePrecision);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 137;\n\t        _la = this._input.LA(1);\n\t        if(!(((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (FHIRPathParser.T__38 - 39)) | (1 << (FHIRPathParser.T__39 - 39)) | (1 << (FHIRPathParser.T__40 - 39)) | (1 << (FHIRPathParser.T__41 - 39)) | (1 << (FHIRPathParser.T__42 - 39)) | (1 << (FHIRPathParser.T__43 - 39)) | (1 << (FHIRPathParser.T__44 - 39)) | (1 << (FHIRPathParser.T__45 - 39)))) !== 0))) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tpluralDateTimePrecision() {\n\t    let localctx = new PluralDateTimePrecisionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 22, FHIRPathParser.RULE_pluralDateTimePrecision);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 139;\n\t        _la = this._input.LA(1);\n\t        if(!(((((_la - 47)) & ~0x1f) == 0 && ((1 << (_la - 47)) & ((1 << (FHIRPathParser.T__46 - 47)) | (1 << (FHIRPathParser.T__47 - 47)) | (1 << (FHIRPathParser.T__48 - 47)) | (1 << (FHIRPathParser.T__49 - 47)) | (1 << (FHIRPathParser.T__50 - 47)) | (1 << (FHIRPathParser.T__51 - 47)) | (1 << (FHIRPathParser.T__52 - 47)) | (1 << (FHIRPathParser.T__53 - 47)))) !== 0))) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttypeSpecifier() {\n\t    let localctx = new TypeSpecifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 24, FHIRPathParser.RULE_typeSpecifier);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 141;\n\t        this.qualifiedIdentifier();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tqualifiedIdentifier() {\n\t    let localctx = new QualifiedIdentifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 26, FHIRPathParser.RULE_qualifiedIdentifier);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 143;\n\t        this.identifier();\n\t        this.state = 148;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,11,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 144;\n\t                this.match(FHIRPathParser.T__0);\n\t                this.state = 145;\n\t                this.identifier(); \n\t            }\n\t            this.state = 150;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,11,this._ctx);\n\t        }\n\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tidentifier() {\n\t    let localctx = new IdentifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 28, FHIRPathParser.RULE_identifier);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 151;\n\t        _la = this._input.LA(1);\n\t        if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__15) | (1 << FHIRPathParser.T__16) | (1 << FHIRPathParser.T__21) | (1 << FHIRPathParser.T__22))) !== 0) || _la===FHIRPathParser.IDENTIFIER || _la===FHIRPathParser.DELIMITEDIDENTIFIER)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n}\n\nFHIRPathParser.EOF = antlr4.Token.EOF;\nFHIRPathParser.T__0 = 1;\nFHIRPathParser.T__1 = 2;\nFHIRPathParser.T__2 = 3;\nFHIRPathParser.T__3 = 4;\nFHIRPathParser.T__4 = 5;\nFHIRPathParser.T__5 = 6;\nFHIRPathParser.T__6 = 7;\nFHIRPathParser.T__7 = 8;\nFHIRPathParser.T__8 = 9;\nFHIRPathParser.T__9 = 10;\nFHIRPathParser.T__10 = 11;\nFHIRPathParser.T__11 = 12;\nFHIRPathParser.T__12 = 13;\nFHIRPathParser.T__13 = 14;\nFHIRPathParser.T__14 = 15;\nFHIRPathParser.T__15 = 16;\nFHIRPathParser.T__16 = 17;\nFHIRPathParser.T__17 = 18;\nFHIRPathParser.T__18 = 19;\nFHIRPathParser.T__19 = 20;\nFHIRPathParser.T__20 = 21;\nFHIRPathParser.T__21 = 22;\nFHIRPathParser.T__22 = 23;\nFHIRPathParser.T__23 = 24;\nFHIRPathParser.T__24 = 25;\nFHIRPathParser.T__25 = 26;\nFHIRPathParser.T__26 = 27;\nFHIRPathParser.T__27 = 28;\nFHIRPathParser.T__28 = 29;\nFHIRPathParser.T__29 = 30;\nFHIRPathParser.T__30 = 31;\nFHIRPathParser.T__31 = 32;\nFHIRPathParser.T__32 = 33;\nFHIRPathParser.T__33 = 34;\nFHIRPathParser.T__34 = 35;\nFHIRPathParser.T__35 = 36;\nFHIRPathParser.T__36 = 37;\nFHIRPathParser.T__37 = 38;\nFHIRPathParser.T__38 = 39;\nFHIRPathParser.T__39 = 40;\nFHIRPathParser.T__40 = 41;\nFHIRPathParser.T__41 = 42;\nFHIRPathParser.T__42 = 43;\nFHIRPathParser.T__43 = 44;\nFHIRPathParser.T__44 = 45;\nFHIRPathParser.T__45 = 46;\nFHIRPathParser.T__46 = 47;\nFHIRPathParser.T__47 = 48;\nFHIRPathParser.T__48 = 49;\nFHIRPathParser.T__49 = 50;\nFHIRPathParser.T__50 = 51;\nFHIRPathParser.T__51 = 52;\nFHIRPathParser.T__52 = 53;\nFHIRPathParser.T__53 = 54;\nFHIRPathParser.DATETIME = 55;\nFHIRPathParser.TIME = 56;\nFHIRPathParser.IDENTIFIER = 57;\nFHIRPathParser.DELIMITEDIDENTIFIER = 58;\nFHIRPathParser.STRING = 59;\nFHIRPathParser.NUMBER = 60;\nFHIRPathParser.WS = 61;\nFHIRPathParser.COMMENT = 62;\nFHIRPathParser.LINE_COMMENT = 63;\n\nFHIRPathParser.RULE_entireExpression = 0;\nFHIRPathParser.RULE_expression = 1;\nFHIRPathParser.RULE_term = 2;\nFHIRPathParser.RULE_literal = 3;\nFHIRPathParser.RULE_externalConstant = 4;\nFHIRPathParser.RULE_invocation = 5;\nFHIRPathParser.RULE_functn = 6;\nFHIRPathParser.RULE_paramList = 7;\nFHIRPathParser.RULE_quantity = 8;\nFHIRPathParser.RULE_unit = 9;\nFHIRPathParser.RULE_dateTimePrecision = 10;\nFHIRPathParser.RULE_pluralDateTimePrecision = 11;\nFHIRPathParser.RULE_typeSpecifier = 12;\nFHIRPathParser.RULE_qualifiedIdentifier = 13;\nFHIRPathParser.RULE_identifier = 14;\n\nclass EntireExpressionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_entireExpression;\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tEOF() {\n\t    return this.getToken(FHIRPathParser.EOF, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterEntireExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitEntireExpression(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass ExpressionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_expression;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass IndexerExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIndexerExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIndexerExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.IndexerExpressionContext = IndexerExpressionContext;\n\nclass PolarityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterPolarityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitPolarityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.PolarityExpressionContext = PolarityExpressionContext;\n\nclass AdditiveExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterAdditiveExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitAdditiveExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.AdditiveExpressionContext = AdditiveExpressionContext;\n\nclass MultiplicativeExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMultiplicativeExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMultiplicativeExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MultiplicativeExpressionContext = MultiplicativeExpressionContext;\n\nclass UnionExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterUnionExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitUnionExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.UnionExpressionContext = UnionExpressionContext;\n\nclass OrExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterOrExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitOrExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.OrExpressionContext = OrExpressionContext;\n\nclass AndExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterAndExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitAndExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.AndExpressionContext = AndExpressionContext;\n\nclass MembershipExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMembershipExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMembershipExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MembershipExpressionContext = MembershipExpressionContext;\n\nclass InequalityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInequalityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInequalityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InequalityExpressionContext = InequalityExpressionContext;\n\nclass InvocationExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tinvocation() {\n\t    return this.getTypedRuleContext(InvocationContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInvocationExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInvocationExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InvocationExpressionContext = InvocationExpressionContext;\n\nclass EqualityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterEqualityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitEqualityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.EqualityExpressionContext = EqualityExpressionContext;\n\nclass ImpliesExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterImpliesExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitImpliesExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ImpliesExpressionContext = ImpliesExpressionContext;\n\nclass TermExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tterm() {\n\t    return this.getTypedRuleContext(TermContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTermExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTermExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TermExpressionContext = TermExpressionContext;\n\nclass TypeExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\ttypeSpecifier() {\n\t    return this.getTypedRuleContext(TypeSpecifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTypeExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTypeExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TypeExpressionContext = TypeExpressionContext;\n\nclass TermContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_term;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass ExternalConstantTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texternalConstant() {\n\t    return this.getTypedRuleContext(ExternalConstantContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterExternalConstantTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitExternalConstantTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ExternalConstantTermContext = ExternalConstantTermContext;\n\nclass LiteralTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tliteral() {\n\t    return this.getTypedRuleContext(LiteralContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterLiteralTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitLiteralTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.LiteralTermContext = LiteralTermContext;\n\nclass ParenthesizedTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterParenthesizedTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitParenthesizedTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ParenthesizedTermContext = ParenthesizedTermContext;\n\nclass InvocationTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tinvocation() {\n\t    return this.getTypedRuleContext(InvocationContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInvocationTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInvocationTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InvocationTermContext = InvocationTermContext;\n\nclass LiteralContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_literal;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass TimeLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tTIME() {\n\t    return this.getToken(FHIRPathParser.TIME, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTimeLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTimeLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TimeLiteralContext = TimeLiteralContext;\n\nclass NullLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterNullLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitNullLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.NullLiteralContext = NullLiteralContext;\n\nclass DateTimeLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tDATETIME() {\n\t    return this.getToken(FHIRPathParser.DATETIME, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterDateTimeLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitDateTimeLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.DateTimeLiteralContext = DateTimeLiteralContext;\n\nclass StringLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterStringLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitStringLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.StringLiteralContext = StringLiteralContext;\n\nclass BooleanLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterBooleanLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitBooleanLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.BooleanLiteralContext = BooleanLiteralContext;\n\nclass NumberLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tNUMBER() {\n\t    return this.getToken(FHIRPathParser.NUMBER, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterNumberLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitNumberLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.NumberLiteralContext = NumberLiteralContext;\n\nclass QuantityLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tquantity() {\n\t    return this.getTypedRuleContext(QuantityContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQuantityLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQuantityLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.QuantityLiteralContext = QuantityLiteralContext;\n\nclass ExternalConstantContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_externalConstant;\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterExternalConstant(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitExternalConstant(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass InvocationContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_invocation;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass TotalInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTotalInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTotalInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TotalInvocationContext = TotalInvocationContext;\n\nclass ThisInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterThisInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitThisInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ThisInvocationContext = ThisInvocationContext;\n\nclass IndexInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIndexInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIndexInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.IndexInvocationContext = IndexInvocationContext;\n\nclass FunctionInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tfunctn() {\n\t    return this.getTypedRuleContext(FunctnContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterFunctionInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitFunctionInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.FunctionInvocationContext = FunctionInvocationContext;\n\nclass MemberInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMemberInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMemberInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MemberInvocationContext = MemberInvocationContext;\n\nclass FunctnContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_functn;\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tparamList() {\n\t    return this.getTypedRuleContext(ParamListContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterFunctn(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitFunctn(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass ParamListContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_paramList;\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterParamList(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitParamList(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass QuantityContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_quantity;\n    }\n\n\tNUMBER() {\n\t    return this.getToken(FHIRPathParser.NUMBER, 0);\n\t};\n\n\tunit() {\n\t    return this.getTypedRuleContext(UnitContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQuantity(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQuantity(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass UnitContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_unit;\n    }\n\n\tdateTimePrecision() {\n\t    return this.getTypedRuleContext(DateTimePrecisionContext,0);\n\t};\n\n\tpluralDateTimePrecision() {\n\t    return this.getTypedRuleContext(PluralDateTimePrecisionContext,0);\n\t};\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterUnit(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitUnit(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass DateTimePrecisionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_dateTimePrecision;\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterDateTimePrecision(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitDateTimePrecision(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass PluralDateTimePrecisionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_pluralDateTimePrecision;\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterPluralDateTimePrecision(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitPluralDateTimePrecision(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass TypeSpecifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_typeSpecifier;\n    }\n\n\tqualifiedIdentifier() {\n\t    return this.getTypedRuleContext(QualifiedIdentifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTypeSpecifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTypeSpecifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass QualifiedIdentifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_qualifiedIdentifier;\n    }\n\n\tidentifier = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(IdentifierContext);\n\t    } else {\n\t        return this.getTypedRuleContext(IdentifierContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQualifiedIdentifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQualifiedIdentifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass IdentifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_identifier;\n    }\n\n\tIDENTIFIER() {\n\t    return this.getToken(FHIRPathParser.IDENTIFIER, 0);\n\t};\n\n\tDELIMITEDIDENTIFIER() {\n\t    return this.getToken(FHIRPathParser.DELIMITEDIDENTIFIER, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIdentifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIdentifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\n\nFHIRPathParser.EntireExpressionContext = EntireExpressionContext; \nFHIRPathParser.ExpressionContext = ExpressionContext; \nFHIRPathParser.TermContext = TermContext; \nFHIRPathParser.LiteralContext = LiteralContext; \nFHIRPathParser.ExternalConstantContext = ExternalConstantContext; \nFHIRPathParser.InvocationContext = InvocationContext; \nFHIRPathParser.FunctnContext = FunctnContext; \nFHIRPathParser.ParamListContext = ParamListContext; \nFHIRPathParser.QuantityContext = QuantityContext; \nFHIRPathParser.UnitContext = UnitContext; \nFHIRPathParser.DateTimePrecisionContext = DateTimePrecisionContext; \nFHIRPathParser.PluralDateTimePrecisionContext = PluralDateTimePrecisionContext; \nFHIRPathParser.TypeSpecifierContext = TypeSpecifierContext; \nFHIRPathParser.QualifiedIdentifierContext = QualifiedIdentifierContext; \nFHIRPathParser.IdentifierContext = IdentifierContext; \n\nmodule.exports = FHIRPathParser;","const antlr4 = require(\"./antlr4-index\");\nconst Lexer = require(\"./generated/FHIRPathLexer\");\nconst Parser = require(\"./generated/FHIRPathParser\");\nconst Listener = require(\"./generated/FHIRPathListener\");\n\n\nclass ErrorListener extends antlr4.error.ErrorListener {\n  constructor(errors) {\n    super();\n    this.errors = errors;\n  }\n  syntaxError(rec, sym, line, col, msg, e) {\n    this.errors.push([rec, sym, line, col, msg, e]);\n  }\n}\n\nvar parse = function(path){\n  var chars = new antlr4.InputStream(path);\n  var lexer = new Lexer(chars);\n\n  var tokens  = new antlr4.CommonTokenStream(lexer);\n\n\n  var parser = new Parser(tokens);\n  parser.buildParseTrees = true;\n  var errors = [];\n  var listener = new ErrorListener(errors);\n\n  lexer.removeErrorListeners();\n  lexer.addErrorListener(listener);\n  parser.removeErrorListeners();\n  parser.addErrorListener(listener);\n\n  var tree = parser.entireExpression();\n\n  class PathListener extends Listener{\n    constructor() {\n      super();\n    }\n  }\n\n  var ast = {};\n  var node;\n  var parentStack = [ast];\n  for (let p of Object.getOwnPropertyNames(Listener.prototype)) {\n    if (p.startsWith(\"enter\")) {\n      PathListener.prototype[p] = function(ctx) {\n        let parentNode = parentStack[parentStack.length - 1];\n        let nodeType = p.slice(5); // remove \"enter\"\n        node = {type: nodeType};\n        node.text = ctx.getText();\n        if (!parentNode.children)\n          parentNode.children = [];\n        parentNode.children.push(node);\n        parentStack.push(node);\n        // Also collect this node's terminal nodes, if any.  Terminal nodes are\n        // not walked with the rest of the tree, but include things like \"+\" and\n        // \"-\", which we need.\n        node.terminalNodeText = [];\n        for (let c of ctx.children) {\n          // Test for node type \"TerminalNodeImpl\".  Minimized code no longer\n          // has the original function names, so we can't rely on\n          // c.constructor.name.  It appears the TerminalNodeImpl is the only\n          // node with a \"symbol\" property, so test for that.\n          if (c.symbol)\n            node.terminalNodeText.push(c.getText());\n        }\n      };\n    }\n    else if (p.startsWith(\"exit\")) {\n      PathListener.prototype[p] = function() {\n        parentStack.pop();\n      };\n    }\n  }\n\n  var printer = new PathListener();\n  antlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);\n\n  if (errors.length > 0) {\n    let errMsgs = [];\n    for (let i=0, len=errors.length; i<len; ++i) {\n      let err = errors[i];\n      let msg = \"line: \"+err[2]+\"; column: \"+ err[3]+\"; message: \"+err[4];\n      errMsgs.push(msg);\n    }\n    var e = new Error(errMsgs.join(\"\\n\"));\n    e.errors = errors;\n    throw e;\n  }\n  return ast;\n};\n\n\nmodule.exports = {\n  parse: parse\n};\n","// Binding the function Array.prototype.slice.call for convert Array-like objects/collections to a new Array.\nconst slice = Function.prototype.call.bind(Array.prototype.slice);\n\n// isInteger (not in IE)\n// From Mozilla docs\nNumber.isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n\nif (!String.prototype.startsWith) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(String.prototype, 'startsWith', {\n    value: function(searchString, position) {\n      position = position || 0;\n      return this.indexOf(searchString, position) === position;\n    }\n  });\n}\n\nif (!String.prototype.endsWith) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(String.prototype, 'endsWith', {\n    value: function(searchString, position) {\n      var subjectString = this.toString();\n      if (position === undefined || position > subjectString.length) {\n        position = subjectString.length;\n      }\n      position -= searchString.length;\n      var lastIndex = subjectString.indexOf(searchString, position);\n      return lastIndex !== -1 && lastIndex === position;\n    }\n  });\n}\n\nif (!String.prototype.includes) {\n  Object.defineProperty(String.prototype, 'includes', {\n    value: function() {\n      return this.indexOf.apply(this, arguments) !== -1;\n    }\n  });\n}\n\nif (!Object.assign) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(Object, 'assign', {\n    value: function(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      return slice(arguments, 1).reduce(function (to, nextSource) {\n        Object.keys(Object(nextSource)).forEach(function (nextKey) {\n          to[nextKey] = nextSource[nextKey];\n        });\n        return to;\n      },  Object(target));\n    }\n  });\n}\n\n// Define btoa for NodeJS\nif (typeof btoa === 'undefined') {\n  global.btoa = function (str) {\n    return new Buffer.from(str, 'binary').toString('base64');\n  };\n}\n\n// Define atob for NodeJS\nif (typeof atob === 'undefined') {\n  global.atob = function (b64Encoded) {\n    return new Buffer.from(b64Encoded, 'base64').toString('binary');\n  };\n}\n","// Contains the supplementary FHIRPath functions defined in the Structured Data\n// Capture IG, https://hl7.org/fhir/uv/sdc/expressions.html#fhirpath-supplements.\n\nlet engine = {};\n\n/**\n * Returns numeric values from the score extension associated with the input\n * collection of Questionnaire items. See the description of the ordinal()\n * function here:\n * https://hl7.org/fhir/uv/sdc/expressions.html#fhirpath-supplements\n * @param {Array} coll - questionnaire items\n * @return {number[]}\n */\nengine.weight = function (coll) {\n  if(coll !== false && ! coll) { return []; }\n\n  const userScoreExtUrl = this.vars.scoreExt || this.processedVars.scoreExt;\n  const checkExtUrl = userScoreExtUrl\n    ? (e) => e.url === userScoreExtUrl\n    : (e) => this.defaultScoreExts.includes(e.url);\n  const res = [];\n\n  const questionnaire = this.vars.questionnaire || this.processedVars.questionnaire?.data;\n  coll.forEach((item) => {\n    if (item?.data) {\n      const valueCoding = item.data.valueCoding;\n      let value = valueCoding;\n      if (!value) {\n        const prop = Object.keys(item.data).find(p => p.length > 5 && p.startsWith('value'));\n        // if we found a child value[x] property\n        value = prop\n          // we use it to get a score extension\n          ? item.data[prop]\n          // otherwise, if the source item has a simple data type\n          : item._data?.extension\n            // we get the extension from the adjacent property starting with\n            // an underscore\n            ? item._data\n            // otherwise we get the extension from the source item\n            // (e.g. 'item' is a Coding)\n            : item.data;\n      }\n      const score = value?.extension?.find(checkExtUrl)?.valueDecimal;\n      if (score !== undefined) {\n        // if we have a score extension in the source item, use it.\n        res.push(score);\n      } else if (valueCoding) {\n        const linkIds = getLinkIds(item.parentResNode);\n        if (linkIds.length) {\n          if (questionnaire) {\n            const qItem = getQItemByLinkIds(questionnaire, linkIds);\n            const answerOption = qItem?.answerOption?.find(o =>\n              o.valueCoding.code === valueCoding.code\n              && o.valueCoding.system === valueCoding.system\n            );\n            if (answerOption) {\n              const score = answerOption.extension?.find(checkExtUrl)?.valueDecimal;\n              if (score !== undefined) {\n                // if we have a score extension for the answerOption, use it.\n                res.push(score);\n              }\n            } else {\n              throw new Error(\n                'Questionnaire answerOption with this linkId was not found: ' +\n                item.parentResNode.data.linkId + '.');\n            }\n          } else {\n            throw new Error('%questionnaire is needed but not specified.');\n          }\n        }\n      }\n    }\n  });\n\n  return res;\n};\n\n/**\n * Returns array of linkIds of ancestor ResourceNodes and source ResourceNode\n * starting with the linkId of the given node and ending with the topmost item's\n * linkId.\n * @param {ResourceNode} node - source ResourceNode.\n * @return {String[]}\n */\nfunction getLinkIds(node) {\n  const res = [];\n\n  while (node.data?.linkId) {\n    res.push(node.data.linkId);\n    node = node.parentResNode;\n  }\n\n  return res;\n}\n\n/**\n * Returns a questionnaire item based on the linkIds array of the ancestor\n * ResourceNodes and the target ResourceNode. If the questionnaire item is not\n * found, it returns null.\n * @param {Object} questionnaire - object with a Questionnaire resource.\n * @param {string[]} linkIds - array of linkIds starting with the linkId of the\n * target node and ending with the topmost item's linkId.\n * @return {Object | null}\n */\nfunction getQItemByLinkIds(questionnaire, linkIds) {\n  let currentNode = questionnaire;\n  for(let i = linkIds.length-1; i >= 0; --i) {\n    currentNode = currentNode.item?.find(o => o.linkId === linkIds[i]);\n    if (!currentNode) {\n      return null;\n    }\n  }\n  return currentNode;\n}\n\nmodule.exports = engine;\n","const util = require(\"./utilities\");\nconst misc = require(\"./misc\");\n\nconst engine = {};\n\n// Cache for rewritten RegExp patterns\nconst cachedRegExp = {};\n\n/**\n * Rewrites RegExp pattern to support single-line mode (dotAll) in IE11:\n * To do that we replace \".\" with \"[^]\" in source RegExp pattern,\n * except where \".\" is escaped or is inside unescaped [].\n * Another way to do the same is using package regexpu-core\n * or packages regjsparser/regjsgen.\n * @param {string} pattern - source RegExp pattern\n * @return {string}\n */\nfunction rewritePatternForDotAll(pattern) {\n  if (!cachedRegExp[pattern]) {\n    cachedRegExp[pattern] = pattern.replace(/\\./g, (_, offset, entirePattern) => {\n      // The preceding part of the string\n      const precedingPart = entirePattern.substr(0, offset);\n      // The preceding part of the string without escaped characters: '\\', '[' or ']'\n      const cleanPrecedingPart = precedingPart\n        .replace(/\\\\\\\\/g, '')\n        .replace(/\\\\[\\][]/g, '');\n      // Check if '.' is escaped\n      const escaped = cleanPrecedingPart[cleanPrecedingPart.length - 1] === '\\\\';\n      // The last index of unescaped '['\n      const lastIndexOfOpenBracket = cleanPrecedingPart.lastIndexOf('[');\n      // The last index of unescaped ']'\n      const lastIndexOfCloseBracket = cleanPrecedingPart.lastIndexOf(']');\n      return escaped ||\n        (lastIndexOfOpenBracket > lastIndexOfCloseBracket)\n        ? '.'\n        : '[^]';\n    });\n  }\n\n  return cachedRegExp[pattern];\n}\n\nengine.indexOf = function (coll, substr) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.indexOf(substr);\n};\n\nengine.substring = function (coll, start, length) {\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(str) || util.isEmpty(start) || start < 0 || start >= str.length) {\n    return [];\n  }\n  if (length === undefined || util.isEmpty(length)) {\n    return str.substring(start);\n  }\n  return str.substring(start, start + length);\n};\n\nengine.startsWith = function (coll, prefix) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(prefix) || util.isEmpty(str) ? [] : str.startsWith(prefix);\n};\n\nengine.endsWith = function (coll, postfix) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(postfix) || util.isEmpty(str) ? [] : str.endsWith(postfix);\n};\n\nengine.containsFn = function (coll, substr) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.includes(substr);\n};\n\nengine.upper = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.toUpperCase();\n};\n\nengine.lower = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.toLowerCase();\n};\n\n// See https://build.fhir.org/ig/HL7/FHIRPath/#joinseparator-string-string\nengine.joinFn = function (coll, separator) {\n  const stringValues = [];\n  coll.forEach((n) => {\n    const d = util.valData(n);\n    if (typeof d === \"string\") {\n      stringValues.push(d);\n    } else if (d != null) {\n      throw new Error('Join requires a collection of strings.');\n    }\n  });\n  if (util.isEmpty(stringValues)) {\n    return [];\n  }\n  if (separator === undefined) {\n    separator = \"\";\n  }\n  return stringValues.join(separator);\n};\n\nengine.splitFn = function (coll, separator) {\n  const strToSplit = misc.singleton(coll, 'String');\n  return util.isEmpty(strToSplit) ? [] : strToSplit.split(separator);\n};\n\nengine.trimFn = function (coll) {\n  const strToTrim = misc.singleton(coll, 'String');\n  return util.isEmpty(strToTrim) ? [] : strToTrim.trim();\n};\n\n// encoding/decoding\nengine.encodeFn = function (coll, format) {\n  const strToEncode = misc.singleton(coll, 'String');\n  if (util.isEmpty(strToEncode)){\n    return [];\n  }\n  if (format === 'urlbase64' || format === 'base64url'){\n    return btoa(strToEncode).replace(/\\+/g, '-').replace(/\\//g, '_');\n  }\n  if (format === 'base64'){\n    return btoa(strToEncode);\n  }\n  if (format === 'hex'){\n    return  Array.from(strToEncode).map(c => \n      c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : \n        encodeURIComponent(c).replace(/%/g,'')\n    ).join('');\n  }\n  return [];\n};\n\nengine.decodeFn = function (coll, format) {\n  const strDecode = misc.singleton(coll, 'String');\n  if (util.isEmpty(strDecode)){\n    return [];\n  }\n  if (format === 'urlbase64' || format === 'base64url'){\n    return atob(strDecode.replace(/-/g, '+').replace(/_/g, '/'));\n  }\n  if (format === 'base64'){\n    return atob(strDecode);\n  }\n  if (format === 'hex'){\n    if (strDecode.length % 2 !== 0){\n      throw new Error('Decode \\'hex\\' requires an even number of characters.');\n    }\n    return decodeURIComponent('%' + strDecode.match(/.{2}/g).join('%'));\n  }\n  return [];\n};\n\n// Check if dotAll is supported.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll for details.\nconst dotAllIsSupported = (new RegExp('')).dotAll === false;\n\nif (dotAllIsSupported) {\n  engine.matches = function (coll, regex) {\n    const str = misc.singleton(coll, 'String');\n    if (util.isEmpty(regex) || util.isEmpty(str)) {\n      return [];\n    }\n    const reg = new RegExp(regex, 'su');\n    return reg.test(str);\n  };\n} else {\n  engine.matches = function (coll, regex) {\n    const str = misc.singleton(coll, 'String');\n    if (util.isEmpty(regex) || util.isEmpty(str)) {\n      return [];\n    }\n    const reg = new RegExp(rewritePatternForDotAll(regex), 'u');\n    return reg.test(str);\n  };\n}\n\nengine.replace = function (coll, pattern, repl) {\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(pattern) || util.isEmpty(repl) || util.isEmpty(str)) {\n    return [];\n  }\n  const reg = new RegExp(util.escapeStringForRegExp(pattern), 'g');\n  return str.replace(reg, repl);\n};\n\nengine.replaceMatches = function (coll, regex, repl) {\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(regex) || util.isEmpty(repl) || util.isEmpty(str)) {\n    return [];\n  }\n  const reg = new RegExp(regex, 'gu');\n  return str.replace(reg, repl);\n};\n\nengine.length = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.length;\n};\n\nengine.toChars = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.split('');\n};\n\nmodule.exports = engine;\n","// This file contains a class that implements the Terminology Service API.\n// See https://build.fhir.org/fhirpath.html#txapi for details.\n\nclass Terminologies {\n  constructor(terminologyUrl) {\n    this.terminologyUrl = terminologyUrl;\n    this.invocationTable = Terminologies.invocationTable;\n  }\n\n  // Same as fhirpath.invocationTable, but for %terminologies methods\n  static invocationTable = {\n    validateVS: {fn: Terminologies.validateVS,  arity: { 2: ['String', 'AnySingletonAtRoot'], 3: ['String', 'AnySingletonAtRoot', 'String']} }\n  };\n\n  /**\n   * This example function calls the Terminology Service $validate-code operation\n   * on a value set. See Terminology Service API: https://build.fhir.org/fhirpath.html#txapi\n   * The source code of this function is based on this script:\n   * https://gist.github.com/brianpos/97e1237470d76835ea9a35bf8e021ca6#file-fhirpath-async-ts\n   * @param {Terminologies[]} self - an array with one element that refers to\n   *  the current Terminology instance.\n   * @param {string} valueset - a canonical URL reference to a value set. In the original\n   *  specification this could also be an actual ValueSet, but I don't want to\n   *  complicate this example.\n   * @param {string|Object} coded - either a Coding, a CodeableConcept,\n   *  or a resource element that is a code.\n   * @param {string} [params] - a URL encoded string with other parameters for the\n   *  validate-code operation (e.g. 'date=2011-03-04&displayLanguage=en').\n   * @return {Promise<Parameters>} - a Parameters resource\n   *  (https://build.fhir.org/parameters.html) with the results of the validation\n   *  operation.\n   */\n  static validateVS(self, valueset, coded, params = '') {\n    checkParams(params);\n    const httpHeaders = {\n      \"Accept\": \"application/fhir+json; charset=utf-8\",\n    };\n    const httpPostHeaders = {\n      \"Accept\": \"application/fhir+json; charset=utf-8\",\n      \"Content-Type\": \"application/fhir+json; charset=utf-8\",\n    };\n    let myHeaders = new Headers(httpHeaders);\n\n    const requestUrl = `${self[0].terminologyUrl}/ValueSet/$validate-code`;\n\n    let response;\n    if (coded.coding) {\n      const parameters = {\n        \"resourceType\": \"Parameters\",\n        \"parameter\": [\n          {\n            \"name\": \"url\",\n            \"valueUri\": valueset\n          },\n          {\n            \"name\": \"codeableConcept\",\n            \"valueCodeableConcept\": coded\n          }\n        ]\n      };\n      myHeaders = new Headers(httpPostHeaders);\n      response = fetch(\n        requestUrl + (params ? '?' + params : ''),\n        { method: \"POST\", headers: myHeaders, body: JSON.stringify(parameters) }\n      );\n    } else if (typeof coded === \"string\") {\n      const queryParams1 = new URLSearchParams({\n        url: valueset,\n      });\n      //  Workaround for the case where we don't have a system. See discussion here:\n      //  https://chat.fhir.org/#narrow/stream/179266-fhirpath/topic/Problem.20with.20the.20.22memberOf.22.20function.20and.20R4.20servers\n      response = fetch(\n        `${self[0].terminologyUrl}/ValueSet?${queryParams1.toString() + (params ? '&' + params : '')}`,\n        {headers: myHeaders}\n      )\n        .then(r => r.json())\n        .then((bundle) => {\n          const system = bundle?.entry?.length === 1 && (\n            getSystemFromArrayItems(bundle.entry[0].resource.expansion?.contains)\n            || getSystemFromArrayItems(bundle.entry[0].resource.compose?.include)\n          );\n          if (system) {\n            const queryParams2 = new URLSearchParams({\n              url: valueset,\n              code: coded,\n              system\n            });\n            return fetch(\n              `${requestUrl}?${queryParams2.toString() + (params ? '&' + params : '')}`,\n              { headers: myHeaders }\n            );\n          } else {\n            throw new Error('The valueset does not have a single code system.');\n          }\n        });\n    } else {\n      if (coded.code) {\n        const queryParams = new URLSearchParams({\n          url: valueset ?? '',\n          system: coded.system ?? '',\n          code: coded.code\n        });\n        response = fetch(\n          `${requestUrl}?${queryParams.toString() + (params ? '&' + params : '')}`,\n          { headers: myHeaders }\n        );\n      }\n    }\n\n    // In Jest unit tests, a promise returned by 'fetch' is not an instance of\n    // Promise that we have in our application context, so we use Promise.resolve\n    // to do the conversion.\n    return Promise.resolve(response)\n      .then(r => r.json())\n      .then(params => {\n        if (params?.parameter) {\n          return params;\n        }\n        throw new Error(params);\n      })\n      .catch(() => {\n        const key = createIndexKeyMemberOf(coded, valueset);\n        throw new Error(\"Failed to check membership: \" + key);\n      });\n  }\n}\n\n/**\n * Create and returns an Index Key for the validateVS function\n * The source code of this function was borrowed from this script:\n * https://gist.github.com/brianpos/97e1237470d76835ea9a35bf8e021ca6#file-fhirpath-async-ts\n * @param {Object|string} value - either a Coding, a CodeableConcept, or\n *  a resource element that is a code.\n * @param {string} valueset - a canonical URL reference to a value set.\n * @returns {string|undefined}\n */\nfunction createIndexKeyMemberOf(value, valueset) {\n  if (typeof value === \"string\") {\n    return value + \" - \" + valueset;\n  }\n  if (value.code) {\n    return value.system + \"|\" + value.code + \" - \" + valueset;\n  }\n  if (value.coding) {\n    // return the same as for coding by joining each of the codings with a comma\n    return value.coding.map((c) => c.system + \"|\" + c.code).join(\",\") + \" - \" + valueset;\n  }\n  return undefined;\n}\n\n/**\n * Throws an exception if the params parameter is not empty and is not a valid\n * URL-encoded string.\n * @param {string|undefined} params - a URL encoded string with parameters\n *  (e.g. 'date=2011-03-04&displayLanguage=en').\n */\nfunction checkParams(params) {\n  if (params?.split('&').find(\n    p => {\n      const v = p.split('=');\n      return v.length <= 2 && v.find(x => encodeURIComponent(decodeURIComponent(x)) !== x);\n    }\n  )) {\n    throw new Error(`\"${params}\" should be a valid URL-encoded string`);\n  }\n}\n\n/**\n * Returns the \"system\" property from an array of items if it is the same for all\n * items and equal to the initial value if the initial value is defined.\n * @param {Object[]|undefined} arr - array of items\n * @param {string|undefined} [system] - optional initial value\n * @return {string|undefined}\n */\nfunction getSystemFromArrayItems(arr, system = undefined) {\n  if (arr) {\n    for (let i = 0; i < arr.length; ++i) {\n      if (!system) {\n        system = arr[i].system;\n      } else if (system !== arr[i].system) {\n        system = undefined;\n        break;\n      }\n    }\n  }\n\n  return system;\n}\n\nmodule.exports = Terminologies;\n","const addMinutes = require('date-fns/add_minutes');\nconst ucumUtils = require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance();\nconst numbers = require('./numbers');\n\nconst ucumSystemUrl = 'http://unitsofmeasure.org';\nlet timeFormat =\n  '[0-9][0-9](\\\\:[0-9][0-9](\\\\:[0-9][0-9](\\\\.[0-9]+)?)?)?(Z|(\\\\+|-)[0-9][0-9]\\\\:[0-9][0-9])?';\nlet timeRE = new RegExp('^T?'+timeFormat+'$');\nlet dateTimeRE = new RegExp(\n  '^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9](T'+timeFormat+')?)?)?Z?$');\nlet dateRE = new RegExp(\n  '^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9])?)?$');\nlet instantRE = new RegExp(\n  '^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9](T[0-9][0-9](\\\\:[0-9][0-9](\\\\:[0-9][0-9](\\\\.[0-9]+)?))(Z|(\\\\+|-)[0-9][0-9]\\\\:[0-9][0-9]))))$');\n// FHIR date/time regular expressions are slightly different.  For now, we will\n// stick with the FHIRPath regular expressions.\n//let fhirTimeRE = /([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?/;\n//let fhirDateTimeRE =\n///([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?/;\n\n/**\n *   Class FP_Type is the superclass for FHIRPath types that required special\n *   handling.\n */\nclass FP_Type {\n  /**\n   *  Tests whether this object is equal to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).  The undefined return value indicates that the values were the\n   *  same to the shared precision, but that they had differnent levels of\n   *  precision.\n   */\n  equals(/* otherObj */) {\n    return false;\n  }\n\n  /**\n   *  Tests whether this object is equivalant to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).\n   */\n  equivalentTo(/* otherObj */) {\n    return false;\n  }\n\n  toString() {\n    return this.asStr ? this.asStr : super.toString();\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  /**\n   *  Returns -1, 0, or 1 if this object is less then, equal to, or greater\n   *  than otherObj.\n   */\n  compare(/* otherObj */) {\n    throw 'Comparison not implemented for ' + this.constructor.name;\n  }\n\n  /**\n   *  Adds other value to this value.\n   */\n  plus(/* otherObj */) {\n    throw 'Addition not implemented for ' + this.constructor.name;\n  }\n\n  /**\n   * Multiplies this value by another value.\n   */\n  mul(/* otherObj */) {\n    throw 'Multiplication not implemented for ' + this.constructor.name;\n  }\n\n  /**\n   * Divides this value by another value.\n   */\n  div(/* otherObj */) {\n    throw 'Division not implemented for ' + this.constructor.name;\n  }\n}\n\n\n/**\n *  A class for Quantities.\n */\nclass FP_Quantity extends FP_Type {\n  constructor(value, unit) {\n    super();\n    this.asStr = value + ' ' + unit;\n    this.value = value;\n    this.unit = unit;\n  }\n\n  equals(otherQuantity) {\n    if (!(otherQuantity instanceof this.constructor)) {\n      return false;\n    }\n\n    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];\n\n    if (\n      !thisUnitInSeconds !== !otherUnitInSeconds &&\n      (thisUnitInSeconds > 1 || otherUnitInSeconds > 1)\n    ) {\n      // If one of the operands is a calendar duration greater than seconds and\n      // another one is not a calendar duration, return empty result\n      return null;\n    }\n\n    if (this.unit === otherQuantity.unit) {\n      return numbers.isEqual(this.value, otherQuantity.value);\n    }\n\n    // Special year/month comparison case: 1 year = 12 month\n    const compareYearsAndMonths = this._compareYearsAndMonths(otherQuantity);\n    if (compareYearsAndMonths) {\n      return compareYearsAndMonths.isEqual;\n    }\n\n    // General comparison case\n    const thisQuantity = FP_Quantity.toUcumQuantity(this.value, this.unit),\n      normalizedOtherQuantity = FP_Quantity.toUcumQuantity(otherQuantity.value, otherQuantity.unit),\n      convResult = ucumUtils.convertUnitTo(normalizedOtherQuantity.unit, normalizedOtherQuantity.value, thisQuantity.unit);\n\n    if (convResult.status !== 'succeeded') {\n      return false;\n    }\n\n    return numbers.isEqual(thisQuantity.value, convResult.toVal);\n  }\n\n  equivalentTo(otherQuantity) {\n    if (!(otherQuantity instanceof this.constructor)) {\n      return false;\n    }\n\n    if (this.unit === otherQuantity.unit) {\n      return numbers.isEquivalent(this.value, otherQuantity.value);\n    }\n\n    const ucumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(this.unit),\n      otherUcumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(otherQuantity.unit),\n      convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherQuantity.value, ucumUnitCode);\n\n    if (convResult.status !== 'succeeded') {\n      return false;\n    }\n\n    return numbers.isEquivalent(this.value, convResult.toVal);\n  }\n\n  /**\n   *  Returns a number less than 0, equal to 0 or greater than 0\n   *  if this quantity is less than, equal to, or greater than otherQuantity.\n   *  If the quantities could not be compared, returns null, which will be\n   *  converted to an empty collection in the \"doInvoke\" function\n   *  See https://hl7.org/fhirpath/#comparison\n   *  @param {FP_Quantity} otherQuantity\n   *  @return {number|null}\n   */\n  compare(otherQuantity) {\n    if (this.unit === otherQuantity.unit) {\n      return this.value - otherQuantity.value;\n    }\n\n    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];\n\n    if (\n      !thisUnitInSeconds !== !otherUnitInSeconds &&\n      (thisUnitInSeconds > 1 || otherUnitInSeconds > 1)\n    ) {\n      // If one of the operands is a calendar duration greater than seconds and\n      // another one is not a calendar duration, return empty result\n      // For example, 1 year > 1 'a' should return []\n      return null;\n    }\n\n    const ucumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(this.unit),\n      otherUcumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(otherQuantity.unit),\n      convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherQuantity.value, ucumUnitCode);\n\n    if (convResult.status !== 'succeeded') {\n      return null;\n    }\n\n    return this.value - convResult.toVal;\n  }\n\n  /**\n   *  Adds a quantity to this quantity.\n   * @param {FP_Quantity} otherQuantity a quantity to be added to this quantity.\n   * @return {FP_Quantity|null}\n   */\n  plus(otherQuantity) {\n    const thisConvFactor = FP_Quantity._yearMonthConversionFactor[this.unit];\n    const otherConvFactor = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];\n    if (thisConvFactor && otherConvFactor) {\n      // If the values are indicated in years and months, we use the conversion factor: 1 year = 12 months\n      return new FP_Quantity(this.value + otherQuantity.value * otherConvFactor / thisConvFactor, this.unit);\n    }\n\n    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];\n\n    if (\n      !thisUnitInSeconds !== !otherUnitInSeconds &&\n      (thisUnitInSeconds > 1 || otherUnitInSeconds > 1)\n    ) {\n      // If one of the operands is a calendar duration greater than seconds and\n      // another one is not a calendar duration, return empty result\n      return null;\n    }\n\n    const thisUcumUnitCode = thisUnitInSeconds ? 's' : this.unit.replace(surroundingApostrophesRegex, '');\n    const thisValue = (thisUnitInSeconds || 1) * this.value;\n\n    const otherUcumUnitCode = otherUnitInSeconds ? 's' : otherQuantity.unit.replace(surroundingApostrophesRegex, '');\n    const otherValue = (otherUnitInSeconds || 1) * otherQuantity.value;\n\n    const convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherValue, thisUcumUnitCode);\n\n    if (convResult.status !== 'succeeded'\n      || convResult.fromUnit.isSpecial_\n      || convResult.toUnit.isSpecial_) {\n      return null;\n    }\n\n    return new FP_Quantity(thisValue + convResult.toVal, thisUcumUnitCode);\n  }\n\n  /**\n   * Multiplies this quantity to another quantity.\n   * @param {FP_Quantity} otherQuantity a quantity by which to multiply this quantity.\n   * @return {FP_Quantity}\n   */\n  mul(otherQuantity) {\n    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];\n\n    if (\n      (thisUnitInSeconds > 1 && otherQuantity.unit !== \"'1'\") ||\n      (otherUnitInSeconds > 1 && this.unit !== \"'1'\")\n    ) {\n      // If one of the operands is a calendar duration greater than seconds and\n      // another one is not a number, return empty result\n      return null;\n    }\n\n    const thisQ = this.convToUcumUnits(this, thisUnitInSeconds);\n    if (!thisQ) {\n      // If the first operand is not a UCUM quantity or it has a special unit\n      return null;\n    }\n\n    const otherQ = this.convToUcumUnits(otherQuantity, otherUnitInSeconds);\n    if (!otherQ) {\n      // If the second operand is not a UCUM quantity or it has a special unit\n      return null;\n    }\n\n    // Do not use UCUM unit codes for durations in simple cases\n    if (this.unit === \"'1'\") {\n      return new FP_Quantity(this.value * otherQuantity.value, otherQuantity.unit);\n    } else if (otherQuantity.unit === \"'1'\") {\n      return new FP_Quantity(this.value * otherQuantity.value, this.unit);\n    }\n\n    return new FP_Quantity(\n      thisQ.value * otherQ.value,\n      `'(${thisQ.unit}).(${otherQ.unit})'`\n    );\n  }\n\n  /**\n   * Divides this quantity by another quantity.\n   * @param {FP_Quantity} otherQuantity a quantity by which to divide this quantity.\n   * @return {FP_Quantity}\n   */\n  div(otherQuantity) {\n    // Division by zero always gives an empty result\n    if (otherQuantity.value === 0) {\n      return null;\n    }\n\n    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];\n    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];\n\n    if (thisUnitInSeconds) {\n      if (otherUnitInSeconds) {\n        // If both operands are calendar duration quantities\n        const thisConvFactor = FP_Quantity._yearMonthConversionFactor[this.unit];\n        const otherConvFactor = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];\n        if (thisConvFactor && otherConvFactor) {\n          // If the values are indicated in years and months, we use the conversion factor: 1 year = 12 months\n          return new FP_Quantity(this.value * thisConvFactor / (otherQuantity.value * otherConvFactor), \"'1'\");\n        }\n      } else if (otherQuantity.unit === \"'1'\") {\n        // If the second operand is a number\n        return new FP_Quantity(this.value / otherQuantity.value, this.unit);\n      } else if (thisUnitInSeconds > 1) {\n        // If the first operand is a calendar duration greater than seconds\n        // and the other is not a calendar duration or number, return an empty result.\n        return null;\n      }\n    } else if (otherUnitInSeconds > 1) {\n      // If the first operands is not a calendar duration and the other is a\n      // calendar duration greater than seconds, return an empty result.\n      return null;\n    }\n\n    const thisQ = this.convToUcumUnits(this, thisUnitInSeconds);\n    if (!thisQ) {\n      // If the first operand is not a UCUM quantity or it has a special unit\n      return null;\n    }\n\n    const otherQ = this.convToUcumUnits(otherQuantity, otherUnitInSeconds);\n    if (!otherQ) {\n      // If the second operand is not a UCUM quantity or it has a special unit\n      return null;\n    }\n\n    const resultUnit = otherQ.unit === '1'\n      ? thisQ.unit\n      : `(${thisQ.unit})/(${otherQ.unit})`;\n\n    const convResult = ucumUtils.convertToBaseUnits(resultUnit, thisQ.value / otherQ.value);\n    if (convResult.status !== 'succeeded') {\n      // If the result units are unclear\n      return null;\n    }\n    return new FP_Quantity(\n      convResult.magnitude,\n      `'${Object.keys(convResult.unitToExp).map(key => key+convResult.unitToExp[key]).join('.') || \"1\"}'`\n    );\n  }\n\n  /**\n   * Converts a quantity to UCUM unit if possible, otherwise returns null.\n   * @param {FP_Quantity} quantity - source quantity.\n   * @param {number|undefined} unitInSeconds - if the source quantity is a\n   *  calendar duration then the value of the quantity unit in seconds,\n   *  otherwise undefined.\n   * @return {{unit: string, value: number} | null}\n   */\n  convToUcumUnits(quantity, unitInSeconds) {\n    if (unitInSeconds) {\n      return {\n        value: unitInSeconds * quantity.value,\n        unit: 's'\n      };\n    } else {\n      const unit = quantity.unit.replace(surroundingApostrophesRegex, '');\n      const convRes = ucumUtils.convertToBaseUnits(unit, quantity.value);\n      if (convRes.status !== 'succeeded' || convRes.fromUnitIsSpecial) {\n        // If it is not a UCUM quantity or it has a special unit\n        return null;\n      }\n      return {\n        value: convRes.magnitude,\n        unit: Object.keys(convRes.unitToExp).map(key => key+convRes.unitToExp[key]).join('.') || \"1\"\n      };\n    }\n  }\n\n  /**\n   * If both quantities have one of these units: year or month,\n   * then a special case will apply; otherwise returns null.\n   * In the special case of comparison, the fact that 1 year = 12 months is used.\n   *\n   * Just note: in general, for a calendar duration:\n   * 1 year = 365 days\n   * 12 month = 12*30 days = 360 days\n   * so, 1 year != 12 month\n   * That's why this special case is needed\n   *\n   * @param {FP_Quantity} otherQuantity\n   * @return {null|{isEqual: boolean}}\n   * @private\n   */\n  _compareYearsAndMonths(otherQuantity) {\n    const magnitude1 = FP_Quantity._yearMonthConversionFactor[this.unit],\n      magnitude2 = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];\n\n    if ( magnitude1 && magnitude2) {\n      return {\n        isEqual: numbers.isEqual(this.value*magnitude1, otherQuantity.value*magnitude2)\n      };\n    }\n\n    return null;\n  }\n\n}\n\nconst  surroundingApostrophesRegex = /^'|'$/g;\n/**\n * Converts a FHIR path unit to a UCUM unit code by converting a calendar duration keyword to an equivalent UCUM unit code\n * or removing single quotes for a UCUM unit.\n * @param {string} unit\n * @return {string}\n */\nFP_Quantity.getEquivalentUcumUnitCode = function (unit) {\n  return FP_Quantity.mapTimeUnitsToUCUMCode[unit] || unit.replace(surroundingApostrophesRegex, '');\n};\n\n/**\n * Converts FHIR path value/unit to UCUM value/unit. Usable for comparison.\n * @param {number} value\n * @param {string} unit\n * @returns { {value: number, unit: string} }\n */\nFP_Quantity.toUcumQuantity = function (value, unit) {\n  const magnitude = FP_Quantity._calendarDuration2Seconds[unit];\n  if (magnitude) {\n    return {\n      value: magnitude * value,\n      unit: 's'\n    };\n  }\n\n  return {\n    value,\n    unit: unit.replace(surroundingApostrophesRegex, '')\n  };\n};\n\n\n/**\n * Converts FHIRPath value/unit to other FHIRPath value/unit.\n * @param {string} fromUnit\n * @param {number} value\n * @param {string} toUnit\n * @return {FP_Quantity|null}\n */\nFP_Quantity.convUnitTo = function (fromUnit, value, toUnit) {\n  // 1 Year <-> 12 Months\n  const fromYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[fromUnit],\n    toYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[toUnit];\n  if (fromYearMonthMagnitude && toYearMonthMagnitude) {\n    return new FP_Quantity( fromYearMonthMagnitude*value/toYearMonthMagnitude, toUnit);\n  }\n\n  const fromMagnitude = FP_Quantity._calendarDuration2Seconds[fromUnit],\n    toMagnitude = FP_Quantity._calendarDuration2Seconds[toUnit];\n\n  // To FHIR path calendar duration\n  if (toMagnitude) {\n    if (fromMagnitude) {\n      return new FP_Quantity( fromMagnitude*value/toMagnitude, toUnit);\n    } else {\n      const convResult = ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, 's');\n\n      if (convResult.status === 'succeeded') {\n        return new FP_Quantity(convResult.toVal/toMagnitude, toUnit);\n      }\n    }\n  // To Ucum unit\n  } else {\n    const convResult = fromMagnitude ? ucumUtils.convertUnitTo('s', fromMagnitude*value, toUnit.replace(/^'|'$/g, ''))\n      : ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, toUnit.replace(/^'|'$/g, ''));\n\n    if(convResult.status === 'succeeded') {\n      return new FP_Quantity(convResult.toVal, toUnit);\n    }\n  }\n\n  return null;\n};\n\n\n// Defines conversion factors for calendar durations\nFP_Quantity._calendarDuration2Seconds = {\n  'years': 365*24*60*60,\n  'months': 30*24*60*60,\n  'weeks': 7*24*60*60,\n  'days': 24*60*60,\n  'hours': 60*60,\n  'minutes': 60,\n  'seconds': 1,\n  'milliseconds': .001,\n  'year': 365*24*60*60,\n  'month': 30*24*60*60,\n  'week': 7*24*60*60,\n  'day': 24*60*60,\n  'hour': 60*60,\n  'minute': 60,\n  'second': 1,\n  'millisecond': .001\n};\n\n// Defines special case to compare years with months for calendar durations\nFP_Quantity._yearMonthConversionFactor = {\n  'years': 12,\n  'months': 1,\n  'year': 12,\n  'month': 1\n};\n\n/**\n *  Defines a map from time units that are supported for date/time arithmetic\n *  (including some UCUM time based units) to FHIRPath time units.\n */\nFP_Quantity.dateTimeArithmeticDurationUnits = {\n  'years': \"year\",\n  'months': \"month\",\n  'weeks': \"week\",\n  'days': \"day\",\n  'hours': \"hour\",\n  'minutes': \"minute\",\n  'seconds': \"second\",\n  'milliseconds': \"millisecond\",\n  'year': \"year\",\n  'month': \"month\",\n  'week': \"week\",\n  'day': \"day\",\n  'hour': \"hour\",\n  'minute': \"minute\",\n  'second': \"second\",\n  'millisecond': \"millisecond\",\n  \"'s'\": \"second\",\n  \"'ms'\": \"millisecond\"\n};\n\n/**\n *  Defines a map from UCUM code to FHIRPath time units.\n */\nFP_Quantity.mapUCUMCodeToTimeUnits = {\n  'a': \"year\",\n  'mo': \"month\",\n  'wk': \"week\",\n  'd': \"day\",\n  'h': \"hour\",\n  'min': \"minute\",\n  's': \"second\",\n  'ms': \"millisecond\",\n};\n\n/**\n *  Defines a map from FHIRPath time units to UCUM code.\n */\nFP_Quantity.mapTimeUnitsToUCUMCode = Object.keys(FP_Quantity.mapUCUMCodeToTimeUnits)\n  .reduce(function (res, key) {\n    res[FP_Quantity.mapUCUMCodeToTimeUnits[key]] = key;\n    res[FP_Quantity.mapUCUMCodeToTimeUnits[key]+'s'] = key;\n    return res;\n  }, {});\n\nclass FP_TimeBase extends FP_Type {\n  constructor(timeStr) {\n    super();\n    this.asStr = timeStr;\n  }\n\n  /**\n   *  Adds a time-based quantity to this date/time.\n   * @param timeQuantity a quantity to be added to this date/time.  See the\n   *  FHIRPath specification for supported units.\n   */\n  plus(timeQuantity) {\n    const unit = timeQuantity.unit;\n    let timeUnit = FP_Quantity.dateTimeArithmeticDurationUnits[unit];\n    if (!timeUnit) {\n      throw new Error('For date/time arithmetic, the unit of the quantity ' +\n        'must be one of the following time-based units: ' +\n        Object.keys(FP_Quantity.dateTimeArithmeticDurationUnits));\n    }\n    const cls = this.constructor;\n    const unitPrecision = cls._timeUnitToDatePrecision[timeUnit];\n    if (unitPrecision === undefined) {\n      throw new Error('Unsupported unit for +.  The unit should be one of ' +\n        Object.keys(cls._timeUnitToDatePrecision).join(', ') + '.');\n    }\n    let qVal = timeQuantity.value;\n    const isTime = (cls === FP_Time);\n\n    // From the FHIRPath specification: \"For precisions above seconds, the\n    // decimal portion of the time-valued quantity is ignored, since date/time\n    // arithmetic above seconds is performed with calendar duration semantics.\"\n    if (isTime ? unitPrecision < 2 : unitPrecision < 5) {\n      qVal = Math.trunc(qVal);\n    }\n\n    // If the precision of the time quantity is higher than the precision of the\n    // date, we need to convert the time quantity to the precision of the date.\n    if (this._getPrecision() < unitPrecision) {\n      const neededUnit = cls._datePrecisionToTimeUnit[\n        this._getPrecision()];\n      if (neededUnit !== 'second') {\n        const newQuantity = FP_Quantity.convUnitTo(timeUnit, qVal, neededUnit);\n        timeUnit = newQuantity.unit;\n        qVal = Math.trunc(newQuantity.value);\n      }\n    }\n    const newDate = FP_TimeBase.timeUnitToAddFn[timeUnit](this._getDateObj(), qVal);\n    // newDate is a Date.  We need to make a string with the correct precision.\n    let precision = this._getPrecision();\n    if (isTime)\n      precision += 3; // based on dateTimeRE, not timeRE\n    let newDateStr = FP_DateTime.isoDateTime(newDate, precision);\n    if (isTime) {\n      // FP_Time just needs the time part of the string\n      newDateStr = newDateStr.slice(newDateStr.indexOf('T') + 1);\n    }\n\n    return new cls(newDateStr);\n  }\n\n\n  /**\n   *  Tests whether this object is equal to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).  The undefined return value indicates that the values were the\n   *  same to the shared precision, but that they had differnent levels of\n   *  precision.\n   * @param otherDateTime any sub-type of FP_TimeBase, but it should be the same\n   *  as the type of \"this\".\n   */\n  equals(otherDateTime) {\n    // From the 2019May ballot:\n    // For Date, DateTime and Time equality, the comparison is performed by\n    // considering each precision in order, beginning with years (or hours for\n    // time values), and respecting timezone offsets. If the values are the\n    // same, comparison proceeds to the next precision; if the values are\n    // different, the comparison stops and the result is false. If one input has\n    // a value for the precision and the other does not, the comparison stops\n    // and the result is empty ({ }); if neither input has a value for the\n    // precision, or the last precision has been reached, the comparison stops\n    // and the result is true.\n    // Note:  Per the spec above\n    //   2012-01 = 2012 //  empty\n    //   2012-01 = 2011 //  false\n    //   2012-01 ~ 2012 //  false\n    var rtn;\n    if (!(otherDateTime instanceof this.constructor) && !(this instanceof otherDateTime.constructor))\n      rtn = false;\n    else {\n      var thisPrec  = this._getPrecision();\n      var otherPrec = otherDateTime._getPrecision();\n\n      if (thisPrec == otherPrec) {\n        rtn = this._getDateObj().getTime() == otherDateTime._getDateObj().getTime();\n      }\n      else {\n        // The dates are not equal, but decide whether to return empty or false.\n        var commonPrec  = thisPrec <= otherPrec ? thisPrec : otherPrec;\n        // Adjust for timezone offsets, if any, so they are at a common timezone\n        var thisUTCStr  = this._getDateObj().toISOString();\n        var otherUTCStr = otherDateTime._getDateObj().toISOString();\n\n        if (this.constructor === FP_Time) {\n          commonPrec += 3; // because we now have year, month, and day\n          thisPrec += 3;\n          otherPrec += 3;\n        }\n\n        // Now parse the strings and compare the adjusted time parts.\n        // Dates without time specify no timezone and should be treated as already normalized to UTC. So we do not adjust the timezone, as this would change the date\n        var thisAdj  = thisPrec > 2 ? (new FP_DateTime(thisUTCStr))._getTimeParts() : this._getTimeParts();\n        var otherAdj = otherPrec > 2 ? (new FP_DateTime(otherUTCStr))._getTimeParts() : otherDateTime._getTimeParts();\n\n        for (var i = 0; i <= commonPrec && rtn !== false; ++i) {\n          rtn = thisAdj[i] == otherAdj[i];\n        }\n        // if rtn is still true, then return empty to indicate the difference in\n        // precision.\n        if (rtn)\n          rtn = undefined;\n      }\n    }\n    // else return undefined (empty)\n    return rtn;\n  }\n\n\n  /**\n   *  Tests whether this object is equivalant to another.  Returns either true\n   *  or false.\n   */\n  equivalentTo(otherDateTime) {\n    var rtn = otherDateTime instanceof this.constructor;\n    if (rtn) {\n      var thisPrec = this._getPrecision();\n      var otherPrec = otherDateTime._getPrecision();\n      rtn = thisPrec == otherPrec;\n      if (rtn) {\n        rtn = this._getDateObj().getTime() ==\n          otherDateTime._getDateObj().getTime();\n      }\n    }\n    return rtn;\n  }\n\n\n  /**\n   *  Returns a number less than 0, equal to 0 or greater than 0\n   *  if this (date) time is less than, equal to, or greater than otherTime.\n   *  Comparisons are made at the lesser of the two time precisions.\n   *  @param {FP_TimeBase} otherTime\n   *  @return {number}\n   */\n  compare(otherTime) {\n    var thisPrecision = this._getPrecision();\n    var otherPrecision = otherTime._getPrecision();\n    var thisTimeInt = thisPrecision <= otherPrecision ?\n      this._getDateObj().getTime(): this._dateAtPrecision(otherPrecision).getTime();\n    var otherTimeInt = otherPrecision <= thisPrecision ?\n      otherTime._getDateObj().getTime(): otherTime._dateAtPrecision(thisPrecision).getTime();\n    if (thisPrecision !== otherPrecision && thisTimeInt === otherTimeInt) {\n      return null;\n    }\n    return thisTimeInt - otherTimeInt;\n  }\n\n\n  /**\n   *  Returns a number representing the precision of the time string given to\n   *  the constructor.  (Higher means more precise).  The number is the number\n   *  of components of the time string (ignoring the time zone) produced by\n   *  matching against the time regular expression, except that milliseconds\n   *  and seconds are counted together as a single of level of precision.\n   *  @return {number}\n   */\n  _getPrecision() {\n    if (this.precision === undefined)\n      this._getMatchData();\n    return this.precision;\n  }\n\n  /**\n   *  Returns the match data from matching the given RegExp against the\n   *  date/time string given to the constructor.\n   *  Also sets this.precision.\n   * @param regEx The regular expression to match against the date/time string.\n   * @param maxPrecision the maximum precision possible for the type\n   */\n  _getMatchData(regEx, maxPrecision) {\n    if (this.timeMatchData === undefined) {\n      this.timeMatchData = this.asStr.match(regEx);\n      if (this.timeMatchData) {\n        for (let i=maxPrecision; i>=0 && this.precision === undefined; --i) {\n          if (this.timeMatchData[i])\n            this.precision = i;\n        }\n      }\n    }\n    return this.timeMatchData;\n  }\n\n  /**\n   *  Returns an array of the pieces of the given time string, for use in\n   *  constructing lower precision versions of the time. The returned array will\n   *  contain separate elements for the hour, minutes, seconds, and milliseconds\n   *  (or as many of those are as present).  The length of the returned array\n   *  will therefore be an indication of the precision.\n   *  It will not include the timezone.\n   * @timeMatchData the result of matching the time portion of the string passed\n   *  into the constructor against the \"timeRE\" regular expression.\n   */\n  _getTimeParts(timeMatchData) {\n    var timeParts = [];\n    // Finish parsing the data into pieces, for later use in building\n    // lower-precision versions of the date if needed.\n    timeParts = [timeMatchData[0]];\n    var timeZone = timeMatchData[4];\n    if (timeZone) { // remove time zone from hours\n      let hours = timeParts[0];\n      timeParts[0] = hours.slice(0, hours.length-timeZone.length);\n    }\n    var min = timeMatchData[1];\n    if (min) { // remove minutes from hours\n      let hours = timeParts[0];\n      timeParts[0] = hours.slice(0, hours.length-min.length);\n      timeParts[1] = min;\n      var sec = timeMatchData[2];\n      if (sec) { // remove seconds from minutes\n        timeParts[1] = min.slice(0, min.length-sec.length);\n        timeParts[2] = sec;\n        var ms = timeMatchData[3];\n        if (ms) { // remove milliseconds from seconds\n          timeParts[2] = sec.slice(0, sec.length-ms.length);\n          timeParts[3] = ms;\n        }\n      }\n    }\n    return timeParts;\n  }\n\n\n  /**\n   *  Returns a date object representing this time on a certain date.\n   */\n  _getDateObj() {\n    if (!this.dateObj) {\n      var precision = this._getPrecision();\n      // We cannot directly pass the string into the date constructor because\n      // (1) we don't want to introduce a time-dependent system date and (2) the\n      // time string might not have contained minutes, which are required by the\n      // Date constructor.\n      this.dateObj = this._dateAtPrecision(precision);\n    }\n    return this.dateObj;\n  }\n\n\n  /**\n   *  Creates a date object for the given timezone.  The returned date object\n   *  will have the specified date and time in the specified timezone.\n   * @param year...ms Just as in the Date constructor.\n   * @param timezoneOffset (optional) a string in the format (+-)HH:mm or Z, representing the\n   *  timezone offset.  If not provided, the local timzone will be assumed (as the\n   *  Date constructor does).\n   */\n  _createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset) {\n    var d = new Date(year, month, day, hour, minutes, seconds, ms);\n    if (timezoneOffset) {\n      // d is in local time.  Adjust for the timezone offset.\n      // First adjust the date by the timezone offset before reducing its\n      // precision.  Otherwise,\n      // @2018-11-01T-04:00 < @2018T-05:00\n      var localTimezoneMinutes = d.getTimezoneOffset();\n      var timezoneMinutes = 0; // if Z\n      if (timezoneOffset != 'Z') {\n        var timezoneParts = timezoneOffset.split(':'); // (+-)hours:minutes\n        var hours = parseInt(timezoneParts[0]);\n        timezoneMinutes = parseInt(timezoneParts[1]);\n        if (hours < 0)\n          timezoneMinutes = -timezoneMinutes;\n        timezoneMinutes += 60*hours;\n      }\n      // localTimezoneMinutes has the inverse sign of its timezone offset\n      d = addMinutes(d, -localTimezoneMinutes-timezoneMinutes);\n    }\n    return d;\n  }\n}\n\n/**\n *  A map from a FHIRPath time units to a function used to add that\n *  quantity to a date/time.\n */\nFP_TimeBase.timeUnitToAddFn = {\n  \"year\": require('date-fns/add_years'),\n  \"month\": require('date-fns/add_months'),\n  \"week\": require('date-fns/add_weeks'),\n  \"day\": require('date-fns/add_days'),\n  \"hour\": require('date-fns/add_hours'),\n  \"minute\": require('date-fns/add_minutes'),\n  \"second\": require('date-fns/add_seconds'),\n  \"millisecond\": require('date-fns/add_milliseconds')\n};\n\n\nclass FP_DateTime extends FP_TimeBase {\n  /**\n   *  Constructs an FP_DateTime, assuming dateStr is valid.  If you don't know\n   *  whether a string is a valid DateTime, use FP_DateTime.checkString instead.\n   */\n  constructor(dateStr) {\n    super(dateStr);\n  }\n\n\n  /**\n   *  Returns -1, 0, or 1 if this date time is less then, equal to, or greater\n   *  than otherDateTime.  Comparisons are made at the lesser of the two date time\n   *  precisions.\n   */\n  compare(otherDateTime) {\n    if (!(otherDateTime instanceof FP_DateTime))\n      throw 'Invalid comparison of a DateTime with something else';\n    return super.compare(otherDateTime);\n  }\n\n\n  /**\n   *  Returns the match data from matching dateTimeRE against the datetime string.\n   *  Also sets this.precision.\n   */\n  _getMatchData() {\n    return super._getMatchData(dateTimeRE, 5);\n  }\n\n  /**\n   *  Returns an array of the pieces of the date time string passed into the\n   *  constructor, for use in constructing lower precision versions of the\n   *  date time. The returned array will contain separate elements for the year,\n   *  month, day, hour, minutes, seconds, and milliseconds (or as many of those\n   *  are as present).  The length of the returned array will therefore be an\n   *  indication of the precision.  It will not include the timezone.\n   */\n  _getTimeParts() {\n    if (!this.timeParts) {\n      let timeMatchData =  this._getMatchData();\n      let year = timeMatchData[0];\n      this.timeParts = [year];\n      var month = timeMatchData[1];\n      if (month) { // Remove other information from year\n        this.timeParts[0] = year.slice(0, year.length-month.length);\n        this.timeParts[1] = month;\n        let day = timeMatchData[2];\n        if (day) { // Remove day information from month\n          this.timeParts[1] = month.slice(0, month.length-day.length);\n          this.timeParts[2] = day;\n          let time = timeMatchData[3];\n          if (time) { // Remove time from day\n            this.timeParts[2] = day.slice(0, day.length-time.length);\n            if (time[0] === 'T') // remove T from hour\n              timeMatchData[3] = time.slice(1);\n            this.timeParts = this.timeParts.concat(\n              super._getTimeParts(timeMatchData.slice(3)));\n          }\n        }\n      }\n    }\n    return this.timeParts;\n  }\n\n\n  /**\n   *  Returns a new Date object for a time equal to what this time would be if\n   *  the string passed into the constructor had the given precision.\n   * @param precision the new precision, which is assumed to be less than\n   *  or equal to the current precision.\n   */\n  _dateAtPrecision(precision) {\n    var timeParts = this._getTimeParts();\n    var timezoneOffset = this._getMatchData()[7];\n    // Get the date object first at the current precision.\n    var thisPrecision = this._getPrecision();\n    var year = parseInt(timeParts[0]);\n    var month = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)) - 1 : 0;\n    var day = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)) : 1;\n    var hour = thisPrecision > 2 ? parseInt(timeParts[3]) : 0;\n    var minutes = thisPrecision > 3 ? parseInt(timeParts[4].slice(1)): 0;\n    var seconds = thisPrecision > 4 ? parseInt(timeParts[5].slice(1)): 0;\n    var ms = timeParts.length > 6 ? parseInt(timeParts[6].slice(1)): 0;\n    var d = this._createDate(year, month, day, hour, minutes, seconds, ms,\n      timezoneOffset);\n    if (precision < thisPrecision) {\n      // Adjust the precision\n      year = d.getFullYear();\n      month = precision > 0 ? d.getMonth() : 0;\n      day = precision > 1 ? d.getDate() : 1;\n      hour = precision > 2 ? d.getHours() : 0;\n      minutes = precision > 3 ? d.getMinutes(): 0;\n      // Here the precision will always be less than the maximum\n      // due to the condition in the if statement: \"precision < thisPrecision\"\n      d = new Date(year, month, day, hour, minutes);\n    }\n    return d;\n  }\n}\n\n/**\n *  Tests str to see if it is convertible to a DateTime.\n * @return If str is convertible to a DateTime, returns an FP_DateTime;\n *  otherwise returns null.\n */\nFP_DateTime.checkString = function(str) {\n  let d = new FP_DateTime(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n/**\n *  A map from FHIRPath time units to the internal DateTime \"precision\" number.\n */\nFP_DateTime._timeUnitToDatePrecision = {\n  \"year\": 0,\n  \"month\": 1,\n  \"week\": 2, // wk is just 7*d\n  \"day\": 2,\n  \"hour\": 3,\n  \"minute\": 4,\n  \"second\": 5,\n  \"millisecond\": 6\n};\n\n/**\n *  The inverse of _timeUnitToDatePrecision.\n */\nFP_DateTime._datePrecisionToTimeUnit = [\n  \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"\n];\n\n\n\nclass FP_Time extends FP_TimeBase {\n  /**\n   *  Constructs an FP_Time, assuming dateStr is valid.  If you don't know\n   *  whether a string is a valid DateTime, use FP_Time.checkString instead.\n   */\n  constructor(timeStr) {\n    if (timeStr[0] == 'T')\n      timeStr = timeStr.slice(1);\n    super(timeStr);\n  }\n\n\n  /**\n   *  Returns -1, 0, or 1 if this time is less then, equal to, or greater\n   *  than otherTime.  Comparisons are made at the lesser of the two time\n   *  precisions.\n   */\n  compare(otherTime) {\n    if (!(otherTime instanceof FP_Time))\n      throw 'Invalid comparison of a time with something else';\n    return super.compare(otherTime);\n  }\n\n\n  /**\n   *  Returns a new Date object for a time equal to what this time would be if\n   *  the string passed into the constructor had the given precision.\n   *  The \"date\" portion of the returned Date object is not meaningful, and\n   *  should be ignored.\n   * @param precision the new precision, which is assumed to be less than the\n   *  or equal to the current precision.  A precision of 0 means the hour.\n   */\n  _dateAtPrecision(precision) {\n    var timeParts = this._getTimeParts();\n    var timezoneOffset = this._getMatchData()[4];\n    // Get the date object first at the current precision.\n    var thisPrecision = this._getPrecision();\n    var year = 2010; // Have to pick some year for the date object\n    var month = 0;\n    var day = 1;\n    var hour = parseInt(timeParts[0]);\n    var minutes = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)): 0;\n    var seconds = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)): 0;\n    var ms = timeParts.length > 3 ? parseInt(timeParts[3].slice(1)): 0;\n    var d = this._createDate(year, month, day, hour, minutes, seconds, ms,\n      timezoneOffset);\n    if (timezoneOffset) {\n      // Keep the date the same (in the local timezone), so it is not a relevant\n      // factor when comparing different times.\n      d.setYear(year);\n      d.setMonth(month);\n      d.setDate(day);\n    }\n    if (precision < thisPrecision) {\n      // Adjust the precision\n      hour = d.getHours();\n      minutes = precision > 0 ? d.getMinutes(): 0;\n      // Here the precision will always be less than the maximum\n      // due to the condition in the if statement: \"precision < thisPrecision\"\n      d = new Date(year, month, day, hour, minutes);\n    }\n    return d;\n  }\n\n\n  /**\n   *  Returns the match data from matching timeRE against the time string.\n   *  Also sets this.precision.\n   */\n  _getMatchData() {\n    return super._getMatchData(timeRE, 2);\n  }\n\n  /**\n   *  Returns an array of the pieces of the time string passed into the\n   *  constructor, for use in constructing lower precision versions of the\n   *  time. The returned array will contain separate elements for the hour,\n   *  minutes, seconds, and milliseconds (or as many of those are as present).\n   *  The length of the returned array will therefore be an indication of the\n   *  precision.  It will not include the timezone.\n   */\n  _getTimeParts() {\n    if (!this.timeParts) {\n      this.timeParts = super._getTimeParts(this._getMatchData());\n    }\n    return this.timeParts;\n  }\n}\n\n/**\n *  Tests str to see if it is convertible to a Time.\n * @return If str is convertible to a Time, returns an FP_Time;\n *  otherwise returns null.\n */\nFP_Time.checkString = function(str) {\n  let d = new FP_Time(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n/**\n *  A map from FHIRPath time units to the internal DateTime \"precision\" number.\n */\nFP_Time._timeUnitToDatePrecision = {\n  \"hour\": 0,\n  \"minute\": 1,\n  \"second\": 2,\n  \"millisecond\": 3\n};\n\n/**\n *  The inverse of _timeUnitToDatePrecision.\n */\nFP_Time._datePrecisionToTimeUnit = [\"hour\", \"minute\", \"second\", \"millisecond\"];\n\n\n/**\n *  Returns either the given number or a string with the number prefixed by\n *  zeros if the given number is less than the given length.\n * @param num the nubmer to format\n * @param len the number of returned digits.  For now this must either be 2 or\n *  3. (Optional-- default is 2).\n */\nfunction formatNum(num, len) {\n  // Could use String.repeat, but that requires convertin num to an string first\n  // to get its length.  This might be slightly faster given that we only need 2\n  // or three 3 digit return values.\n  var rtn = num;\n  if (len === 3 && num < 100)\n    rtn = '0' + num;\n  if (num < 10)\n    rtn = '0' + rtn;\n  return rtn;\n}\n\n\n/**\n *  Formats the given date object into an ISO8601 datetime string, expressing it\n *  in the local timezone.\n * @date the date to format\n * @precision the precision at which to terminate string string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  dateTimeRE.\n * @return a string in ISO8601 format.\n */\nFP_DateTime.isoDateTime = function(date, precision) {\n  if (precision === undefined)\n    precision = 5; // maximum\n  // YYYY-MM-DDTHH:mm:ss.sss[+-]HH:mm\n  // Note:  Date.toISOString sets the timezone at 'Z', which I did not want.\n  // Actually, I wanted to keep the original timezone given in the constructor,\n  // but that is difficult due to daylight savings time changes.  (For instance,\n  // if you add 6 months, the timezone offset could change).\n  var rtn = '' + date.getFullYear();\n  if (precision > 0) {\n    rtn += '-' + formatNum(date.getMonth() + 1);\n    if (precision > 1) {\n      rtn += '-' + formatNum(date.getDate());\n      if (precision > 2) {\n        rtn += 'T' + FP_DateTime.isoTime(date, precision - 3);\n      }\n    }\n  }\n  // FHIRPath STU1 does not allow a timezone offset on a dateTime that does not\n  // have a time part (except that the grammar allows 'Z', which is\n  // inconsistent).\n  if (precision > 2) {\n    // Note:  getTimezoneoffset returns the offset for the local system at the\n    // given date.\n    var tzOffset = date.getTimezoneOffset();\n    // tzOffset is a number of minutes, and is positive for negative timezones,\n    // and negative for positive timezones.\n    var tzSign = tzOffset < 0 ? '+' : '-';\n    tzOffset = Math.abs(tzOffset);\n    var tzMin = tzOffset % 60;\n    var tzHour = (tzOffset - tzMin) / 60;\n    rtn += tzSign + formatNum(tzHour) + ':' + formatNum(tzMin);\n  }\n  return rtn;\n};\n\n\n/**\n *  Returns a time string in ISO format at the given precision level.\n * @date the date to format\n * @precision the precision at which to terminate string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  timeRE.\n * @return a string in ISO 8601 format.\n */\nFP_DateTime.isoTime = function(date, precision) {\n  if (precision === undefined)\n    precision = 2; // maximum\n\n  let rtn = '' + formatNum(date.getHours());\n  if (precision > 0) {\n    rtn += ':' + formatNum(date.getMinutes());\n    if (precision > 1) {\n      rtn += ':' + formatNum(date.getSeconds() );\n      if (date.getMilliseconds())\n        rtn += '.' + formatNum(date.getMilliseconds(), 3);\n    }\n  }\n  return rtn;\n};\n\n\nclass FP_Date extends FP_DateTime {\n  /**\n   * Constructs an FP_Date, assuming dateStr is valid.  If you don't know\n   * whether a string is a valid Date, use FP_Date.checkString instead.\n   */\n  constructor(dateStr) {\n    super(dateStr);\n  }\n\n\n  /**\n   * Returns the match data from matching dateRE against the date string.\n   * Also sets this.precision.\n   */\n  _getMatchData() {\n    return FP_TimeBase.prototype._getMatchData.apply(this, [dateRE, 2]);\n  }\n}\n\n\n/**\n * Tests str to see if it is convertible to a Date.\n * @return If str is convertible to a Date, returns an FP_Date;\n *  otherwise returns null.\n */\nFP_Date.checkString = function(str) {\n  let d = new FP_Date(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n\n/**\n * Returns a date string in ISO format at the given precision level.\n * @date the date to format\n * @precision the precision at which to terminate string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  dateTimeRE.\n * @return a string in ISO8601 format.\n */\nFP_Date.isoDate = function(date, precision) {\n  if (precision === undefined || precision > 2)\n    precision = 2;\n  return FP_DateTime.isoDateTime(date, precision);\n};\n\nclass FP_Instant extends FP_DateTime {\n  /**\n   * Constructs an FP_Instant, assuming instantStr is valid.  If you don't know\n   * whether a string is a valid \"instant\", use FP_Instant.checkString instead.\n   */\n  constructor(instantStr) {\n    super(instantStr);\n  }\n\n\n  /**\n   * Returns the match data from matching instantRE against the \"instant\" string.\n   * Also sets this.precision.\n   */\n  _getMatchData() {\n    return FP_TimeBase.prototype._getMatchData.apply(this, [instantRE, 5]);\n  }\n}\n\n\n/**\n * Tests str to see if it is convertible to an \"instant\".\n * @return If str match the \"instant\" RegExp, returns an FP_Instant;\n *  otherwise returns null.\n */\nFP_Instant.checkString = function(str) {\n  let d = new FP_Instant(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n/**\n *  A class that represents a node in a FHIR resource, with path and possibly type\n *  information.\n */\nclass ResourceNode {\n  /**\n   *  Constructs a instance for the given node (\"data\") of a resource.  If the\n   *  data is the top-level node of a resouce, the path and type parameters will\n   *  be ignored in favor of the resource's resourceType field.\n   * @param {*} data - the node's data or value (which might be an object with\n   *  sub-nodes, an array, or FHIR data type)\n   * @param {ResourceNode} parentResNode - parent ResourceNode.\n   * @param {string} path - the node's path in the resource (e.g. Patient.name).\n   *  If the data's type can be determined from data, that will take precedence\n   *  over this parameter.\n   * @param {*} _data - additional data stored in a property named with \"_\"\n   *  prepended, see https://www.hl7.org/fhir/element.html#json for details.\n   * @param {string} fhirNodeDataType - FHIR node data type, if the resource node\n   *  is described in the FHIR model.\n   */\n  constructor(data, parentResNode, path, _data, fhirNodeDataType) {\n    // If data is a resource (maybe a contained resource) reset the path\n    // information to the resource type.\n    if (data?.resourceType) {\n      path = data.resourceType;\n      fhirNodeDataType = data.resourceType;\n    }\n    this.parentResNode = parentResNode || null;\n    this.path = path || null;\n    this.data = data;\n    this._data = _data || {};\n    this.fhirNodeDataType = fhirNodeDataType || null;\n  }\n\n  /**\n   * Returns resource node type info.\n   * @return {TypeInfo}\n   */\n  getTypeInfo() {\n    if (!this.typeInfo) {\n      let typeInfo;\n\n      if (TypeInfo.model) {\n        if (/^System\\.(.*)$/.test(this.fhirNodeDataType)) {\n          typeInfo = new TypeInfo({namespace: TypeInfo.System, name: RegExp.$1});\n        } else if (this.fhirNodeDataType) {\n          typeInfo = new TypeInfo({\n            namespace: TypeInfo.FHIR,\n            name: this.fhirNodeDataType\n          });\n        }\n      }\n\n      this.typeInfo = typeInfo\n        // Resource object properties that are not defined in the model now have\n        // System.* data types:\n        || TypeInfo.createByValueInSystemNamespace(this.data);\n    }\n    return this.typeInfo;\n  }\n\n  toJSON() {\n    return JSON.stringify(this.data);\n  }\n\n  /**\n   * Converts a resource node value to an instance of the FHIRPath system type\n   * (FP_Quantity, FP_Date, FP_DateTime, or FP_Time) for use in evaluating\n   * a FHIRPath expression if the node path matches the specified type in the\n   * model and when conversion is possible, otherwise returns the data as is.\n   * Throws an exception if the data is a Quantity that has a comparator.\n   * The Mapping from FHIR Quantity to FHIRPath System.Quantity is explained here:\n   * https://www.hl7.org/fhir/fhirpath.html#quantity\n   * this.data is not changed, but converted value is returned.\n   * @return {FP_Type|any}\n   */\n  convertData() {\n    if (!this.convertedData) {\n      var data = this.data;\n      const cls = TypeInfo.typeToClassWithCheckString[this.path];\n      if (cls) {\n        data = cls.checkString(data) || data;\n      } else if (TypeInfo.isType(this.path, 'Quantity')) {\n        if (data?.system === ucumSystemUrl) {\n          if (typeof data.value === 'number' && typeof data.code === 'string') {\n            if (data.comparator !== undefined)\n              throw new Error('Cannot convert a FHIR.Quantity that has a comparator');\n            data = new FP_Quantity(\n              data.value,\n              FP_Quantity.mapUCUMCodeToTimeUnits[data.code] || '\\'' + data.code + '\\''\n            );\n          }\n        }\n      }\n\n      this.convertedData = data;\n    }\n    return this.convertedData;\n  }\n\n}\n\n\n/**\n *  Returns a ResourceNode for the given data node, checking first to see if the\n *  given node is already a ResourceNode.  Takes the same arguments as the\n *  constructor for ResourceNode.\n */\nResourceNode.makeResNode = function(data, parentResNode, path, _data, fhirNodeDataType = null) {\n  return (data instanceof ResourceNode) ? data : new ResourceNode(data, parentResNode, path, _data, fhirNodeDataType);\n};\n\n// The set of available data types in the System namespace\nconst availableSystemTypes = new Set();\n// IE11 probably doesn't support `new Set(iterable)`\n['Boolean', 'String', 'Integer', 'Decimal', 'Date', 'DateTime', 'Time', 'Quantity'].forEach(i => availableSystemTypes.add(i));\n\n/**\n * Object class defining type information.\n * Used for minimal type support.\n * (see http://hl7.org/fhirpath/#types-and-reflection)\n */\nclass TypeInfo {\n  constructor({name, namespace}) {\n    this.name = name;\n    this.namespace = namespace;\n  }\n\n  // The \"model\" data object specific to a domain, e.g. R4.\n  static model = null;\n\n  /**\n   * Checks for equality with another TypeInfo object, or that another TypeInfo\n   * object specifies a superclass for the type specified by this object.\n   * @param {TypeInfo} other\n   * @return {boolean}\n   */\n  is(other) {\n    if (\n      other instanceof TypeInfo &&\n      (!this.namespace || !other.namespace || this.namespace === other.namespace)\n    ) {\n      return TypeInfo.model && (!this.namespace || this.namespace === TypeInfo.FHIR)\n        ? TypeInfo.isType(this.name, other.name)\n        : this.name === other.name;\n    }\n    return false;\n  }\n\n  /**\n   * Returns the string representation of type info.\n   * @returns {string}\n   */\n  toString() {\n    return (this.namespace ? this.namespace + '.' : '') + this.name;\n  }\n\n  /**\n   * Returns true if type info represents a valid type identifier, false otherwise.\n   * @returns {boolean}\n   */\n  isValid() {\n    let result = false;\n    if (this.namespace === 'System') {\n      result = availableSystemTypes.has(this.name);\n    } else if (this.namespace === 'FHIR') {\n      result = TypeInfo.model?.availableTypes.has(this.name);\n    } else if (!this.namespace) {\n      result = availableSystemTypes.has(this.name)\n        || TypeInfo.model?.availableTypes.has(this.name);\n    }\n    return result;\n  }\n}\n\n/**\n * Defines a map from a datatype to a datatype class which has a checkString method.\n * @type {Object.<string, FP_DateTime | FP_Time>}\n */\nTypeInfo.typeToClassWithCheckString = {\n  date: FP_Date,\n  dateTime: FP_DateTime,\n  instant: FP_Instant,\n  time: FP_Time\n};\n\n/**\n * Checks if the type name or its parent type name is equal to\n * the expected type name.\n * @param type - type name to check.\n * @param superType - expected type name.\n * @return {boolean}\n */\nTypeInfo.isType = function(type, superType) {\n  do {\n    if (type === superType) {\n      return true;\n    }\n  } while ((type = TypeInfo.model?.type2Parent[type]));\n  return false;\n};\n\n// Available namespaces:\nTypeInfo.System = 'System';\nTypeInfo.FHIR = 'FHIR';\n\n/**\n * Creates new TypeInfo object for specified value in the System namespace.\n * @param {*} value\n * @return {TypeInfo}\n */\nTypeInfo.createByValueInSystemNamespace = function(value) {\n  let name = typeof value;\n\n  if (Number.isInteger(value)) {\n    name = 'integer';\n  } else if (name === \"number\") {\n    name = 'decimal';\n  } else if (value instanceof FP_Date) {\n    name = 'date';\n  } else if (value instanceof FP_DateTime) {\n    name = 'dateTime';\n  } else if (value instanceof FP_Time) {\n    name = 'time';\n  } else if (value instanceof FP_Quantity) {\n    name = 'Quantity';\n  }\n\n  name = name.replace(/^\\w/, c => c.toUpperCase());\n\n  // Currently can return name = \"Object\" which is probably wrong,\n  // but the isValid method allows you to check this.\n  return new TypeInfo({namespace: TypeInfo.System, name}) ;\n};\n\n/**\n * Retrieves TypeInfo by value\n * @param {*} value\n * @return {TypeInfo}\n */\nTypeInfo.fromValue = function (value) {\n  return value instanceof ResourceNode\n    ? value.getTypeInfo()\n    : TypeInfo.createByValueInSystemNamespace(value);\n};\n\n/**\n * Set of primitive data type names.\n */\nconst primitives = new Set();\n// IE11 probably doesn't support `new Set(iterable)`\n[\n  \"instant\",\n  \"time\",\n  \"date\",\n  \"dateTime\",\n  \"base64Binary\",\n  \"decimal\",\n  \"integer64\",\n  \"boolean\",\n  \"string\",\n  \"code\",\n  \"markdown\",\n  \"id\",\n  \"integer\",\n  \"unsignedInt\",\n  \"positiveInt\",\n  \"uri\",\n  \"oid\",\n  \"uuid\",\n  \"canonical\",\n  \"url\",\n  \"Integer\",\n  \"Decimal\",\n  \"String\",\n  \"Date\",\n  \"DateTime\",\n  \"Time\"\n].forEach(i => primitives.add(i));\n\n/**\n * Checks whether the specified type information contains a primitive data type.\n * @param {TypeInfo} typeInfo\n * @return {boolean}\n */\nTypeInfo.isPrimitive = function(typeInfo) {\n  return primitives.has(typeInfo.name);\n};\n\n/**\n * Basic \"type()\" function implementation\n * (see http://hl7.org/fhirpath/#reflection)\n * @param {Array<*>} coll - input collection\n * @return {Array<*>}\n */\nfunction typeFn(coll) {\n  return coll.map(value => {\n    return TypeInfo.fromValue(value);\n  });\n}\n\n/**\n * Implementation of function \"is(type : type specifier)\" and operator \"is\"\n * (see http://hl7.org/fhirpath/#is-type-specifier)\n * @param {Array<*>} coll - input collection\n * @param {TypeInfo} typeInfo\n * @return {boolean|[]}\n */\nfunction isFn(coll, typeInfo) {\n  if(coll.length === 0) {\n    return [];\n  }\n\n  if(coll.length > 1) {\n    throw new Error(\"Expected singleton on left side of 'is', got \" + JSON.stringify(coll));\n  }\n\n  return TypeInfo.fromValue(coll[0]).is(typeInfo);\n}\n\n/**\n * Implementation of function \"as(type : type specifier)\" and operator \"as\"\n * (see http://hl7.org/fhirpath/#as-type-specifier)\n * @param {Array<*>} coll - input collection\n * @param {TypeInfo} typeInfo\n * @return {Array<*>}\n */\nfunction asFn(coll, typeInfo) {\n  if(coll.length === 0) {\n    return [];\n  }\n\n  if(coll.length > 1) {\n    throw new Error(\"Expected singleton on left side of 'as', got \" + JSON.stringify(coll));\n  }\n\n  return TypeInfo.fromValue(coll[0]).is(typeInfo) ? coll : [];\n}\n\nmodule.exports = {\n  FP_Type,\n  FP_TimeBase,\n  FP_Date,\n  FP_DateTime,\n  FP_Instant,\n  FP_Time,\n  FP_Quantity,\n  timeRE,\n  dateTimeRE,\n  dateRE,\n  instantRE,\n  ResourceNode,\n  TypeInfo,\n  typeFn,\n  isFn,\n  asFn\n};\n","// This file holds utility functions used in implementing the public functions.\n\nconst util =  {};\nconst types = require('./types');\nconst {ResourceNode} = types;\n\n/**\n *  Reports and error to the calling environment and stops processing.\n * @param message the error message\n * @param fnName the name of the function raising the error (optional)\n */\nutil.raiseError = function(message, fnName) {\n  fnName = fnName ? fnName + \": \" : \"\";\n  throw fnName + message;\n};\n\n/**\n *  Throws an exception if the collection contains not one value.\n * @param collection the collection to be checked.\n * @param errorMsgPrefix An optional prefix for the error message to assist in\n *  debugging.\n */\nutil.assertOnlyOne = function (collection, errorMsgPrefix) {\n  if (collection.length !== 1) {\n    util.raiseError(\"Was expecting only one element but got \" +\n      JSON.stringify(collection), errorMsgPrefix);\n  }\n};\n\n/**\n *  Throws an exception if the data is not one of the expected types.\n * @param data the value to be checked.  This may be a ResourceNode.\n * @param types an array of the permitted types\n * @param errorMsgPrefix An optional prefix for the error message to assist in\n *  debugging.\n * @return the value that was checked.  If \"data\" was a ResourceNode, this will\n *  be the ReourceNode's data.\n */\nutil.assertType = function(data, types, errorMsgPrefix) {\n  let val = this.valData(data);\n  if (types.indexOf(typeof val) < 0) {\n    let typeList = types.length > 1 ? \"one of \"+types.join(\", \") : types[0];\n    util.raiseError(\"Found type '\"+(typeof data)+\"' but was expecting \" +\n      typeList, errorMsgPrefix);\n  }\n  return val;\n};\n\nutil.isEmpty = function(x){\n  return Array.isArray(x) && x.length === 0;\n};\n\nutil.isSome = function(x){\n  return x !== null && x !== undefined && !util.isEmpty(x);\n};\n\nutil.isTrue = function(x){\n  // We use util.valData because we can use a boolean node as a criterion\n  return x !== null && x !== undefined && (x === true || (x.length === 1 && util.valData(x[0]) === true));\n};\n\nutil.isCapitalized = function(x){\n  return x && (x[0] === x[0].toUpperCase());\n};\n\nutil.flatten = function(x){\n  if (x.some(i => i instanceof Promise)) {\n    return Promise.all(x).then(arr => flattenSync(arr));\n  }\n  return flattenSync(x);\n};\n\n/**\n * Creates a shallow copy of the source array and replaces those elements of the\n * source array that are arrays with their contents.\n * For example:\n * [1, [2, 3]] -> [1, 2, 3]\n * @param {Array} x - source array\n * @return {Array}\n */\nfunction flattenSync(x) {\n  return [].concat(...x);\n}\n\nutil.arraify = function(x){\n  if(Array.isArray(x)){ return x; }\n  if(util.isSome(x)){ return [x]; }\n  return [];\n};\n\n/**\n * If the input parameter is a promise, arraify the result of that promise,\n * otherwise arraify the input parameter.\n * @param {*|Promise<*>} x - input parameter\n * @return {*[]|Promise<*[]>}\n */\nutil.resolveAndArraify = function(x){\n  return x instanceof Promise\n    ? x.then(r => util.arraify(r))\n    : util.arraify(x);\n};\n\n/**\n *  Returns the data value of the given parameter, which might be a ResourceNode.\n *  Otherwise, it returns the value that was passed in.\n */\nutil.valData = function(val) {\n  return (val instanceof ResourceNode) ? val.data : val;\n};\n\n/**\n *  Returns the data value of the given parameter, which might be a ResourceNode.\n *  Otherwise, it returns the value that was passed in.  In the case of a\n *  ResourceNode that is a Quantity, the returned value will have been converted\n *  to an FP_Quantity.\n */\nutil.valDataConverted = function(val) {\n  if (val instanceof ResourceNode) {\n    val = val.convertData();\n  }\n  return val;\n};\n\n/**\n * Prepares a string for insertion into a regular expression\n * @param {string} str\n * @return {string}\n */\nutil.escapeStringForRegExp = function (str) {\n  return str.replace(/[-[\\]{}()*+?.,\\\\/^$|#\\s]/g, '\\\\$&');\n};\n\n/**\n * Binding to the Array.prototype.push.apply function to define a function to\n * push the contents of the source array to the destination array.\n * @name pushFn\n * @function\n * @param {Array} destArray - destination array\n * @param {Array} sourceArray - source array\n * @returns the new length property of destArray\n */\nutil.pushFn = Function.prototype.apply.bind(Array.prototype.push);\n\n/**\n * Creates child resource nodes for the specified resource node property.\n * @param {ResourceNode} parentResNode - resource node\n * @param {string} childProperty - name of property\n * @param {object} [model] - \"model\" data object\n * @return {ResourceNode[]}\n */\nutil.makeChildResNodes = function(parentResNode, childProperty, model) {\n  let childPath = parentResNode.path + '.' + childProperty;\n\n  if (model) {\n    let defPath = model.pathsDefinedElsewhere[childPath];\n    if (defPath)\n      childPath = defPath;\n  }\n  let toAdd, _toAdd;\n  let actualTypes = model && model.choiceTypePaths[childPath];\n  if (actualTypes) {\n    // Use actualTypes to find the field's value\n    for (let t of actualTypes) {\n      let field = childProperty + t;\n      toAdd = parentResNode.data?.[field];\n      _toAdd = parentResNode.data?.['_' + field];\n      if (toAdd !== undefined || _toAdd !== undefined) {\n        childPath += t;\n        break;\n      }\n    }\n  }\n  else {\n    toAdd = parentResNode.data?.[childProperty];\n    _toAdd = parentResNode.data?.['_' + childProperty];\n    if (toAdd === undefined && _toAdd === undefined) {\n      toAdd = parentResNode._data[childProperty];\n    }\n    if (childProperty === 'extension') {\n      childPath = 'Extension';\n    }\n  }\n\n  let fhirNodeDataType = null;\n  if (model) {\n    fhirNodeDataType = model.path2Type[childPath];\n    childPath = model.path2TypeWithoutElements[childPath] || childPath;\n  }\n\n  let result;\n  if (util.isSome(toAdd) || util.isSome(_toAdd)) {\n    if(Array.isArray(toAdd)) {\n      result = toAdd.map((x, i)=>\n        ResourceNode.makeResNode(x, parentResNode, childPath, _toAdd && _toAdd[i], fhirNodeDataType));\n      // Add items to the end of the ResourceNode list that have no value\n      // but have associated data, such as extensions or ids.\n      const _toAddLength = _toAdd?.length || 0;\n      for (let i = toAdd.length; i < _toAddLength; ++i) {\n        result.push(ResourceNode.makeResNode(null, parentResNode, childPath, _toAdd[i], fhirNodeDataType));\n      }\n    } else if (toAdd == null && Array.isArray(_toAdd)) {\n      // Add items to the end of the ResourceNode list when there are no\n      // values at all, but there is a list of associated data, such as\n      // extensions or ids.\n      result = _toAdd.map((x) => ResourceNode.makeResNode(null, parentResNode, childPath, x, fhirNodeDataType));\n    } else {\n      result = [ResourceNode.makeResNode(toAdd, parentResNode, childPath, _toAdd, fhirNodeDataType)];\n    }\n  } else {\n    result = [];\n  }\n  return result;\n};\n\nmodule.exports = util;\n","var MILLISECONDS_IN_MINUTE = 60000\n\n/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\nmodule.exports = function getTimezoneOffsetInMilliseconds (dirtyDate) {\n  var date = new Date(dirtyDate.getTime())\n  var baseTimezoneOffset = date.getTimezoneOffset()\n  date.setSeconds(0, 0)\n  var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE\n\n  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset\n}\n","var parse = require('../parse/index.js')\n\n/**\n * @category Day Helpers\n * @summary Add the specified number of days to the given date.\n *\n * @description\n * Add the specified number of days to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of days to be added\n * @returns {Date} the new date with the days added\n *\n * @example\n * // Add 10 days to 1 September 2014:\n * var result = addDays(new Date(2014, 8, 1), 10)\n * //=> Thu Sep 11 2014 00:00:00\n */\nfunction addDays (dirtyDate, dirtyAmount) {\n  var date = parse(dirtyDate)\n  var amount = Number(dirtyAmount)\n  date.setDate(date.getDate() + amount)\n  return date\n}\n\nmodule.exports = addDays\n","var addMilliseconds = require('../add_milliseconds/index.js')\n\nvar MILLISECONDS_IN_HOUR = 3600000\n\n/**\n * @category Hour Helpers\n * @summary Add the specified number of hours to the given date.\n *\n * @description\n * Add the specified number of hours to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of hours to be added\n * @returns {Date} the new date with the hours added\n *\n * @example\n * // Add 2 hours to 10 July 2014 23:00:00:\n * var result = addHours(new Date(2014, 6, 10, 23, 0), 2)\n * //=> Fri Jul 11 2014 01:00:00\n */\nfunction addHours (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR)\n}\n\nmodule.exports = addHours\n","var parse = require('../parse/index.js')\n\n/**\n * @category Millisecond Helpers\n * @summary Add the specified number of milliseconds to the given date.\n *\n * @description\n * Add the specified number of milliseconds to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of milliseconds to be added\n * @returns {Date} the new date with the milliseconds added\n *\n * @example\n * // Add 750 milliseconds to 10 July 2014 12:45:30.000:\n * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)\n * //=> Thu Jul 10 2014 12:45:30.750\n */\nfunction addMilliseconds (dirtyDate, dirtyAmount) {\n  var timestamp = parse(dirtyDate).getTime()\n  var amount = Number(dirtyAmount)\n  return new Date(timestamp + amount)\n}\n\nmodule.exports = addMilliseconds\n","var addMilliseconds = require('../add_milliseconds/index.js')\n\nvar MILLISECONDS_IN_MINUTE = 60000\n\n/**\n * @category Minute Helpers\n * @summary Add the specified number of minutes to the given date.\n *\n * @description\n * Add the specified number of minutes to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of minutes to be added\n * @returns {Date} the new date with the minutes added\n *\n * @example\n * // Add 30 minutes to 10 July 2014 12:00:00:\n * var result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)\n * //=> Thu Jul 10 2014 12:30:00\n */\nfunction addMinutes (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE)\n}\n\nmodule.exports = addMinutes\n","var parse = require('../parse/index.js')\nvar getDaysInMonth = require('../get_days_in_month/index.js')\n\n/**\n * @category Month Helpers\n * @summary Add the specified number of months to the given date.\n *\n * @description\n * Add the specified number of months to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of months to be added\n * @returns {Date} the new date with the months added\n *\n * @example\n * // Add 5 months to 1 September 2014:\n * var result = addMonths(new Date(2014, 8, 1), 5)\n * //=> Sun Feb 01 2015 00:00:00\n */\nfunction addMonths (dirtyDate, dirtyAmount) {\n  var date = parse(dirtyDate)\n  var amount = Number(dirtyAmount)\n  var desiredMonth = date.getMonth() + amount\n  var dateWithDesiredMonth = new Date(0)\n  dateWithDesiredMonth.setFullYear(date.getFullYear(), desiredMonth, 1)\n  dateWithDesiredMonth.setHours(0, 0, 0, 0)\n  var daysInMonth = getDaysInMonth(dateWithDesiredMonth)\n  // Set the last day of the new month\n  // if the original date was the last day of the longer month\n  date.setMonth(desiredMonth, Math.min(daysInMonth, date.getDate()))\n  return date\n}\n\nmodule.exports = addMonths\n","var addMilliseconds = require('../add_milliseconds/index.js')\n\n/**\n * @category Second Helpers\n * @summary Add the specified number of seconds to the given date.\n *\n * @description\n * Add the specified number of seconds to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of seconds to be added\n * @returns {Date} the new date with the seconds added\n *\n * @example\n * // Add 30 seconds to 10 July 2014 12:45:00:\n * var result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)\n * //=> Thu Jul 10 2014 12:45:30\n */\nfunction addSeconds (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMilliseconds(dirtyDate, amount * 1000)\n}\n\nmodule.exports = addSeconds\n","var addDays = require('../add_days/index.js')\n\n/**\n * @category Week Helpers\n * @summary Add the specified number of weeks to the given date.\n *\n * @description\n * Add the specified number of week to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of weeks to be added\n * @returns {Date} the new date with the weeks added\n *\n * @example\n * // Add 4 weeks to 1 September 2014:\n * var result = addWeeks(new Date(2014, 8, 1), 4)\n * //=> Mon Sep 29 2014 00:00:00\n */\nfunction addWeeks (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  var days = amount * 7\n  return addDays(dirtyDate, days)\n}\n\nmodule.exports = addWeeks\n","var addMonths = require('../add_months/index.js')\n\n/**\n * @category Year Helpers\n * @summary Add the specified number of years to the given date.\n *\n * @description\n * Add the specified number of years to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of years to be added\n * @returns {Date} the new date with the years added\n *\n * @example\n * // Add 5 years to 1 September 2014:\n * var result = addYears(new Date(2014, 8, 1), 5)\n * //=> Sun Sep 01 2019 00:00:00\n */\nfunction addYears (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMonths(dirtyDate, amount * 12)\n}\n\nmodule.exports = addYears\n","var parse = require('../parse/index.js')\n\n/**\n * @category Month Helpers\n * @summary Get the number of days in a month of the given date.\n *\n * @description\n * Get the number of days in a month of the given date.\n *\n * @param {Date|String|Number} date - the given date\n * @returns {Number} the number of days in a month\n *\n * @example\n * // How many days are in February 2000?\n * var result = getDaysInMonth(new Date(2000, 1))\n * //=> 29\n */\nfunction getDaysInMonth (dirtyDate) {\n  var date = parse(dirtyDate)\n  var year = date.getFullYear()\n  var monthIndex = date.getMonth()\n  var lastDayOfMonth = new Date(0)\n  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0)\n  lastDayOfMonth.setHours(0, 0, 0, 0)\n  return lastDayOfMonth.getDate()\n}\n\nmodule.exports = getDaysInMonth\n","/**\n * @category Common Helpers\n * @summary Is the given argument an instance of Date?\n *\n * @description\n * Is the given argument an instance of Date?\n *\n * @param {*} argument - the argument to check\n * @returns {Boolean} the given argument is an instance of Date\n *\n * @example\n * // Is 'mayonnaise' a Date?\n * var result = isDate('mayonnaise')\n * //=> false\n */\nfunction isDate (argument) {\n  return argument instanceof Date\n}\n\nmodule.exports = isDate\n","var getTimezoneOffsetInMilliseconds = require('../_lib/getTimezoneOffsetInMilliseconds/index.js')\nvar isDate = require('../is_date/index.js')\n\nvar MILLISECONDS_IN_HOUR = 3600000\nvar MILLISECONDS_IN_MINUTE = 60000\nvar DEFAULT_ADDITIONAL_DIGITS = 2\n\nvar parseTokenDateTimeDelimeter = /[T ]/\nvar parseTokenPlainTime = /:/\n\n// year tokens\nvar parseTokenYY = /^(\\d{2})$/\nvar parseTokensYYY = [\n  /^([+-]\\d{2})$/, // 0 additional digits\n  /^([+-]\\d{3})$/, // 1 additional digit\n  /^([+-]\\d{4})$/ // 2 additional digits\n]\n\nvar parseTokenYYYY = /^(\\d{4})/\nvar parseTokensYYYYY = [\n  /^([+-]\\d{4})/, // 0 additional digits\n  /^([+-]\\d{5})/, // 1 additional digit\n  /^([+-]\\d{6})/ // 2 additional digits\n]\n\n// date tokens\nvar parseTokenMM = /^-(\\d{2})$/\nvar parseTokenDDD = /^-?(\\d{3})$/\nvar parseTokenMMDD = /^-?(\\d{2})-?(\\d{2})$/\nvar parseTokenWww = /^-?W(\\d{2})$/\nvar parseTokenWwwD = /^-?W(\\d{2})-?(\\d{1})$/\n\n// time tokens\nvar parseTokenHH = /^(\\d{2}([.,]\\d*)?)$/\nvar parseTokenHHMM = /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/\nvar parseTokenHHMMSS = /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/\n\n// timezone tokens\nvar parseTokenTimezone = /([Z+-].*)$/\nvar parseTokenTimezoneZ = /^(Z)$/\nvar parseTokenTimezoneHH = /^([+-])(\\d{2})$/\nvar parseTokenTimezoneHHMM = /^([+-])(\\d{2}):?(\\d{2})$/\n\n/**\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If an argument is a string, the function tries to parse it.\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n *\n * If all above fails, the function passes the given argument to Date constructor.\n *\n * @param {Date|String|Number} argument - the value to convert\n * @param {Object} [options] - the object with options\n * @param {0 | 1 | 2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @returns {Date} the parsed date in the local time zone\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * var result = parse('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Parse string '+02014101',\n * // if the additional number of digits in the extended year format is 1:\n * var result = parse('+02014101', {additionalDigits: 1})\n * //=> Fri Apr 11 2014 00:00:00\n */\nfunction parse (argument, dirtyOptions) {\n  if (isDate(argument)) {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime())\n  } else if (typeof argument !== 'string') {\n    return new Date(argument)\n  }\n\n  var options = dirtyOptions || {}\n  var additionalDigits = options.additionalDigits\n  if (additionalDigits == null) {\n    additionalDigits = DEFAULT_ADDITIONAL_DIGITS\n  } else {\n    additionalDigits = Number(additionalDigits)\n  }\n\n  var dateStrings = splitDateString(argument)\n\n  var parseYearResult = parseYear(dateStrings.date, additionalDigits)\n  var year = parseYearResult.year\n  var restDateString = parseYearResult.restDateString\n\n  var date = parseDate(restDateString, year)\n\n  if (date) {\n    var timestamp = date.getTime()\n    var time = 0\n    var offset\n\n    if (dateStrings.time) {\n      time = parseTime(dateStrings.time)\n    }\n\n    if (dateStrings.timezone) {\n      offset = parseTimezone(dateStrings.timezone) * MILLISECONDS_IN_MINUTE\n    } else {\n      var fullTime = timestamp + time\n      var fullTimeDate = new Date(fullTime)\n\n      offset = getTimezoneOffsetInMilliseconds(fullTimeDate)\n\n      // Adjust time when it's coming from DST\n      var fullTimeDateNextDay = new Date(fullTime)\n      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1)\n      var offsetDiff =\n        getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) -\n        getTimezoneOffsetInMilliseconds(fullTimeDate)\n      if (offsetDiff > 0) {\n        offset += offsetDiff\n      }\n    }\n\n    return new Date(timestamp + time + offset)\n  } else {\n    return new Date(argument)\n  }\n}\n\nfunction splitDateString (dateString) {\n  var dateStrings = {}\n  var array = dateString.split(parseTokenDateTimeDelimeter)\n  var timeString\n\n  if (parseTokenPlainTime.test(array[0])) {\n    dateStrings.date = null\n    timeString = array[0]\n  } else {\n    dateStrings.date = array[0]\n    timeString = array[1]\n  }\n\n  if (timeString) {\n    var token = parseTokenTimezone.exec(timeString)\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], '')\n      dateStrings.timezone = token[1]\n    } else {\n      dateStrings.time = timeString\n    }\n  }\n\n  return dateStrings\n}\n\nfunction parseYear (dateString, additionalDigits) {\n  var parseTokenYYY = parseTokensYYY[additionalDigits]\n  var parseTokenYYYYY = parseTokensYYYYY[additionalDigits]\n\n  var token\n\n  // YYYY or ±YYYYY\n  token = parseTokenYYYY.exec(dateString) || parseTokenYYYYY.exec(dateString)\n  if (token) {\n    var yearString = token[1]\n    return {\n      year: parseInt(yearString, 10),\n      restDateString: dateString.slice(yearString.length)\n    }\n  }\n\n  // YY or ±YYY\n  token = parseTokenYY.exec(dateString) || parseTokenYYY.exec(dateString)\n  if (token) {\n    var centuryString = token[1]\n    return {\n      year: parseInt(centuryString, 10) * 100,\n      restDateString: dateString.slice(centuryString.length)\n    }\n  }\n\n  // Invalid ISO-formatted year\n  return {\n    year: null\n  }\n}\n\nfunction parseDate (dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) {\n    return null\n  }\n\n  var token\n  var date\n  var month\n  var week\n\n  // YYYY\n  if (dateString.length === 0) {\n    date = new Date(0)\n    date.setUTCFullYear(year)\n    return date\n  }\n\n  // YYYY-MM\n  token = parseTokenMM.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    date.setUTCFullYear(year, month)\n    return date\n  }\n\n  // YYYY-DDD or YYYYDDD\n  token = parseTokenDDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    var dayOfYear = parseInt(token[1], 10)\n    date.setUTCFullYear(year, 0, dayOfYear)\n    return date\n  }\n\n  // YYYY-MM-DD or YYYYMMDD\n  token = parseTokenMMDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    var day = parseInt(token[2], 10)\n    date.setUTCFullYear(year, month, day)\n    return date\n  }\n\n  // YYYY-Www or YYYYWww\n  token = parseTokenWww.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    return dayOfISOYear(year, week)\n  }\n\n  // YYYY-Www-D or YYYYWwwD\n  token = parseTokenWwwD.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    var dayOfWeek = parseInt(token[2], 10) - 1\n    return dayOfISOYear(year, week, dayOfWeek)\n  }\n\n  // Invalid ISO-formatted date\n  return null\n}\n\nfunction parseTime (timeString) {\n  var token\n  var hours\n  var minutes\n\n  // hh\n  token = parseTokenHH.exec(timeString)\n  if (token) {\n    hours = parseFloat(token[1].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR\n  }\n\n  // hh:mm or hhmm\n  token = parseTokenHHMM.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseFloat(token[2].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE\n  }\n\n  // hh:mm:ss or hhmmss\n  token = parseTokenHHMMSS.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseInt(token[2], 10)\n    var seconds = parseFloat(token[3].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE +\n      seconds * 1000\n  }\n\n  // Invalid ISO-formatted time\n  return null\n}\n\nfunction parseTimezone (timezoneString) {\n  var token\n  var absoluteOffset\n\n  // Z\n  token = parseTokenTimezoneZ.exec(timezoneString)\n  if (token) {\n    return 0\n  }\n\n  // ±hh\n  token = parseTokenTimezoneHH.exec(timezoneString)\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60\n    return (token[1] === '+') ? -absoluteOffset : absoluteOffset\n  }\n\n  // ±hh:mm or ±hhmm\n  token = parseTokenTimezoneHHMM.exec(timezoneString)\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10)\n    return (token[1] === '+') ? -absoluteOffset : absoluteOffset\n  }\n\n  return 0\n}\n\nfunction dayOfISOYear (isoYear, week, day) {\n  week = week || 0\n  day = day || 0\n  var date = new Date(0)\n  date.setUTCFullYear(isoYear, 0, 4)\n  var fourthOfJanuaryDay = date.getUTCDay() || 7\n  var diff = week * 7 + day + 1 - fourthOfJanuaryDay\n  date.setUTCDate(date.getUTCDate() + diff)\n  return date\n}\n\nmodule.exports = parse\n","'use strict';\n\nmodule.exports = Number.isFinite || function (value) {\n\treturn !(typeof value !== 'number' || value !== value || value === Infinity || value === -Infinity);\n};\n","// https://github.com/paulmillr/es6-shim\n// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isinteger\nvar isFinite = require(\"is-finite\");\nmodule.exports = Number.isInteger || function(val) {\n  return typeof val === \"number\" &&\n    isFinite(val) &&\n    Math.floor(val) === val;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(9090);\n"],"names":["dimLen_","validOps_","codeSep_","valMsgStart_","valMsgEnd_","cnvMsgStart_","cnvMsgEnd_","openEmph_","closeEmph_","openEmphHTML_","closeEmphHTML_","bracesMsg_","needMoleWeightMsg_","csvCols_","inputKey_","specUnits_","UC","require","isInteger","Dimension","dimSetting","_classCallCheck","Ucum","Error","this","assignZero","Array","length","concat","JSON","stringify","dimVec_","d","push","key","value","indexPos","ret","propertyName","charAt","join","dim2","_typeof","i","s","isEqual","dimVec2","undefined","allZero","that","assignDim","obj","config","data","_config","prepareConfig","map","unpackItem","bind","prototype","isArray","item","result","forEach","keyArr","place","Prefix","attrs","code_","ciCode_","name_","printSymbol_","value_","parseFloat","exp_","prefix2","PrefixTablesFactory","byCode_","byValue_","Object","keys","prefixBuff","pList","pLen","p","pfx","getPrefixByValue","prefixList","sort","getPrefixByCode","prefixObj","getCode","getValue","code","prefixTablesInstance","PrefixTables","getInstance","UcumFunctions","funcs","cnvTo","x","cnvFrom","Math","log","LN10","pow","exp","LN2","tan","atan","sqrt","func","fname","toLowerCase","f","theString","num","isNaN","str","test","theSyn","resp","retObj","UnitTables","getUnitBySynonym","aLen","a","theUnit","csCode_","guidance_","Pfx","PfxT","Un","Utab","unpackArray","UcumJsonDefs","jsonDefs","prefixes","units","unitsCount","pTab","plen","newPref","add","uTab","ulen","u","newUnit","Unit","addUnit","ucumJsonDefs","_ucumJsonDefs","intUtils_","_interopRequireWildcard","UnitString","UcumLhcUtils","loadJsonDefs","uStrParser_","use","useHTMLInMessages","useBraceMsgForEachString","uStr","suggest","valConv","getSpecifiedUnit","status","fromUnitCode","fromVal","toUnitCode","molecularWeight","returnObj","trim","_checkFromVal","fromUnit","parseResp","toUnit","moleExp_","isMoleMassCommensurable","convertMolToMass","convertMassToMol","convertFrom","err","message","inputUnitLookup","_inputUnitLookup$retM","unit","msg","retMsg","isArbitrary_","_unit$dim_","unitToExp","dimVec","dim_","baseUnitString","dimVecIndexToBaseUnit","dimVecIndexToBaseUnit_","len","retUnitLookup","retUnit","magnitude","e","toString","fromUnitIsSpecial","isSpecial_","responseObj","isNumericString","getSynonyms","uName","utab","getUnitByCode","parseString","console","unshift","origString","fromName","commUnits","fromDim","getProperty","getUnitsByDimension","_ucumFunctions","arguments","isBase_","property_","magnitude_","class_","isMetric_","variable_","cnv_","cnvPfx_","synonyms_","source_","loincProperty_","category_","csUnitString_","ciUnitString_","baseFactorStr_","baseFactor_","defError_","vals","uKey","hasOwnProperty","_this","getOwnPropertyNames","val","clone","unit2","_this2","equals","thisAttr","u2Attr","keyLen","match","k","isNull","fromCnv","fromMag","default","forName","f_from","convertCoherent","max","getMax","elem","getElementAt","uA","_getUnitTables","name","amt","molUnit","molAmt","avoNum","massUnit","mutateCoherent","mulVal","_concatStrs","isZero","resetFieldsForDerivedUnit","invertString","sub","minus","stringRep","replace","substr","str1","operator","str2","startChar","endChar","_buildOneString","endsWith","uArray","arLen","un","nun","parseInt","uLen","uChar","mul","getMassDimensionIndex","commensurable","testDim","curVal","setElementAt","utabs_","pfxTabs_","parensFlag_","pFlagLen_","braceFlag_","bFlagLen_","vcMsgStart_","vcMsgEnd_","retMsg_","parensUnits_","annotations_","suggestions","suggestions_","_getAnnotations","sUnit","indexOf","finalUnit","_parseTheString","isIntegerUnit","endProcessing","parensResp","_processParens","mkUArray","_makeUnitsArray","u1","curCode","Number","parenUnit","_getParensUnit","uRet","_makeUnit","_performUnitArithmetic","uString","openBrace","closeBrace","braceStr","substring","VALID_ANNOTATION_REGEX","aIdx","INVALID_ANNOTATION_CHAR_MSG","uStrArray","uStrAryPos","stopProcessing","pu","trimmedCt","openCt","closeCt","openPos","closePos","theMsg","c","uArray1","startNumCheck","numRes","dispVal","parensback","op","n","theOp","numRes2","invalidString","parensStr","parensString","nextParens","pStr","psIdx","befText","peIdx","lastIndexOf","aftText","pNumText","nMag","assignVals","annoRet","_getAnnoText","_getSuggestions","power","asIdx","startText","aeIdx","endText","idx","idxNum","suggSet","synLen","unitArray","uCode","getAnnoRet","_getUnitWithAnnotation","tryCode","addBrackets","retUnitAry","getUnitByName","mString","dupMsg","r","rStr","RegExp","res","origCode","origUnit","pfxCode","pfxObj","pfxVal","pfxExp","codeAndExp","_isCodeWithExponent","getExp","pCodeLen","theDim","theMag","theName","theCiCode","thePrintSymbol","expMul","theCode","getName","getCiCode","getPrintSymbol","expStr","annoText","befAnnoText","aftAnnoText","msgLen","mkUnitRet","_templateObject","tryBrackets","pop","u2","nextUnit","msgString","divide","multiplyThese","unitTablesInstance","UnitTablesFactory","unitNames_","unitCodes_","codeOrder_","unitStrings_","unitDimensions_","unitSynonyms_","massDimIndex_","addUnitName","addUnitCode","addUnitString","addUnitDimension","nonZeroIndex","caseSensitive_","uEntry","mag","uDim","uSyns","synsAry","split","addSynonymCodes","theSynonyms","words","wLen","w","word","sepPos","retUnits","retAry","unitsArray","uSyn","foundCodes","buildUnitSynonyms","fLen","nameList","codes","compareCodes","b","unitsList","cols","sep","unitBuff","getAllUnitNames","cLen","nameRecs","rec","cbuf","doLong","codeList","unitString","curUnit","curDim","Token","Lexer","Interval","BufferedTokenStream","_TokenStream","_inherits","_super","_createSuper","tokenSource","call","tokens","index","fetchedEOF","_createClass","marker","seek","lazyInit","adjustSeekIndex","LA","EOF","sync","fetch","t","nextToken","tokenIndex","type","start","stop","types","subset","contains","LT","LB","setup","channel","token","nextOnChannel","nextTokenOnChannel","DEFAULT_TOKEN_CHANNEL","from_","to","filterForChannel","prevOnChannel","previousTokenOnChannel","left","right","hidden","getSourceName","interval","fill","text","TokenStream","module","exports","CommonToken","CommonTokenFactory","_TokenFactory","copyText","source","line","column","getText","TokenFactory","DEFAULT","CommonTokenStream","_BufferedTokenStream","lexer","DEFAULT_CHANNEL","InputStream","decodeToUnicodeCodePoints","strdata","_index","codePoint","codePointAt","codeUnit","charCodeAt","_size","offset","pos","min","String","fromCodePoint","slice","get","IntervalSet","intervals","readOnly","v","INVALID_TYPE","addInterval","l","h","toAdd","existing","splice","reduce","other","current","next","toRemove","removeRange","removeOne","literalNames","symbolicNames","elemsAreChar","toTokenString","toCharString","toIndexString","names","fromCharCode","j","elementName","EPSILON","acc","_require","Set","BitSet","ATNConfig","RuleStopState","_require6","RuleTransition","NotSetTransition","WildcardTransition","AbstractPredicateTransition","_require7","predictionContextFromRuleContext","PredictionContext","SingletonPredictionContext","LL1Analyzer","atn","count","transitions","look","alt","lookBusy","_LOOK","transition","target","EMPTY","HIT_PRED","stopState","ctx","lookContext","calledRuleStack","seeThruPreds","addEOF","state","context","addOne","isEmpty","removed","ruleIndex","remove","returnState","states","getReturnState","getParent","constructor","newContext","create","followState","stateNumber","isEpsilon","addRange","MIN_USER_TOKEN_TYPE","maxTokenType","set","label","complement","addSet","Recognizer","RecognitionException","LexerNoViableAltException","_Recognizer","input","_input","_factory","_tokenFactorySourcePair","_assertThisInitialized","_interp","_token","_tokenStartCharIndex","_tokenStartLine","_tokenStartColumn","_hitEOF","_channel","_type","_modeStack","_mode","DEFAULT_MODE","_text","reset","tokenStartMarker","mark","emitEOF","continueOuter","ttype","SKIP","stack","notifyListeners","recover","MORE","emit","release","m","debug","mode","getCharIndex","emitToken","cpos","lpos","eof","getErrorDisplay","getErrorListenerDispatch","syntaxError","getErrorDisplayForChar","re","consume","sourceName","HIDDEN","HIDDEN_CHANNEL","MIN_CHAR_VALUE","MAX_CHAR_VALUE","_require2","ParseTreeListener","TerminalNode","ErrorNode","DefaultErrorStrategy","ATNDeserializer","ATNDeserializationOptions","TraceListener","_ParseTreeListener","parser","ruleNames","node","symbol","_ctx","Parser","_super2","_errHandler","_precedenceStack","buildParseTrees","_tracer","_parseListeners","_syntaxErrors","setInputStream","setTrace","getCurrentToken","reportMatch","recoverInline","addErrorNode","_buildParseTrees","listener","enterEveryRule","enterRule","reverse","exitRule","exitEveryRule","factory","serializedAtn","getSerializedATN","bypassAltsAtnCache","deserializationOptions","generateRuleBypassTransitions","deserialize","pattern","patternRuleIndex","getTokenStream","ParseTreePatternMatcher","compile","setTokenStream","offendingToken","o","getInputStream","hasListener","inErrorRecoveryMode","addTokenNode","invokingState","isErrorNode","visitErrorNode","visitTerminal","parentCtx","addChild","localctx","addContextToParseTree","triggerEnterRuleEvent","triggerExitRuleEvent","altNum","setAltNumber","removeLastChild","precedence","previous","retCtx","parseListeners","getParseListeners","following","nextTokens","rt","getExpectedTokens","ruleName","getRuleIndexMap","decisionToDFA","seenOne","dfa","printer","println","decision","print","trace","removeParseListener","addParseListener","RuleContext","Tree","INVALID_INTERVAL","TerminalNodeImpl","ErrorNodeImpl","ParserRuleContext","_RuleContext","parent","invokingStateNumber","children","exception","child","badToken","ctxType","getChild","contexts","Hash","Map","equalArrays","cachedHashCode","EMPTY_RETURN_STATE","hash","update","globalNodeCount","id","PredictionContextCache","cache","put","_PredictionContext","hashCode","finish","up","EmptyPredictionContext","_SingletonPredictionC","ArrayPredictionContext","_PredictionContext2","_super3","parents","returnStates","_possibleConstructorReturn","merge","rootIsWildcard","mergeCache","rootMerge","payloads","mergeRoot","spc","singleParent","apc","a_","mergeSingletons","mergedReturnStates","mergedParents","a_parent","b_parent","payload","M","uniqueParents","containsKey","q","combineCommonParents","mergeArrays","outerContext","getCachedPredictionContext","contextCache","visited","changed","updated","ConsoleErrorListener","ProxyErrorListener","_listeners","INSTANCE","_stateNumber","toolVersion","getPrototypeOf","tokenNames","getLiteralNames","getSymbolicNames","getTokenNames","tokenTypeMapCache","ruleIndexMapCache","tokenName","getTokenTypeMap","getOffendingToken","actionIndex","RuleNode","Trees","_RuleNode","getChildCount","altNumber","visitor","visitChildren","recog","toStringTree","ri","_Token","EMPTY_SOURCE","txt","size","valueToString","arrayToString","standardEqualsFunction","standardHashCodeFunction","seed","round","random","h1b","k1","remainder","bytes","h1","c1","c2","hashFunction","equalsFunction","values","bits","apply","hashKey","entries","entry","oldValue","AltDict","DoubleDict","defaultMapCtor","cacheMap","updateHashCode","hashStuff","escapeWhitespace","escapeSpaces","titleCase","toUpperCase","ATN","grammarType","decisionToState","ruleToStartState","ruleToStopState","modeNameToStartState","ruleToTokenType","lexerActions","modeToStartState","LOOK","nextTokenWithinRule","nextTokensInContext","nextTokensNoContext","expected","INVALID_ALT_NUMBER","DecisionState","SemanticContext","checkParams","params","isCfg","semanticContext","reachesIntoOuterContext","props","precedenceFilterSuppressed","checkContext","NONE","LexerATNConfig","_ATNConfig","lexerActionExecutor","passedThroughNonGreedyDecision","checkNonGreedyDecision","hashCodeForConfigSet","equalsForConfigSet","_get","_getPrototypeOf","nonGreedy","Utils","hashATNConfig","equalATNConfigs","ATNConfigSet","fullCtx","configLookup","configs","uniqueAlt","conflictingAlts","hasSemanticContext","dipsIntoOuterContext","merged","preds","interpreter","getCachedContext","coll","containsFast","OrderedATNConfigSet","_ATNConfigSet","copyFrom","verifyATN","defaultOptions","ATNType","ATNState","BasicState","BlockStartState","BlockEndState","LoopEndState","RuleStartState","TokensStartState","PlusLoopbackState","StarLoopbackState","StarLoopEntryState","PlusBlockStartState","StarBlockStartState","BasicBlockStartState","_require3","Transition","AtomTransition","SetTransition","RangeTransition","ActionTransition","EpsilonTransition","PredicateTransition","PrecedencePredicateTransition","_require5","LexerActionType","LexerSkipAction","LexerChannelAction","LexerCustomAction","LexerMoreAction","LexerTypeAction","LexerPushModeAction","LexerPopModeAction","LexerModeAction","ADDED_UNICODE_SMP","SUPPORTED_UUIDS","SERIALIZED_UUID","initArray","tmp","options","stateFactories","actionFactories","feature","actualUuid","idx1","checkVersion","checkUUID","readATN","readStates","readRules","readModes","sets","readSets","readInt","isFeatureSupported","uuid","readInt32","readEdges","readDecisions","readLexerActions","markPrecedenceDecisions","PARSER","temp","version","readUUID","pair","loopBackStateNumbers","endStateNumbers","nstates","stype","stateFactory","LOOP_END","loopBackStateNumber","endStateNumber","addState","loopBackState","endState","numNonGreedyStates","numPrecedenceStates","isPrecedenceRule","nrules","LEXER","tokenType","nmodes","readUnicode","iset","i1","i2","trans","nedges","src","trg","arg1","arg2","arg3","edgeFactory","addTransition","outermostPrecedenceReturn","startState","ndecisions","decState","actionType","data1","data2","lexerActionFactory","generateRuleBypassTransition","bypassStart","bypassStop","defineDecisionState","excludeTransition","stateIsEndStateFor","matchState","maybeLoopEndState","epsilonOnlyTransitions","isPrecedenceDecision","checkCondition","condition","bb","int","byteToHex","RANGE","RULE","PREDICATE","PRECEDENCE","ATOM","ACTION","SET","NOT_SET","WILDCARD","sf","BASIC","RULE_START","BLOCK_START","PLUS_BLOCK_START","STAR_BLOCK_START","TOKEN_START","RULE_STOP","BLOCK_END","STAR_LOOP_BACK","STAR_LOOP_ENTRY","PLUS_LOOP_BACK","af","CHANNEL","CUSTOM","MODE","POP_MODE","PUSH_MODE","TYPE","bth","createByteToHex","DFAState","ATNSimulator","sharedContextCache","ERROR","INVALID_STATE_NUMBER","stateType","serializationNames","_ATNState","_ATNState2","_DecisionState","_this3","_BlockStartState","_super4","_this4","_ATNState3","_super5","_this5","_ATNState4","_super6","_this6","_ATNState5","_super7","_this7","_DecisionState2","_super8","_this8","_BlockStartState2","_super9","_this9","_BlockStartState3","_super10","_this10","_ATNState6","_super11","_this11","_DecisionState3","_super12","_this12","_ATNState7","_super13","_this13","_DecisionState4","_super14","_this14","LexerActionExecutor","resetSimState","sim","dfaState","SimState","LexerATNSimulator","_ATNSimulator","startIndex","prevAccept","simulator","match_calls","s0","matchATN","execATN","old_mode","s0_closure","computeStartState","suppressEdge","addDFAState","predict","toLexerString","ds0","isAcceptState","captureSimState","getExistingTargetState","computeTargetState","failOrAccept","edges","MIN_DFA_EDGE","MAX_DFA_EDGE","reach","getReachableConfigSet","items","addDFAEdge","accept","prediction","closure","skipAlt","cfg","currentAltReachedAcceptState","getTokenName","getReachableTarget","fixOffsetBeforeMatch","treatEofAsEpsilon","charPos","execute","matches","initialContext","speculative","hasEmptyPath","getEpsilonTarget","serializationType","predIndex","evaluatePredicate","append","sempred","savedcolumn","savedLine","settings","tk","cfgs","proposed","firstConfigWithRuleStopState","newState","setReadonly","tt","dfa_debug","LexerAction","action","isPositionDependent","_LexerAction","skip","_LexerAction2","_LexerAction3","pushMode","_LexerAction4","popMode","_LexerAction5","more","_LexerAction6","_LexerAction7","_LexerAction8","LexerIndexedCustomAction","_LexerAction9","lexerAction","updatedLexerActions","requiresSeek","stopIndex","numActions","PredPrediction","PredictionMode","_require9","NoViableAltException","_require11","ParserATNSimulator","predictionMode","LL","_startIndex","_outerContext","_dfa","debug_closure","debug_add","debug_list_atn_decisions","retry_debug","getLookaheadName","precedenceDfa","getPrecedenceStartState","getPrecedence","atnStartState","applyPrecedenceFilter","setPrecedenceStartState","previousD","D","noViableAlt","getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule","requiresFullContext","SLL","predicates","conflictIndex","evalSemanticContext","minValue","reportAttemptingFullContext","execATNWithFullContext","alts","reportAmbiguity","computeReachSet","predictedAlt","getUniqueAlt","altSubSets","getConflictingAltSubsets","allSubsetsConflict","getConflictingAlts","hasSLLConflictTerminatingPrediction","predicateDFAState","getDecisionState","decisionState","nalts","altsToCollectPredsFrom","getConflictingAltsOrUniqueAlt","altToPred","getPredsForAmbigAlts","getPredicatePredictions","foundExactAmbig","resolvesToJustOneViableAlt","LL_EXACT_AMBIG_DETECTION","allSubsetsEqual","getSingleViableAlt","reportContextSensitivity","intermediate","skippedStopStates","closureBusy","removeAllConfigsNotInRuleStopState","hasConfigInRuleStopState","lookToEndOfRule","allConfigsInRuleStopStates","endOfRuleState","statesFromAlt1","configSet","updatedContext","evalPrecedence","ambigAlts","orContext","nPredAlts","pred","pairs","containsPredicate","splitAccordingToSemanticValidity","semValidConfigs","semInvalidConfigs","getAltThatFinishedDecisionEntryRule","succeeded","failed","evaluate","predPredictions","complete","predictions","predicateEvaluationResult","collectPredicates","closureCheckingStopState","depth","parms","getRuleName","closure_","canDropLoopEntryEdgeInLeftRecursiveRule","continueCollecting","newDepth","numCtxs","blockEndStateNum","blockEndState","returnStateNumber","returnStateTarget","inContext","ruleTransition","precedenceTransition","predTransition","actionTransition","pt","getRuleInvocationStack","currentPosition","predSucceeds","getPredicate","newSemCtx","andContext","isCtxDependent","altsets","getAlts","getTokens","nvae","decs","getDeadEndConfigs","error","optimizeConfigs","exact","dup","hasConflictingAltSet","hasStateAssociatedWithOneAlt","hasNonConflictingAltSet","first","all","or","configToAlts","getValues","getStateToAltMap","minAlt","AND","opnds","OR","Predicate","_SemanticContext","PrecedencePredicate","_SemanticContext2","precpred","_SemanticContext3","operands","precedencePredicates","filterPrecedencePredicates","reduced","from","differs","evaluated","_SemanticContext4","compareTo","serializationTypes","_Transition","label_","makeLabel","minVocabSymbol","maxVocabSymbol","_Transition2","ruleStart","_Transition3","_Transition4","_Transition5","_AbstractPredicateTra","_Transition6","_Transition7","_SetTransition","_Transition8","_AbstractPredicateTra2","DFASerializer","LexerDFASerializer","DFA","_states","precedenceState","buf","sortedStates","getStateString","getEdgeLabel","baseStateStr","_DFASerializer","ErrorListener","DiagnosticErrorListener","_ErrorListener","exactOnly","recognizer","getDecisionDescription","notifyErrorListeners","reportedAlts","offendingSymbol","_ErrorListener2","delegates","InputMismatchException","FailedPredicateException","ParseCancellationException","_require4","_ErrorStrategy","errorRecoveryMode","lastErrorIndex","lastErrorStates","nextTokensContext","nextTokenState","endErrorCondition","beginErrorCondition","reportNoViableAlternative","reportInputMismatch","reportFailedPredicate","getMessage","followSet","getErrorRecoverySet","consumeUntil","la","nextTokensState","singleTokenDeletion","reportUnwantedToken","expecting","whatFollowsLoopIterationOrRule","startToken","escapeWSAndQuote","getTokenErrorDisplay","matchedSymbol","singleTokenInsertion","getMissingSymbol","currentSymbolType","reportMissingToken","nextTokenType","tokenText","currentSymbol","expectedTokenType","lookback","getTokenFactory","recoverSet","follow","ErrorStrategy","BailErrorStrategy","_DefaultErrorStrategy","_Error","captureStackTrace","offendingState","_wrapNativeSuper","_RecognitionException","deadEndConfigs","_RecognitionException2","_RecognitionException3","formatMessage","predicate","_RecognitionException4","predicateIndex","_Error2","defineProperty","object","$defineProperty","position","TypeError","string","second","stringFromCharCode","floor","_","highSurrogate","lowSurrogate","codeUnits","isFinite","RangeError","ParseTree","_SyntaxTree","_Tree","SyntaxTree","_ParseTree","_ParseTree2","_TerminalNode","ParseTreeVisitor","visit","_TerminalNode2","_TerminalNodeImpl","ParseTreeWalker","walk","getRuleContext","tree","getNodeText","getAltNumber","getPayload","getChildren","list","getAncestors","ancestors","findAllTokenNodes","findAllNodes","findAllRuleNodes","findTokens","nodes","_findAllNodes","descendants","_objectSpread","util","Terminologies","engine","valueset","async","terminologies","processedVars","validateVS","valData","then","parameter","find","valueBoolean","math","equality","minMaxShortcutTemplate","fn","$total","$this","isTrue","aggregateMacro","expr","initialValue","total","Promise","$index","countFn","sumFn","arraify","filter","y","plus","minFn","lt","maxFn","gt","avgFn","div","deepEqual","containsImpl","in","combineFns","distinctFn","hashObject","maxCollSizeForDeepEqual","union","coll1","coll2","combineFn","intersect","coll1Length","uncheckedLength","coll2hash","obj1","some","obj2","exclude","coll2Length","item2","nowDate","Date","today","now","timeOfDay","localTimezoneOffset","constants","FP_Date","FP_DateTime","FP_Time","isoStr","isoDateTime","isoDate","isoTime","FP_Type","FP_Quantity","numbers","pSlice","objectKeys","isArguments","isString","myVar","isNumber","normalizeStr","isUndefinedOrNull","actual","opts","valDataConverted","fuzzy","isEquivalent","getTime","actualIsFPT","expectedIsFPT","equivalentTo","anotherIsNumber","ka","kb","objEquiv","equivalence","typecheck","assertOnlyOne","lClass","rClass","raiseError","equal","unequal","eq","equival","unequival","_typecheck2","_slicedToArray","a0","b0","compare","_typecheck4","lte","_typecheck6","gte","_typecheck8","whereMacro","misc","subsetOf","rtn","c2Hash","_loop","emptyFn","notFn","singleton","existsMacro","exprRes","allMacro","promises","allTrueFn","assertType","anyTrueFn","allFalseFn","anyFalseFn","subsetOfFn","supersetOfFn","isDistinctFn","ResourceNode","TypeInfo","instantRE","timeRE","dateRE","dateTimeRE","Factory","self","url","makeResNode","createExtensionObject","_defineProperty","fromValue","system","typeColl","isSome","typeInfo","isType","family","givenColl","prefix","suffix","given","lineColl","city","postalCode","country","display","valueColl","coding","getTypeInfo","namespace","System","instanceColl","instance","_instance$_data","_instance$data","_data","isPrimitive","extension","_toConsumableArray","path","fhirNodeDataType","_value$","_value$2","Extension","arity","Identifier","HumanName","ContactPoint","Address","Quantity","Coding","CodeableConcept","withExtension","withProperty","_ref4","primitiveType","extensions","extensionDataType","invocationTable","existence","filtering","aggregate","supplements","combining","collections","strings","navigation","datetime","additional","logic","getStringLiteralVal","submatch","getIdentifierVal","makeParam","parentData","param","ctxExpr","definedVars","doEval","dataRoot","TypeSpecifier","isNullable","infixInvoke","fnName","rawParams","invoc","paramsNumber","argTypes","tp","pr","nullable","parse","applyParsedPath","resource","parsedPath","envVars","model","__path__","parentResNode","resourceType","ucum","processedUserVarNames","vars","traceFn","customTraceFn","userInvocationTable","defaultScoreExts","terminologyUrl","prepareEvalResult","resolve","resolveInternalTypes","internalStructures","_len","args","_key","arg","expression","fhirData","base","basePath","pathsDefinedElsewhere","baseFhirNodeDataType","path2Type","memberOf","empty","not","exists","allTrue","anyTrue","allFalse","anyFalse","supersetOf","isDistinct","distinct","where","select","selectMacro","sum","avg","weight","ordinal","single","singleFn","firstFn","last","lastFn","typeFn","ofType","ofTypeFn","is","isFn","as","asFn","tail","tailFn","take","takeFn","skipFn","combine","iif","iifMacro","defineVariable","toInteger","toDecimal","toDate","toDateTime","toTime","toBoolean","toQuantity","hasValue","hasValueFn","getValueFn","convertsToBoolean","createConvertsToFn","convertsToInteger","convertsToDecimal","convertsToString","convertsToDate","convertsToDateTime","convertsToTime","convertsToQuantity","startsWith","containsFn","upper","lower","replaceMatches","toChars","joinFn","splitFn","trimFn","encode","encodeFn","decode","decodeFn","abs","ceiling","ln","truncate","repeat","repeatMacro","amp","mod","intdiv","orOp","andOp","xorOp","impliesOp","InvocationExpression","ch","TermExpression","PolarityExpression","sign","terminalNodeText","identifiers","_identifiers","isValid","ExternalConstantTerm","varName","_value","_value2","extConstant","has","LiteralTerm","term","StringLiteral","BooleanLiteral","QuantityLiteral","valueNode","unitNode","DateTimeLiteral","dateStr","TimeLiteral","timeStr","NumberLiteral","InvocationTerm","MemberInvocation","_res$__path__","_res$__path__2","_res$data","pushFn","makeChildResNodes","IndexerExpression","coll_node","idx_node","Functn","realizeParams","FunctionInvocation","shift","_ctx$userInvocationTa","_data$","resolveAndArraify","doInvoke","ParamList","UnionExpression","ThisInvocation","TotalInvocation","IndexInvocation","OpExpression","AliasOpExpression","alias","NullLiteral","ParenthesizedTerm","evalTable","EqualityExpression","InequalityExpression","AdditiveExpression","MultiplicativeExpression","TypeExpression","MembershipExpression","EntireExpression","OrExpression","ImpliesExpression","AndExpression","XorExpression","doEvalSync","evaluator","_i","_Object$keys","fhirpathResult","_value$__path__","_value$__path__2","_value$__path__3","ti","ucumUtils","getNewItems","unique","newItems","isUnique","flatten","_ref","_ref2","uniqueHash","xObj","xStr","roundToMaxPrecision","prepareObject","toISOString","_yearMonthConversionFactor","ucumQuantity","toUcumQuantity","callFnForNumericSingleton","xs","ys","ceil","exponent","precision","degree","trunc","iifMacroSync","ok","fail","cond","includes","intRegex","quantityRegex","thisUnitInSeconds","_calendarDuration2Seconds","toUnitInSeconds","mapTimeUnitsToUCUMCode","quantityRegexRes","exec","time","convUnitTo","numRegex","defineTimeConverter","timeType","timeName","checkString","trueStrings","falseStrings","lowerCaseValue","toFunction","singletonEvalByType","toSingleton","prop","numberFns","decimalPlaces","fraction","roundToDecimalPlaces","scale","prec","codepointat","fromcodepoint","pc","antlr4","serializedATN","decisionsToDFA","ds","FHIRPathLexer","_antlr4$Lexer","T__0","T__1","T__2","T__3","T__4","T__5","T__6","T__7","T__8","T__9","T__10","T__11","T__12","T__13","T__14","T__15","T__16","T__17","T__18","T__19","T__20","T__21","T__22","T__23","T__24","T__25","T__26","T__27","T__28","T__29","T__30","T__31","T__32","T__33","T__34","T__35","T__36","T__37","T__38","T__39","T__40","T__41","T__42","T__43","T__44","T__45","T__46","T__47","T__48","T__49","T__50","T__51","T__52","T__53","DATETIME","TIME","IDENTIFIER","DELIMITEDIDENTIFIER","STRING","NUMBER","WS","COMMENT","LINE_COMMENT","FHIRPathListener","_antlr4$tree$ParseTre","FHIRPathParser","_antlr4$Parser","expression_sempred","EntireExpressionContext","RULE_entireExpression","enterOuterAlt","reportError","_p","_parentctx","_parentState","ExpressionContext","enterRecursionRule","RULE_expression","_la","TermExpressionContext","PolarityExpressionContext","_alt","adaptivePredict","MultiplicativeExpressionContext","pushNewRecursionContext","AdditiveExpressionContext","UnionExpressionContext","InequalityExpressionContext","EqualityExpressionContext","MembershipExpressionContext","AndExpressionContext","OrExpressionContext","ImpliesExpressionContext","InvocationExpressionContext","invocation","IndexerExpressionContext","TypeExpressionContext","typeSpecifier","unrollRecursionContexts","TermContext","RULE_term","InvocationTermContext","LiteralTermContext","literal","ExternalConstantTermContext","externalConstant","ParenthesizedTermContext","LiteralContext","RULE_literal","NullLiteralContext","BooleanLiteralContext","StringLiteralContext","NumberLiteralContext","DateTimeLiteralContext","TimeLiteralContext","QuantityLiteralContext","quantity","ExternalConstantContext","RULE_externalConstant","identifier","InvocationContext","RULE_invocation","MemberInvocationContext","FunctionInvocationContext","functn","ThisInvocationContext","IndexInvocationContext","TotalInvocationContext","FunctnContext","RULE_functn","paramList","ParamListContext","RULE_paramList","QuantityContext","RULE_quantity","UnitContext","RULE_unit","dateTimePrecision","pluralDateTimePrecision","DateTimePrecisionContext","RULE_dateTimePrecision","PluralDateTimePrecisionContext","RULE_pluralDateTimePrecision","TypeSpecifierContext","RULE_typeSpecifier","qualifiedIdentifier","QualifiedIdentifierContext","RULE_qualifiedIdentifier","IdentifierContext","RULE_identifier","_antlr4$ParserRuleCon","getTypedRuleContext","getToken","enterEntireExpression","exitEntireExpression","_antlr4$ParserRuleCon2","_ExpressionContext","_thisSuper","getTypedRuleContexts","enterIndexerExpression","exitIndexerExpression","_ExpressionContext2","_thisSuper2","enterPolarityExpression","exitPolarityExpression","_ExpressionContext3","_thisSuper3","enterAdditiveExpression","exitAdditiveExpression","_ExpressionContext4","_thisSuper4","enterMultiplicativeExpression","exitMultiplicativeExpression","_ExpressionContext5","_thisSuper5","enterUnionExpression","exitUnionExpression","_ExpressionContext6","_thisSuper6","enterOrExpression","exitOrExpression","_ExpressionContext7","_thisSuper7","enterAndExpression","exitAndExpression","_ExpressionContext8","_thisSuper8","enterMembershipExpression","exitMembershipExpression","_ExpressionContext9","_thisSuper9","enterInequalityExpression","exitInequalityExpression","_ExpressionContext10","_thisSuper10","enterInvocationExpression","exitInvocationExpression","_ExpressionContext11","_thisSuper11","enterEqualityExpression","exitEqualityExpression","_ExpressionContext12","_super15","_thisSuper12","_this15","enterImpliesExpression","exitImpliesExpression","_ExpressionContext13","_super16","_thisSuper13","_this16","enterTermExpression","exitTermExpression","_ExpressionContext14","_super17","_thisSuper14","_this17","enterTypeExpression","exitTypeExpression","_antlr4$ParserRuleCon3","_super18","_this18","_TermContext","_super19","_thisSuper15","_this19","enterExternalConstantTerm","exitExternalConstantTerm","_TermContext2","_super20","_thisSuper16","_this20","enterLiteralTerm","exitLiteralTerm","_TermContext3","_super21","_thisSuper17","_this21","enterParenthesizedTerm","exitParenthesizedTerm","_TermContext4","_super22","_thisSuper18","_this22","enterInvocationTerm","exitInvocationTerm","_antlr4$ParserRuleCon4","_super23","_this23","_LiteralContext","_super24","_thisSuper19","_this24","enterTimeLiteral","exitTimeLiteral","_LiteralContext2","_super25","_thisSuper20","_this25","enterNullLiteral","exitNullLiteral","_LiteralContext3","_super26","_thisSuper21","_this26","enterDateTimeLiteral","exitDateTimeLiteral","_LiteralContext4","_super27","_thisSuper22","_this27","enterStringLiteral","exitStringLiteral","_LiteralContext5","_super28","_thisSuper23","_this28","enterBooleanLiteral","exitBooleanLiteral","_LiteralContext6","_super29","_thisSuper24","_this29","enterNumberLiteral","exitNumberLiteral","_LiteralContext7","_super30","_thisSuper25","_this30","enterQuantityLiteral","exitQuantityLiteral","_antlr4$ParserRuleCon5","_super31","_this31","enterExternalConstant","exitExternalConstant","_antlr4$ParserRuleCon6","_super32","_this32","_InvocationContext","_super33","_thisSuper26","_this33","enterTotalInvocation","exitTotalInvocation","_InvocationContext2","_super34","_thisSuper27","_this34","enterThisInvocation","exitThisInvocation","_InvocationContext3","_super35","_thisSuper28","_this35","enterIndexInvocation","exitIndexInvocation","_InvocationContext4","_super36","_thisSuper29","_this36","enterFunctionInvocation","exitFunctionInvocation","_InvocationContext5","_super37","_thisSuper30","_this37","enterMemberInvocation","exitMemberInvocation","_antlr4$ParserRuleCon7","_super38","_this38","enterFunctn","exitFunctn","_antlr4$ParserRuleCon8","_super39","_this39","enterParamList","exitParamList","_antlr4$ParserRuleCon9","_super40","_this40","enterQuantity","exitQuantity","_antlr4$ParserRuleCon10","_super41","_this41","enterUnit","exitUnit","_antlr4$ParserRuleCon11","_super42","_this42","enterDateTimePrecision","exitDateTimePrecision","_antlr4$ParserRuleCon12","_super43","_this43","enterPluralDateTimePrecision","exitPluralDateTimePrecision","_antlr4$ParserRuleCon13","_super44","_this44","enterTypeSpecifier","exitTypeSpecifier","_antlr4$ParserRuleCon14","_super45","_this45","enterQualifiedIdentifier","exitQualifiedIdentifier","_antlr4$ParserRuleCon15","_super46","_this46","enterIdentifier","exitIdentifier","Listener","_antlr4$error$ErrorLi","errors","sym","col","chars","removeErrorListeners","addErrorListener","_step","entireExpression","PathListener","_Listener","ast","parentStack","_iterator","_createForOfIteratorHelper","parentNode","nodeType","_step2","_iterator2","done","errMsgs","Function","searchString","subjectString","lastIndex","assign","nextSource","nextKey","btoa","global","Buffer","atob","b64Encoded","_this$processedVars$q","userScoreExtUrl","scoreExt","checkExtUrl","questionnaire","_value$extension","_value$extension$find","valueCoding","_item$_data","score","valueDecimal","linkIds","_node$data","linkId","getLinkIds","_qItem$answerOption","qItem","currentNode","_currentNode$item","_ret","getQItemByLinkIds","answerOption","_answerOption$extensi","_answerOption$extensi2","cachedRegExp","postfix","separator","stringValues","strToSplit","strToTrim","format","strToEncode","encodeURIComponent","strDecode","decodeURIComponent","dotAllIsSupported","dotAll","regex","entirePattern","cleanPrecedingPart","escaped","lastIndexOfOpenBracket","lastIndexOfCloseBracket","repl","reg","escapeStringForRegExp","coded","response","myHeaders","Headers","requestUrl","parameters","method","headers","body","queryParams1","URLSearchParams","json","bundle","_bundle$entry","_bundle$entry$0$resou","_bundle$entry$0$resou2","getSystemFromArrayItems","expansion","compose","include","queryParams2","_coded$system","queryParams","catch","createIndexKeyMemberOf","arr","addMinutes","timeFormat","asStr","_FP_Type","otherQuantity","otherUnitInSeconds","compareYearsAndMonths","_compareYearsAndMonths","thisQuantity","normalizedOtherQuantity","convResult","convertUnitTo","toVal","ucumUnitCode","getEquivalentUcumUnitCode","otherUcumUnitCode","thisConvFactor","otherConvFactor","thisUcumUnitCode","surroundingApostrophesRegex","thisValue","otherValue","thisQ","convToUcumUnits","otherQ","resultUnit","convertToBaseUnits","unitInSeconds","convRes","magnitude1","magnitude2","fromYearMonthMagnitude","toYearMonthMagnitude","fromMagnitude","toMagnitude","dateTimeArithmeticDurationUnits","mapUCUMCodeToTimeUnits","FP_TimeBase","_FP_Type2","timeQuantity","timeUnit","cls","unitPrecision","_timeUnitToDatePrecision","qVal","isTime","_getPrecision","neededUnit","_datePrecisionToTimeUnit","newQuantity","newDate","timeUnitToAddFn","_getDateObj","newDateStr","otherDateTime","thisPrec","otherPrec","commonPrec","thisUTCStr","otherUTCStr","thisAdj","_getTimeParts","otherAdj","otherTime","thisPrecision","otherPrecision","thisTimeInt","_dateAtPrecision","otherTimeInt","_getMatchData","regEx","maxPrecision","timeMatchData","timeParts","timeZone","hours","sec","ms","dateObj","year","month","day","hour","minutes","seconds","timezoneOffset","localTimezoneMinutes","getTimezoneOffset","timezoneMinutes","timezoneParts","_FP_TimeBase","_createDate","getFullYear","getMonth","getDate","getHours","getMinutes","_FP_TimeBase2","setYear","setMonth","setDate","formatNum","date","tzOffset","tzSign","tzMin","getSeconds","getMilliseconds","_FP_DateTime","FP_Instant","_FP_DateTime2","instantStr","$1","FHIR","createByValueInSystemNamespace","convertedData","typeToClassWithCheckString","_data2","comparator","availableSystemTypes","_TypeInfo$model","availableTypes","_TypeInfo$model2","dateTime","instant","superType","_TypeInfo$model3","type2Parent","primitives","flattenSync","collection","errorMsgPrefix","typeList","isCapitalized","convertData","childProperty","_toAdd","childPath","defPath","actualTypes","choiceTypePaths","_parentResNode$data","_parentResNode$data2","field","_parentResNode$data3","_parentResNode$data4","path2TypeWithoutElements","_toAdd2","_toAddLength","dirtyDate","baseTimezoneOffset","setSeconds","dirtyAmount","amount","addMilliseconds","timestamp","getDaysInMonth","desiredMonth","dateWithDesiredMonth","setFullYear","setHours","daysInMonth","addDays","addMonths","monthIndex","lastDayOfMonth","argument","getTimezoneOffsetInMilliseconds","isDate","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","parseTokenDateTimeDelimeter","parseTokenPlainTime","parseTokenYY","parseTokensYYY","parseTokenYYYY","parseTokensYYYYY","parseTokenMM","parseTokenDDD","parseTokenMMDD","parseTokenWww","parseTokenWwwD","parseTokenHH","parseTokenHHMM","parseTokenHHMMSS","parseTokenTimezone","parseTokenTimezoneZ","parseTokenTimezoneHH","parseTokenTimezoneHHMM","dayOfISOYear","isoYear","week","setUTCFullYear","diff","getUTCDay","setUTCDate","getUTCDate","dirtyOptions","additionalDigits","timezoneString","absoluteOffset","dateStrings","dateString","timeString","array","timezone","splitDateString","parseYearResult","parseTokenYYY","parseTokenYYYYY","yearString","restDateString","centuryString","parseYear","dayOfYear","parseDate","parseTime","fullTime","fullTimeDate","fullTimeDateNextDay","offsetDiff","Infinity","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","g","globalThis","window","__webpack_exports__"],"sourceRoot":""}